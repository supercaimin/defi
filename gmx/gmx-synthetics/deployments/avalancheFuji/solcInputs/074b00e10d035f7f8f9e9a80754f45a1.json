{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/bank/Bank.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../token/TokenUtils.sol\";\nimport \"../role/RoleModule.sol\";\n\n// @title Bank\n// @dev Contract to handle storing and transferring of tokens\ncontract Bank is RoleModule {\n    using SafeERC20 for IERC20;\n\n    DataStore public immutable dataStore;\n\n    constructor(RoleStore _roleStore, DataStore _dataStore) RoleModule(_roleStore) {\n        dataStore = _dataStore;\n    }\n\n    receive() external payable {\n        address wnt = TokenUtils.wnt(dataStore);\n        if (msg.sender != wnt) {\n            revert Errors.InvalidNativeTokenSender(msg.sender);\n        }\n    }\n\n    // @dev transfer tokens from this contract to a receiver\n    //\n    // @param token the token to transfer\n    // @param amount the amount to transfer\n    // @param receiver the address to transfer to\n    function transferOut(\n        address token,\n        address receiver,\n        uint256 amount\n    ) external onlyController {\n        _transferOut(token, receiver, amount);\n    }\n\n    // @dev transfer tokens from this contract to a receiver\n    // handles native token transfers as well\n    //\n    // @param token the token to transfer\n    // @param amount the amount to transfer\n    // @param receiver the address to transfer to\n    // @param shouldUnwrapNativeToken whether to unwrap the wrapped native token\n    // before transferring\n    function transferOut(\n        address token,\n        address receiver,\n        uint256 amount,\n        bool shouldUnwrapNativeToken\n    ) external onlyController {\n        address wnt = TokenUtils.wnt(dataStore);\n\n        if (token == wnt && shouldUnwrapNativeToken) {\n            _transferOutNativeToken(token, receiver, amount);\n        } else {\n            _transferOut(token, receiver, amount);\n        }\n    }\n\n    // @dev transfer native tokens from this contract to a receiver\n    //\n    // @param token the token to transfer\n    // @param amount the amount to transfer\n    // @param receiver the address to transfer to\n    // @param shouldUnwrapNativeToken whether to unwrap the wrapped native token\n    // before transferring\n    function transferOutNativeToken(\n        address receiver,\n        uint256 amount\n    ) external onlyController {\n        address wnt = TokenUtils.wnt(dataStore);\n        _transferOutNativeToken(wnt, receiver, amount);\n    }\n\n    // @dev transfer tokens from this contract to a receiver\n    //\n    // @param token the token to transfer\n    // @param amount the amount to transfer\n    // @param receiver the address to transfer to\n    function _transferOut(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal {\n        if (receiver == address(this)) {\n            revert Errors.SelfTransferNotSupported(receiver);\n        }\n\n        TokenUtils.transfer(dataStore, token, receiver, amount);\n\n        _afterTransferOut(token);\n    }\n\n    // @dev unwrap wrapped native tokens and transfer the native tokens from\n    // this contract to a receiver\n    //\n    // @param token the token to transfer\n    // @param amount the amount to transfer\n    // @param receiver the address to transfer to\n    function _transferOutNativeToken(\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal {\n        if (receiver == address(this)) {\n            revert Errors.SelfTransferNotSupported(receiver);\n        }\n\n        TokenUtils.withdrawAndSendNativeToken(\n            dataStore,\n            token,\n            receiver,\n            amount\n        );\n\n        _afterTransferOut(token);\n    }\n\n    function _afterTransferOut(address /* token */) internal virtual {}\n}\n"
    },
    "contracts/bank/StrictBank.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./Bank.sol\";\n\n// @title StrictBank\n// @dev a stricter version of Bank\n//\n// the Bank contract does not have functions to validate the amount of tokens\n// transferred in\n// the Bank contract will mainly assume that safeTransferFrom calls work correctly\n// and that tokens were transferred into it if there was no revert\n//\n// the StrictBank contract keeps track of its internal token balance\n// and uses recordTransferIn to compare its change in balance and return\n// the amount of tokens received\ncontract StrictBank is Bank {\n    using SafeERC20 for IERC20;\n\n    // used to record token balances to evaluate amounts transferred in\n    mapping (address => uint256) public tokenBalances;\n\n    constructor(RoleStore _roleStore, DataStore _dataStore) Bank(_roleStore, _dataStore) {}\n\n    // @dev records a token transfer into the contract\n    // @param token the token to record the transfer for\n    // @return the amount of tokens transferred in\n    function recordTransferIn(address token) external onlyController returns (uint256) {\n        return _recordTransferIn(token);\n    }\n\n    // @dev this can be used to update the tokenBalances in case of token burns\n    // or similar balance changes\n    // the prevBalance is not validated to be more than the nextBalance as this\n    // could allow someone to block this call by transferring into the contract\n    // @param token the token to record the burn for\n    // @return the new balance\n    function syncTokenBalance(address token) external onlyController returns (uint256) {\n        uint256 nextBalance = IERC20(token).balanceOf(address(this));\n        tokenBalances[token] = nextBalance;\n        return nextBalance;\n    }\n\n    // @dev records a token transfer into the contract\n    // @param token the token to record the transfer for\n    // @return the amount of tokens transferred in\n    function _recordTransferIn(address token) internal returns (uint256) {\n        uint256 prevBalance = tokenBalances[token];\n        uint256 nextBalance = IERC20(token).balanceOf(address(this));\n        tokenBalances[token] = nextBalance;\n\n        return nextBalance - prevBalance;\n    }\n\n    // @dev update the internal balance after tokens have been transferred out\n    // this is called from the Bank contract\n    // @param token the token that was transferred out\n    function _afterTransferOut(address token) internal override {\n        tokenBalances[token] = IERC20(token).balanceOf(address(this));\n    }\n}\n"
    },
    "contracts/data/DataStore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../role/RoleModule.sol\";\nimport \"../utils/Calc.sol\";\n\n// @title DataStore\n// @dev DataStore for all general state values\ncontract DataStore is RoleModule {\n    using SafeCast for int256;\n\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableValues for EnumerableSet.Bytes32Set;\n    using EnumerableValues for EnumerableSet.AddressSet;\n    using EnumerableValues for EnumerableSet.UintSet;\n\n    // store for uint values\n    mapping(bytes32 => uint256) public uintValues;\n    // store for int values\n    mapping(bytes32 => int256) public intValues;\n    // store for address values\n    mapping(bytes32 => address) public addressValues;\n    // store for bool values\n    mapping(bytes32 => bool) public boolValues;\n    // store for string values\n    mapping(bytes32 => string) public stringValues;\n    // store for bytes32 values\n    mapping(bytes32 => bytes32) public bytes32Values;\n\n    // store for uint[] values\n    mapping(bytes32 => uint256[]) public uintArrayValues;\n    // store for int[] values\n    mapping(bytes32 => int256[]) public intArrayValues;\n    // store for address[] values\n    mapping(bytes32 => address[]) public addressArrayValues;\n    // store for bool[] values\n    mapping(bytes32 => bool[]) public boolArrayValues;\n    // store for string[] values\n    mapping(bytes32 => string[]) public stringArrayValues;\n    // store for bytes32[] values\n    mapping(bytes32 => bytes32[]) public bytes32ArrayValues;\n\n    // store for bytes32 sets\n    mapping(bytes32 => EnumerableSet.Bytes32Set) internal bytes32Sets;\n    // store for address sets\n    mapping(bytes32 => EnumerableSet.AddressSet) internal addressSets;\n    // store for uint256 sets\n    mapping(bytes32 => EnumerableSet.UintSet) internal uintSets;\n\n    constructor(RoleStore _roleStore) RoleModule(_roleStore) {}\n\n    // @dev get the uint value for the given key\n    // @param key the key of the value\n    // @return the uint value for the key\n    function getUint(bytes32 key) external view returns (uint256) {\n        return uintValues[key];\n    }\n\n    // @dev set the uint value for the given key\n    // @param key the key of the value\n    // @param value the value to set\n    // @return the uint value for the key\n    function setUint(bytes32 key, uint256 value) external onlyController returns (uint256) {\n        uintValues[key] = value;\n        return value;\n    }\n\n    // @dev delete the uint value for the given key\n    // @param key the key of the value\n    function removeUint(bytes32 key) external onlyController {\n        delete uintValues[key];\n    }\n\n    // @dev add the input int value to the existing uint value\n    // @param key the key of the value\n    // @param value the input int value\n    // @return the new uint value\n    function applyDeltaToUint(bytes32 key, int256 value, string memory errorMessage) external onlyController returns (uint256) {\n        uint256 currValue = uintValues[key];\n        if (value < 0 && (-value).toUint256() > currValue) {\n            revert(errorMessage);\n        }\n        uint256 nextUint = Calc.sumReturnUint256(currValue, value);\n        uintValues[key] = nextUint;\n        return nextUint;\n    }\n\n    // @dev add the input uint value to the existing uint value\n    // @param key the key of the value\n    // @param value the input int value\n    // @return the new uint value\n    function applyDeltaToUint(bytes32 key, uint256 value) external onlyController returns (uint256) {\n        uint256 currValue = uintValues[key];\n        uint256 nextUint = currValue + value;\n        uintValues[key] = nextUint;\n        return nextUint;\n    }\n\n    // @dev add the input int value to the existing uint value, prevent the uint\n    // value from becoming negative\n    // @param key the key of the value\n    // @param value the input int value\n    // @return the new uint value\n    function applyBoundedDeltaToUint(bytes32 key, int256 value) external onlyController returns (uint256) {\n        uint256 uintValue = uintValues[key];\n        if (value < 0 && (-value).toUint256() > uintValue) {\n            uintValues[key] = 0;\n            return 0;\n        }\n\n        uint256 nextUint = Calc.sumReturnUint256(uintValue, value);\n        uintValues[key] = nextUint;\n        return nextUint;\n    }\n\n    // @dev add the input uint value to the existing uint value\n    // @param key the key of the value\n    // @param value the input uint value\n    // @return the new uint value\n    function incrementUint(bytes32 key, uint256 value) external onlyController returns (uint256) {\n        uint256 nextUint = uintValues[key] + value;\n        uintValues[key] = nextUint;\n        return nextUint;\n    }\n\n    // @dev subtract the input uint value from the existing uint value\n    // @param key the key of the value\n    // @param value the input uint value\n    // @return the new uint value\n    function decrementUint(bytes32 key, uint256 value) external onlyController returns (uint256) {\n        uint256 nextUint = uintValues[key] - value;\n        uintValues[key] = nextUint;\n        return nextUint;\n    }\n\n    // @dev get the int value for the given key\n    // @param key the key of the value\n    // @return the int value for the key\n    function getInt(bytes32 key) external view returns (int256) {\n        return intValues[key];\n    }\n\n    // @dev set the int value for the given key\n    // @param key the key of the value\n    // @param value the value to set\n    // @return the int value for the key\n    function setInt(bytes32 key, int256 value) external onlyController returns (int256) {\n        intValues[key] = value;\n        return value;\n    }\n\n    function removeInt(bytes32 key) external onlyController {\n        delete intValues[key];\n    }\n\n    // @dev add the input int value to the existing int value\n    // @param key the key of the value\n    // @param value the input int value\n    // @return the new int value\n    function applyDeltaToInt(bytes32 key, int256 value) external onlyController returns (int256) {\n        int256 nextInt = intValues[key] + value;\n        intValues[key] = nextInt;\n        return nextInt;\n    }\n\n    // @dev add the input int value to the existing int value\n    // @param key the key of the value\n    // @param value the input int value\n    // @return the new int value\n    function incrementInt(bytes32 key, int256 value) external onlyController returns (int256) {\n        int256 nextInt = intValues[key] + value;\n        intValues[key] = nextInt;\n        return nextInt;\n    }\n\n    // @dev subtract the input int value from the existing int value\n    // @param key the key of the value\n    // @param value the input int value\n    // @return the new int value\n    function decrementInt(bytes32 key, int256 value) external onlyController returns (int256) {\n        int256 nextInt = intValues[key] - value;\n        intValues[key] = nextInt;\n        return nextInt;\n    }\n\n    // @dev get the address value for the given key\n    // @param key the key of the value\n    // @return the address value for the key\n    function getAddress(bytes32 key) external view returns (address) {\n        return addressValues[key];\n    }\n\n    // @dev set the address value for the given key\n    // @param key the key of the value\n    // @param value the value to set\n    // @return the address value for the key\n    function setAddress(bytes32 key, address value) external onlyController returns (address) {\n        addressValues[key] = value;\n        return value;\n    }\n\n    // @dev delete the address value for the given key\n    // @param key the key of the value\n    function removeAddress(bytes32 key) external onlyController {\n        delete addressValues[key];\n    }\n\n    // @dev get the bool value for the given key\n    // @param key the key of the value\n    // @return the bool value for the key\n    function getBool(bytes32 key) external view returns (bool) {\n        return boolValues[key];\n    }\n\n    // @dev set the bool value for the given key\n    // @param key the key of the value\n    // @param value the value to set\n    // @return the bool value for the key\n    function setBool(bytes32 key, bool value) external onlyController returns (bool) {\n        boolValues[key] = value;\n        return value;\n    }\n\n    // @dev delete the bool value for the given key\n    // @param key the key of the value\n    function removeBool(bytes32 key) external onlyController {\n        delete boolValues[key];\n    }\n\n    // @dev get the string value for the given key\n    // @param key the key of the value\n    // @return the string value for the key\n    function getString(bytes32 key) external view returns (string memory) {\n        return stringValues[key];\n    }\n\n    // @dev set the string value for the given key\n    // @param key the key of the value\n    // @param value the value to set\n    // @return the string value for the key\n    function setString(bytes32 key, string memory value) external onlyController returns (string memory) {\n        stringValues[key] = value;\n        return value;\n    }\n\n    // @dev delete the string value for the given key\n    // @param key the key of the value\n    function removeString(bytes32 key) external onlyController {\n        delete stringValues[key];\n    }\n\n    // @dev get the bytes32 value for the given key\n    // @param key the key of the value\n    // @return the bytes32 value for the key\n    function getBytes32(bytes32 key) external view returns (bytes32) {\n        return bytes32Values[key];\n    }\n\n    // @dev set the bytes32 value for the given key\n    // @param key the key of the value\n    // @param value the value to set\n    // @return the bytes32 value for the key\n    function setBytes32(bytes32 key, bytes32 value) external onlyController returns (bytes32) {\n        bytes32Values[key] = value;\n        return value;\n    }\n\n    // @dev delete the bytes32 value for the given key\n    // @param key the key of the value\n    function removeBytes32(bytes32 key) external onlyController {\n        delete bytes32Values[key];\n    }\n\n    // @dev get the uint array for the given key\n    // @param key the key of the uint array\n    // @return the uint array for the key\n    function getUintArray(bytes32 key) external view returns (uint256[] memory) {\n        return uintArrayValues[key];\n    }\n\n    // @dev set the uint array for the given key\n    // @param key the key of the uint array\n    // @param value the value of the uint array\n    function setUintArray(bytes32 key, uint256[] memory value) external onlyController {\n        uintArrayValues[key] = value;\n    }\n\n    // @dev delete the uint array for the given key\n    // @param key the key of the uint array\n    // @param value the value of the uint array\n    function removeUintArray(bytes32 key) external onlyController {\n        delete uintArrayValues[key];\n    }\n\n    // @dev get the int array for the given key\n    // @param key the key of the int array\n    // @return the int array for the key\n    function getIntArray(bytes32 key) external view returns (int256[] memory) {\n        return intArrayValues[key];\n    }\n\n    // @dev set the int array for the given key\n    // @param key the key of the int array\n    // @param value the value of the int array\n    function setIntArray(bytes32 key, int256[] memory value) external onlyController {\n        intArrayValues[key] = value;\n    }\n\n    // @dev delete the int array for the given key\n    // @param key the key of the int array\n    // @param value the value of the int array\n    function removeIntArray(bytes32 key) external onlyController {\n        delete intArrayValues[key];\n    }\n\n    // @dev get the address array for the given key\n    // @param key the key of the address array\n    // @return the address array for the key\n    function getAddressArray(bytes32 key) external view returns (address[] memory) {\n        return addressArrayValues[key];\n    }\n\n    // @dev set the address array for the given key\n    // @param key the key of the address array\n    // @param value the value of the address array\n    function setAddressArray(bytes32 key, address[] memory value) external onlyController {\n        addressArrayValues[key] = value;\n    }\n\n    // @dev delete the address array for the given key\n    // @param key the key of the address array\n    // @param value the value of the address array\n    function removeAddressArray(bytes32 key) external onlyController {\n        delete addressArrayValues[key];\n    }\n\n    // @dev get the bool array for the given key\n    // @param key the key of the bool array\n    // @return the bool array for the key\n    function getBoolArray(bytes32 key) external view returns (bool[] memory) {\n        return boolArrayValues[key];\n    }\n\n    // @dev set the bool array for the given key\n    // @param key the key of the bool array\n    // @param value the value of the bool array\n    function setBoolArray(bytes32 key, bool[] memory value) external onlyController {\n        boolArrayValues[key] = value;\n    }\n\n    // @dev delete the bool array for the given key\n    // @param key the key of the bool array\n    // @param value the value of the bool array\n    function removeBoolArray(bytes32 key) external onlyController {\n        delete boolArrayValues[key];\n    }\n\n    // @dev get the string array for the given key\n    // @param key the key of the string array\n    // @return the string array for the key\n    function getStringArray(bytes32 key) external view returns (string[] memory) {\n        return stringArrayValues[key];\n    }\n\n    // @dev set the string array for the given key\n    // @param key the key of the string array\n    // @param value the value of the string array\n    function setStringArray(bytes32 key, string[] memory value) external onlyController {\n        stringArrayValues[key] = value;\n    }\n\n    // @dev delete the string array for the given key\n    // @param key the key of the string array\n    // @param value the value of the string array\n    function removeStringArray(bytes32 key) external onlyController {\n        delete stringArrayValues[key];\n    }\n\n    // @dev get the bytes32 array for the given key\n    // @param key the key of the bytes32 array\n    // @return the bytes32 array for the key\n    function getBytes32Array(bytes32 key) external view returns (bytes32[] memory) {\n        return bytes32ArrayValues[key];\n    }\n\n    // @dev set the bytes32 array for the given key\n    // @param key the key of the bytes32 array\n    // @param value the value of the bytes32 array\n    function setBytes32Array(bytes32 key, bytes32[] memory value) external onlyController {\n        bytes32ArrayValues[key] = value;\n    }\n\n    // @dev delete the bytes32 array for the given key\n    // @param key the key of the bytes32 array\n    // @param value the value of the bytes32 array\n    function removeBytes32Array(bytes32 key) external onlyController {\n        delete bytes32ArrayValues[key];\n    }\n\n    // @dev check whether the given value exists in the set\n    // @param setKey the key of the set\n    // @param value the value to check\n    function containsBytes32(bytes32 setKey, bytes32 value) external view returns (bool) {\n        return bytes32Sets[setKey].contains(value);\n    }\n\n    // @dev get the length of the set\n    // @param setKey the key of the set\n    function getBytes32Count(bytes32 setKey) external view returns (uint256) {\n        return bytes32Sets[setKey].length();\n    }\n\n    // @dev get the values of the set in the given range\n    // @param setKey the key of the set\n    // @param the start of the range, values at the start index will be returned\n    // in the result\n    // @param the end of the range, values at the end index will not be returned\n    // in the result\n    function getBytes32ValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (bytes32[] memory) {\n        return bytes32Sets[setKey].valuesAt(start, end);\n    }\n\n    // @dev add the given value to the set\n    // @param setKey the key of the set\n    // @param value the value to add\n    function addBytes32(bytes32 setKey, bytes32 value) external onlyController {\n        bytes32Sets[setKey].add(value);\n    }\n\n    // @dev remove the given value from the set\n    // @param setKey the key of the set\n    // @param value the value to remove\n    function removeBytes32(bytes32 setKey, bytes32 value) external onlyController {\n        bytes32Sets[setKey].remove(value);\n    }\n\n    // @dev check whether the given value exists in the set\n    // @param setKey the key of the set\n    // @param value the value to check\n    function containsAddress(bytes32 setKey, address value) external view returns (bool) {\n        return addressSets[setKey].contains(value);\n    }\n\n    // @dev get the length of the set\n    // @param setKey the key of the set\n    function getAddressCount(bytes32 setKey) external view returns (uint256) {\n        return addressSets[setKey].length();\n    }\n\n    // @dev get the values of the set in the given range\n    // @param setKey the key of the set\n    // @param the start of the range, values at the start index will be returned\n    // in the result\n    // @param the end of the range, values at the end index will not be returned\n    // in the result\n    function getAddressValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (address[] memory) {\n        return addressSets[setKey].valuesAt(start, end);\n    }\n\n    // @dev add the given value to the set\n    // @param setKey the key of the set\n    // @param value the value to add\n    function addAddress(bytes32 setKey, address value) external onlyController {\n        addressSets[setKey].add(value);\n    }\n\n    // @dev remove the given value from the set\n    // @param setKey the key of the set\n    // @param value the value to remove\n    function removeAddress(bytes32 setKey, address value) external onlyController {\n        addressSets[setKey].remove(value);\n    }\n\n    // @dev check whether the given value exists in the set\n    // @param setKey the key of the set\n    // @param value the value to check\n    function containsUint(bytes32 setKey, uint256 value) external view returns (bool) {\n        return uintSets[setKey].contains(value);\n    }\n\n    // @dev get the length of the set\n    // @param setKey the key of the set\n    function getUintCount(bytes32 setKey) external view returns (uint256) {\n        return uintSets[setKey].length();\n    }\n\n    // @dev get the values of the set in the given range\n    // @param setKey the key of the set\n    // @param the start of the range, values at the start index will be returned\n    // in the result\n    // @param the end of the range, values at the end index will not be returned\n    // in the result\n    function getUintValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (uint256[] memory) {\n        return uintSets[setKey].valuesAt(start, end);\n    }\n\n    // @dev add the given value to the set\n    // @param setKey the key of the set\n    // @param value the value to add\n    function addUint(bytes32 setKey, uint256 value) external onlyController {\n        uintSets[setKey].add(value);\n    }\n\n    // @dev remove the given value from the set\n    // @param setKey the key of the set\n    // @param value the value to remove\n    function removeUint(bytes32 setKey, uint256 value) external onlyController {\n        uintSets[setKey].remove(value);\n    }\n}\n"
    },
    "contracts/data/Keys.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n// @title Keys\n// @dev Keys for values in the DataStore\nlibrary Keys {\n    // @dev key for the address of the wrapped native token\n    bytes32 public constant WNT = keccak256(abi.encode(\"WNT\"));\n    // @dev key for the nonce value used in NonceUtils\n    bytes32 public constant NONCE = keccak256(abi.encode(\"NONCE\"));\n\n    // @dev for sending received fees\n    bytes32 public constant FEE_RECEIVER = keccak256(abi.encode(\"FEE_RECEIVER\"));\n\n    // @dev for holding tokens that could not be sent out\n    bytes32 public constant HOLDING_ADDRESS = keccak256(abi.encode(\"HOLDING_ADDRESS\"));\n\n    // @dev key for the minimum gas for execution error\n    bytes32 public constant MIN_HANDLE_EXECUTION_ERROR_GAS = keccak256(abi.encode(\"MIN_HANDLE_EXECUTION_ERROR_GAS\"));\n\n    // @dev key for the minimum gas that should be forwarded for execution error handling\n    bytes32 public constant MIN_HANDLE_EXECUTION_ERROR_GAS_TO_FORWARD = keccak256(abi.encode(\"MIN_HANDLE_EXECUTION_ERROR_GAS_TO_FORWARD\"));\n\n    // @dev key for the min additional gas for execution\n    bytes32 public constant MIN_ADDITIONAL_GAS_FOR_EXECUTION = keccak256(abi.encode(\"MIN_ADDITIONAL_GAS_FOR_EXECUTION\"));\n\n    // @dev for a global reentrancy guard\n    bytes32 public constant REENTRANCY_GUARD_STATUS = keccak256(abi.encode(\"REENTRANCY_GUARD_STATUS\"));\n\n    // @dev key for deposit fees\n    bytes32 public constant DEPOSIT_FEE_TYPE = keccak256(abi.encode(\"DEPOSIT_FEE_TYPE\"));\n    // @dev key for withdrawal fees\n    bytes32 public constant WITHDRAWAL_FEE_TYPE = keccak256(abi.encode(\"WITHDRAWAL_FEE_TYPE\"));\n    // @dev key for swap fees\n    bytes32 public constant SWAP_FEE_TYPE = keccak256(abi.encode(\"SWAP_FEE_TYPE\"));\n    // @dev key for position fees\n    bytes32 public constant POSITION_FEE_TYPE = keccak256(abi.encode(\"POSITION_FEE_TYPE\"));\n    // @dev key for ui deposit fees\n    bytes32 public constant UI_DEPOSIT_FEE_TYPE = keccak256(abi.encode(\"UI_DEPOSIT_FEE_TYPE\"));\n    // @dev key for ui withdrawal fees\n    bytes32 public constant UI_WITHDRAWAL_FEE_TYPE = keccak256(abi.encode(\"UI_WITHDRAWAL_FEE_TYPE\"));\n    // @dev key for ui swap fees\n    bytes32 public constant UI_SWAP_FEE_TYPE = keccak256(abi.encode(\"UI_SWAP_FEE_TYPE\"));\n    // @dev key for ui position fees\n    bytes32 public constant UI_POSITION_FEE_TYPE = keccak256(abi.encode(\"UI_POSITION_FEE_TYPE\"));\n\n    // @dev key for ui fee factor\n    bytes32 public constant UI_FEE_FACTOR = keccak256(abi.encode(\"UI_FEE_FACTOR\"));\n    // @dev key for max ui fee receiver factor\n    bytes32 public constant MAX_UI_FEE_FACTOR = keccak256(abi.encode(\"MAX_UI_FEE_FACTOR\"));\n\n    // @dev key for the claimable fee amount\n    bytes32 public constant CLAIMABLE_FEE_AMOUNT = keccak256(abi.encode(\"CLAIMABLE_FEE_AMOUNT\"));\n    // @dev key for the claimable ui fee amount\n    bytes32 public constant CLAIMABLE_UI_FEE_AMOUNT = keccak256(abi.encode(\"CLAIMABLE_UI_FEE_AMOUNT\"));\n    // @dev key for the max number of auto cancel orders\n    bytes32 public constant MAX_AUTO_CANCEL_ORDERS = keccak256(abi.encode(\"MAX_AUTO_CANCEL_ORDERS\"));\n    // @dev key for the max total callback gas limit for auto cancel orders\n    bytes32 public constant MAX_TOTAL_CALLBACK_GAS_LIMIT_FOR_AUTO_CANCEL_ORDERS = keccak256(abi.encode(\"MAX_TOTAL_CALLBACK_GAS_LIMIT_FOR_AUTO_CANCEL_ORDERS\"));\n\n    // @dev key for the market list\n    bytes32 public constant MARKET_LIST = keccak256(abi.encode(\"MARKET_LIST\"));\n\n    // @dev key for the fee batch list\n    bytes32 public constant FEE_BATCH_LIST = keccak256(abi.encode(\"FEE_BATCH_LIST\"));\n\n    // @dev key for the deposit list\n    bytes32 public constant DEPOSIT_LIST = keccak256(abi.encode(\"DEPOSIT_LIST\"));\n    // @dev key for the account deposit list\n    bytes32 public constant ACCOUNT_DEPOSIT_LIST = keccak256(abi.encode(\"ACCOUNT_DEPOSIT_LIST\"));\n\n    // @dev key for the withdrawal list\n    bytes32 public constant WITHDRAWAL_LIST = keccak256(abi.encode(\"WITHDRAWAL_LIST\"));\n    // @dev key for the account withdrawal list\n    bytes32 public constant ACCOUNT_WITHDRAWAL_LIST = keccak256(abi.encode(\"ACCOUNT_WITHDRAWAL_LIST\"));\n\n    // @dev key for the shift list\n    bytes32 public constant SHIFT_LIST = keccak256(abi.encode(\"SHIFT_LIST\"));\n    // @dev key for the account shift list\n    bytes32 public constant ACCOUNT_SHIFT_LIST = keccak256(abi.encode(\"ACCOUNT_SHIFT_LIST\"));\n\n    bytes32 public constant GLV_LIST = keccak256(abi.encode(\"GLV_LIST\"));\n    bytes32 public constant GLV_DEPOSIT_LIST = keccak256(abi.encode(\"GLV_DEPOSIT_LIST\"));\n    bytes32 public constant GLV_SHIFT_LIST = keccak256(abi.encode(\"GLV_SHIFT_LIST\"));\n    bytes32 public constant ACCOUNT_GLV_DEPOSIT_LIST = keccak256(abi.encode(\"ACCOUNT_GLV_DEPOSIT_LIST\"));\n    bytes32 public constant GLV_WITHDRAWAL_LIST = keccak256(abi.encode(\"GLV_WITHDRAWAL_LIST\"));\n    bytes32 public constant ACCOUNT_GLV_WITHDRAWAL_LIST = keccak256(abi.encode(\"ACCOUNT_GLV_WITHDRAWAL_LIST\"));\n    bytes32 public constant GLV_SUPPORTED_MARKET_LIST = keccak256(abi.encode(\"GLV_SUPPORTED_MARKET_LIST\"));\n\n    // @dev key for the position list\n    bytes32 public constant POSITION_LIST = keccak256(abi.encode(\"POSITION_LIST\"));\n    // @dev key for the account position list\n    bytes32 public constant ACCOUNT_POSITION_LIST = keccak256(abi.encode(\"ACCOUNT_POSITION_LIST\"));\n\n    // @dev key for the order list\n    bytes32 public constant ORDER_LIST = keccak256(abi.encode(\"ORDER_LIST\"));\n    // @dev key for the account order list\n    bytes32 public constant ACCOUNT_ORDER_LIST = keccak256(abi.encode(\"ACCOUNT_ORDER_LIST\"));\n\n    // @dev key for the subaccount list\n    bytes32 public constant SUBACCOUNT_LIST = keccak256(abi.encode(\"SUBACCOUNT_LIST\"));\n\n    // @dev key for the auto cancel order list\n    bytes32 public constant AUTO_CANCEL_ORDER_LIST = keccak256(abi.encode(\"AUTO_CANCEL_ORDER_LIST\"));\n\n    // @dev key for is market disabled\n    bytes32 public constant IS_MARKET_DISABLED = keccak256(abi.encode(\"IS_MARKET_DISABLED\"));\n\n    // @dev key for the max swap path length allowed\n    bytes32 public constant MAX_SWAP_PATH_LENGTH = keccak256(abi.encode(\"MAX_SWAP_PATH_LENGTH\"));\n    // @dev key used to store markets observed in a swap path, to ensure that a swap path contains unique markets\n    bytes32 public constant SWAP_PATH_MARKET_FLAG = keccak256(abi.encode(\"SWAP_PATH_MARKET_FLAG\"));\n    // @dev key used to store the min market tokens for the first deposit for a market\n    bytes32 public constant MIN_MARKET_TOKENS_FOR_FIRST_DEPOSIT = keccak256(abi.encode(\"MIN_MARKET_TOKENS_FOR_FIRST_DEPOSIT\"));\n\n    bytes32 public constant CREATE_GLV_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\"CREATE_GLV_DEPOSIT_FEATURE_DISABLED\"));\n    bytes32 public constant CANCEL_GLV_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\"CANCEL_GLV_DEPOSIT_FEATURE_DISABLED\"));\n    bytes32 public constant EXECUTE_GLV_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_GLV_DEPOSIT_FEATURE_DISABLED\"));\n\n    bytes32 public constant CREATE_GLV_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\"CREATE_GLV_WITHDRAWAL_FEATURE_DISABLED\"));\n    bytes32 public constant CANCEL_GLV_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\"CANCEL_GLV_WITHDRAWAL_FEATURE_DISABLED\"));\n    bytes32 public constant EXECUTE_GLV_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_GLV_WITHDRAWAL_FEATURE_DISABLED\"));\n\n    bytes32 public constant CREATE_GLV_SHIFT_FEATURE_DISABLED = keccak256(abi.encode(\"CREATE_GLV_SHIFT_FEATURE_DISABLED\"));\n    bytes32 public constant EXECUTE_GLV_SHIFT_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_GLV_SHIFT_FEATURE_DISABLED\"));\n\n    // @dev key for whether the create deposit feature is disabled\n    bytes32 public constant CREATE_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\"CREATE_DEPOSIT_FEATURE_DISABLED\"));\n    // @dev key for whether the cancel deposit feature is disabled\n    bytes32 public constant CANCEL_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\"CANCEL_DEPOSIT_FEATURE_DISABLED\"));\n    // @dev key for whether the execute deposit feature is disabled\n    bytes32 public constant EXECUTE_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_DEPOSIT_FEATURE_DISABLED\"));\n\n    // @dev key for whether the create withdrawal feature is disabled\n    bytes32 public constant CREATE_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\"CREATE_WITHDRAWAL_FEATURE_DISABLED\"));\n    // @dev key for whether the cancel withdrawal feature is disabled\n    bytes32 public constant CANCEL_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\"CANCEL_WITHDRAWAL_FEATURE_DISABLED\"));\n    // @dev key for whether the execute withdrawal feature is disabled\n    bytes32 public constant EXECUTE_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_WITHDRAWAL_FEATURE_DISABLED\"));\n    // @dev key for whether the execute atomic withdrawal feature is disabled\n    bytes32 public constant EXECUTE_ATOMIC_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_ATOMIC_WITHDRAWAL_FEATURE_DISABLED\"));\n\n    // @dev key for whether the create shift feature is disabled\n    bytes32 public constant CREATE_SHIFT_FEATURE_DISABLED = keccak256(abi.encode(\"CREATE_SHIFT_FEATURE_DISABLED\"));\n    // @dev key for whether the cancel shift feature is disabled\n    bytes32 public constant CANCEL_SHIFT_FEATURE_DISABLED = keccak256(abi.encode(\"CANCEL_SHIFT_FEATURE_DISABLED\"));\n    // @dev key for whether the execute shift feature is disabled\n    bytes32 public constant EXECUTE_SHIFT_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_SHIFT_FEATURE_DISABLED\"));\n\n    // @dev key for whether the create order feature is disabled\n    bytes32 public constant CREATE_ORDER_FEATURE_DISABLED = keccak256(abi.encode(\"CREATE_ORDER_FEATURE_DISABLED\"));\n    // @dev key for whether the execute order feature is disabled\n    bytes32 public constant EXECUTE_ORDER_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_ORDER_FEATURE_DISABLED\"));\n    // @dev key for whether the execute adl feature is disabled\n    // for liquidations, it can be disabled by using the EXECUTE_ORDER_FEATURE_DISABLED key with the Liquidation\n    // order type, ADL orders have a MarketDecrease order type, so a separate key is needed to disable it\n    bytes32 public constant EXECUTE_ADL_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_ADL_FEATURE_DISABLED\"));\n    // @dev key for whether the update order feature is disabled\n    bytes32 public constant UPDATE_ORDER_FEATURE_DISABLED = keccak256(abi.encode(\"UPDATE_ORDER_FEATURE_DISABLED\"));\n    // @dev key for whether the cancel order feature is disabled\n    bytes32 public constant CANCEL_ORDER_FEATURE_DISABLED = keccak256(abi.encode(\"CANCEL_ORDER_FEATURE_DISABLED\"));\n\n    // @dev key for whether the claim funding fees feature is disabled\n    bytes32 public constant CLAIM_FUNDING_FEES_FEATURE_DISABLED = keccak256(abi.encode(\"CLAIM_FUNDING_FEES_FEATURE_DISABLED\"));\n    // @dev key for whether the claim collateral feature is disabled\n    bytes32 public constant CLAIM_COLLATERAL_FEATURE_DISABLED = keccak256(abi.encode(\"CLAIM_COLLATERAL_FEATURE_DISABLED\"));\n    // @dev key for whether the claim affiliate rewards feature is disabled\n    bytes32 public constant CLAIM_AFFILIATE_REWARDS_FEATURE_DISABLED = keccak256(abi.encode(\"CLAIM_AFFILIATE_REWARDS_FEATURE_DISABLED\"));\n    // @dev key for whether the claim ui fees feature is disabled\n    bytes32 public constant CLAIM_UI_FEES_FEATURE_DISABLED = keccak256(abi.encode(\"CLAIM_UI_FEES_FEATURE_DISABLED\"));\n    // @dev key for whether the subaccount feature is disabled\n    bytes32 public constant SUBACCOUNT_FEATURE_DISABLED = keccak256(abi.encode(\"SUBACCOUNT_FEATURE_DISABLED\"));\n\n    // @dev key for the minimum required oracle signers for an oracle observation\n    bytes32 public constant MIN_ORACLE_SIGNERS = keccak256(abi.encode(\"MIN_ORACLE_SIGNERS\"));\n    // @dev key for the minimum block confirmations before blockhash can be excluded for oracle signature validation\n    bytes32 public constant MIN_ORACLE_BLOCK_CONFIRMATIONS = keccak256(abi.encode(\"MIN_ORACLE_BLOCK_CONFIRMATIONS\"));\n    // @dev key for the maximum usable oracle price age in seconds\n    bytes32 public constant MAX_ORACLE_PRICE_AGE = keccak256(abi.encode(\"MAX_ORACLE_PRICE_AGE\"));\n    // @dev key for the maximum oracle timestamp range\n    bytes32 public constant MAX_ORACLE_TIMESTAMP_RANGE = keccak256(abi.encode(\"MAX_ORACLE_TIMESTAMP_RANGE\"));\n    // @dev key for the maximum oracle price deviation factor from the ref price\n    bytes32 public constant MAX_ORACLE_REF_PRICE_DEVIATION_FACTOR = keccak256(abi.encode(\"MAX_ORACLE_REF_PRICE_DEVIATION_FACTOR\"));\n    // @dev key for whether an oracle provider is enabled\n    bytes32 public constant IS_ORACLE_PROVIDER_ENABLED = keccak256(abi.encode(\"IS_ORACLE_PROVIDER_ENABLED\"));\n    // @dev key for whether an oracle provider can be used for atomic actions\n    bytes32 public constant IS_ATOMIC_ORACLE_PROVIDER = keccak256(abi.encode(\"IS_ATOMIC_ORACLE_PROVIDER\"));\n    // @dev key for oracle timestamp adjustment\n    bytes32 public constant ORACLE_TIMESTAMP_ADJUSTMENT = keccak256(abi.encode(\"ORACLE_TIMESTAMP_ADJUSTMENT\"));\n    // @dev key for oracle provider for token\n    bytes32 public constant ORACLE_PROVIDER_FOR_TOKEN = keccak256(abi.encode(\"ORACLE_PROVIDER_FOR_TOKEN\"));\n    // @dev key for the chainlink payment token\n    bytes32 public constant CHAINLINK_PAYMENT_TOKEN = keccak256(abi.encode(\"CHAINLINK_PAYMENT_TOKEN\"));\n    // @dev key for the sequencer grace duration\n    bytes32 public constant SEQUENCER_GRACE_DURATION = keccak256(abi.encode(\"SEQUENCER_GRACE_DURATION\"));\n\n    // @dev key for the percentage amount of position fees to be received\n    bytes32 public constant POSITION_FEE_RECEIVER_FACTOR = keccak256(abi.encode(\"POSITION_FEE_RECEIVER_FACTOR\"));\n    // @dev key for the percentage amount of swap fees to be received\n    bytes32 public constant SWAP_FEE_RECEIVER_FACTOR = keccak256(abi.encode(\"SWAP_FEE_RECEIVER_FACTOR\"));\n    // @dev key for the percentage amount of borrowing fees to be received\n    bytes32 public constant BORROWING_FEE_RECEIVER_FACTOR = keccak256(abi.encode(\"BORROWING_FEE_RECEIVER_FACTOR\"));\n\n    // @dev key for the base gas limit used when estimating execution fee\n    bytes32 public constant ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1 = keccak256(abi.encode(\"ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1\"));\n    // @dev key for the gas limit used for each oracle price when estimating execution fee\n    bytes32 public constant ESTIMATED_GAS_FEE_PER_ORACLE_PRICE = keccak256(abi.encode(\"ESTIMATED_GAS_FEE_PER_ORACLE_PRICE\"));\n    // @dev key for the multiplier used when estimating execution fee\n    bytes32 public constant ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR = keccak256(abi.encode(\"ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR\"));\n\n    // @dev key for the base gas limit used when calculating execution fee\n    bytes32 public constant EXECUTION_GAS_FEE_BASE_AMOUNT_V2_1 = keccak256(abi.encode(\"EXECUTION_GAS_FEE_BASE_AMOUNT_V2_1\"));\n    // @dev key for the gas limit used for each oracle price\n    bytes32 public constant EXECUTION_GAS_FEE_PER_ORACLE_PRICE = keccak256(abi.encode(\"EXECUTION_GAS_FEE_PER_ORACLE_PRICE\"));\n    // @dev key for the multiplier used when calculating execution fee\n    bytes32 public constant EXECUTION_GAS_FEE_MULTIPLIER_FACTOR = keccak256(abi.encode(\"EXECUTION_GAS_FEE_MULTIPLIER_FACTOR\"));\n\n    // @dev key for the estimated gas limit for deposits\n    bytes32 public constant DEPOSIT_GAS_LIMIT = keccak256(abi.encode(\"DEPOSIT_GAS_LIMIT\"));\n    // @dev key for the estimated gas limit for withdrawals\n    bytes32 public constant WITHDRAWAL_GAS_LIMIT = keccak256(abi.encode(\"WITHDRAWAL_GAS_LIMIT\"));\n    bytes32 public constant GLV_DEPOSIT_GAS_LIMIT = keccak256(abi.encode(\"GLV_DEPOSIT_GAS_LIMIT\"));\n    bytes32 public constant GLV_WITHDRAWAL_GAS_LIMIT = keccak256(abi.encode(\"GLV_WITHDRAWAL_GAS_LIMIT\"));\n    bytes32 public constant GLV_SHIFT_GAS_LIMIT = keccak256(abi.encode(\"GLV_SHIFT_GAS_LIMIT\"));\n    bytes32 public constant GLV_PER_MARKET_GAS_LIMIT = keccak256(abi.encode(\"GLV_PER_MARKET_GAS_LIMIT\"));\n    // @dev key for the estimated gas limit for shifts\n    bytes32 public constant SHIFT_GAS_LIMIT = keccak256(abi.encode(\"SHIFT_GAS_LIMIT\"));\n    // @dev key for the estimated gas limit for single swaps\n    bytes32 public constant SINGLE_SWAP_GAS_LIMIT = keccak256(abi.encode(\"SINGLE_SWAP_GAS_LIMIT\"));\n    // @dev key for the estimated gas limit for increase orders\n    bytes32 public constant INCREASE_ORDER_GAS_LIMIT = keccak256(abi.encode(\"INCREASE_ORDER_GAS_LIMIT\"));\n    // @dev key for the estimated gas limit for decrease orders\n    bytes32 public constant DECREASE_ORDER_GAS_LIMIT = keccak256(abi.encode(\"DECREASE_ORDER_GAS_LIMIT\"));\n    // @dev key for the estimated gas limit for swap orders\n    bytes32 public constant SWAP_ORDER_GAS_LIMIT = keccak256(abi.encode(\"SWAP_ORDER_GAS_LIMIT\"));\n    // @dev key for the amount of gas to forward for token transfers\n    bytes32 public constant TOKEN_TRANSFER_GAS_LIMIT = keccak256(abi.encode(\"TOKEN_TRANSFER_GAS_LIMIT\"));\n    // @dev key for the amount of gas to forward for native token transfers\n    bytes32 public constant NATIVE_TOKEN_TRANSFER_GAS_LIMIT = keccak256(abi.encode(\"NATIVE_TOKEN_TRANSFER_GAS_LIMIT\"));\n    // @dev key for the request expiration time, after which the request will be considered expired\n    bytes32 public constant REQUEST_EXPIRATION_TIME = keccak256(abi.encode(\"REQUEST_EXPIRATION_TIME\"));\n\n    bytes32 public constant MAX_CALLBACK_GAS_LIMIT = keccak256(abi.encode(\"MAX_CALLBACK_GAS_LIMIT\"));\n    bytes32 public constant REFUND_EXECUTION_FEE_GAS_LIMIT = keccak256(abi.encode(\"REFUND_EXECUTION_FEE_GAS_LIMIT\"));\n    bytes32 public constant SAVED_CALLBACK_CONTRACT = keccak256(abi.encode(\"SAVED_CALLBACK_CONTRACT\"));\n\n    // @dev key for the min collateral factor\n    bytes32 public constant MIN_COLLATERAL_FACTOR = keccak256(abi.encode(\"MIN_COLLATERAL_FACTOR\"));\n    // @dev key for the min collateral factor for open interest multiplier\n    bytes32 public constant MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER = keccak256(abi.encode(\"MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER\"));\n    // @dev key for the min allowed collateral in USD\n    bytes32 public constant MIN_COLLATERAL_USD = keccak256(abi.encode(\"MIN_COLLATERAL_USD\"));\n    // @dev key for the min allowed position size in USD\n    bytes32 public constant MIN_POSITION_SIZE_USD = keccak256(abi.encode(\"MIN_POSITION_SIZE_USD\"));\n\n    // @dev key for the virtual id of tokens\n    bytes32 public constant VIRTUAL_TOKEN_ID = keccak256(abi.encode(\"VIRTUAL_TOKEN_ID\"));\n    // @dev key for the virtual id of markets\n    bytes32 public constant VIRTUAL_MARKET_ID = keccak256(abi.encode(\"VIRTUAL_MARKET_ID\"));\n    // @dev key for the virtual inventory for swaps\n    bytes32 public constant VIRTUAL_INVENTORY_FOR_SWAPS = keccak256(abi.encode(\"VIRTUAL_INVENTORY_FOR_SWAPS\"));\n    // @dev key for the virtual inventory for positions\n    bytes32 public constant VIRTUAL_INVENTORY_FOR_POSITIONS = keccak256(abi.encode(\"VIRTUAL_INVENTORY_FOR_POSITIONS\"));\n\n    // @dev key for the position impact factor\n    bytes32 public constant POSITION_IMPACT_FACTOR = keccak256(abi.encode(\"POSITION_IMPACT_FACTOR\"));\n    // @dev key for the position impact exponent factor\n    bytes32 public constant POSITION_IMPACT_EXPONENT_FACTOR = keccak256(abi.encode(\"POSITION_IMPACT_EXPONENT_FACTOR\"));\n    // @dev key for the max decrease position impact factor\n    bytes32 public constant MAX_POSITION_IMPACT_FACTOR = keccak256(abi.encode(\"MAX_POSITION_IMPACT_FACTOR\"));\n    // @dev key for the max position impact factor for liquidations\n    bytes32 public constant MAX_POSITION_IMPACT_FACTOR_FOR_LIQUIDATIONS = keccak256(abi.encode(\"MAX_POSITION_IMPACT_FACTOR_FOR_LIQUIDATIONS\"));\n    // @dev key for the position fee factor\n    bytes32 public constant POSITION_FEE_FACTOR = keccak256(abi.encode(\"POSITION_FEE_FACTOR\"));\n    // @dev key for the swap impact factor\n    bytes32 public constant SWAP_IMPACT_FACTOR = keccak256(abi.encode(\"SWAP_IMPACT_FACTOR\"));\n    // @dev key for the swap impact exponent factor\n    bytes32 public constant SWAP_IMPACT_EXPONENT_FACTOR = keccak256(abi.encode(\"SWAP_IMPACT_EXPONENT_FACTOR\"));\n    // @dev key for the swap fee factor\n    bytes32 public constant SWAP_FEE_FACTOR = keccak256(abi.encode(\"SWAP_FEE_FACTOR\"));\n    // @dev key for the atomic swap fee factor\n    bytes32 public constant ATOMIC_SWAP_FEE_FACTOR = keccak256(abi.encode(\"ATOMIC_SWAP_FEE_FACTOR\"));\n    // @dev key for the oracle type\n    bytes32 public constant ORACLE_TYPE = keccak256(abi.encode(\"ORACLE_TYPE\"));\n    // @dev key for open interest\n    bytes32 public constant OPEN_INTEREST = keccak256(abi.encode(\"OPEN_INTEREST\"));\n    // @dev key for open interest in tokens\n    bytes32 public constant OPEN_INTEREST_IN_TOKENS = keccak256(abi.encode(\"OPEN_INTEREST_IN_TOKENS\"));\n    // @dev key for collateral sum for a market\n    bytes32 public constant COLLATERAL_SUM = keccak256(abi.encode(\"COLLATERAL_SUM\"));\n    // @dev key for pool amount\n    bytes32 public constant POOL_AMOUNT = keccak256(abi.encode(\"POOL_AMOUNT\"));\n    // @dev key for max pool amount\n    bytes32 public constant MAX_POOL_AMOUNT = keccak256(abi.encode(\"MAX_POOL_AMOUNT\"));\n    // @dev key for max pool usd for deposit\n    bytes32 public constant MAX_POOL_USD_FOR_DEPOSIT = keccak256(abi.encode(\"MAX_POOL_USD_FOR_DEPOSIT\"));\n    // @dev key for max open interest\n    bytes32 public constant MAX_OPEN_INTEREST = keccak256(abi.encode(\"MAX_OPEN_INTEREST\"));\n    // @dev key for position impact pool amount\n    bytes32 public constant POSITION_IMPACT_POOL_AMOUNT = keccak256(abi.encode(\"POSITION_IMPACT_POOL_AMOUNT\"));\n    // @dev key for min position impact pool amount\n    bytes32 public constant MIN_POSITION_IMPACT_POOL_AMOUNT = keccak256(abi.encode(\"MIN_POSITION_IMPACT_POOL_AMOUNT\"));\n    // @dev key for position impact pool distribution rate\n    bytes32 public constant POSITION_IMPACT_POOL_DISTRIBUTION_RATE = keccak256(abi.encode(\"POSITION_IMPACT_POOL_DISTRIBUTION_RATE\"));\n    // @dev key for position impact pool distributed at\n    bytes32 public constant POSITION_IMPACT_POOL_DISTRIBUTED_AT = keccak256(abi.encode(\"POSITION_IMPACT_POOL_DISTRIBUTED_AT\"));\n    // @dev key for swap impact pool amount\n    bytes32 public constant SWAP_IMPACT_POOL_AMOUNT = keccak256(abi.encode(\"SWAP_IMPACT_POOL_AMOUNT\"));\n    // @dev key for price feed\n    bytes32 public constant PRICE_FEED = keccak256(abi.encode(\"PRICE_FEED\"));\n    // @dev key for price feed multiplier\n    bytes32 public constant PRICE_FEED_MULTIPLIER = keccak256(abi.encode(\"PRICE_FEED_MULTIPLIER\"));\n    // @dev key for price feed heartbeat\n    bytes32 public constant PRICE_FEED_HEARTBEAT_DURATION = keccak256(abi.encode(\"PRICE_FEED_HEARTBEAT_DURATION\"));\n    // @dev key for data stream feed id\n    bytes32 public constant DATA_STREAM_ID = keccak256(abi.encode(\"DATA_STREAM_ID\"));\n    // @dev key for data stream feed multipler\n    bytes32 public constant DATA_STREAM_MULTIPLIER = keccak256(abi.encode(\"DATA_STREAM_MULTIPLIER\"));\n    // @dev key for stable price\n    bytes32 public constant STABLE_PRICE = keccak256(abi.encode(\"STABLE_PRICE\"));\n    // @dev key for reserve factor\n    bytes32 public constant RESERVE_FACTOR = keccak256(abi.encode(\"RESERVE_FACTOR\"));\n    // @dev key for open interest reserve factor\n    bytes32 public constant OPEN_INTEREST_RESERVE_FACTOR = keccak256(abi.encode(\"OPEN_INTEREST_RESERVE_FACTOR\"));\n    // @dev key for max pnl factor\n    bytes32 public constant MAX_PNL_FACTOR = keccak256(abi.encode(\"MAX_PNL_FACTOR\"));\n    // @dev key for max pnl factor\n    bytes32 public constant MAX_PNL_FACTOR_FOR_TRADERS = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_TRADERS\"));\n    // @dev key for max pnl factor for adl\n    bytes32 public constant MAX_PNL_FACTOR_FOR_ADL = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_ADL\"));\n    // @dev key for min pnl factor for adl\n    bytes32 public constant MIN_PNL_FACTOR_AFTER_ADL = keccak256(abi.encode(\"MIN_PNL_FACTOR_AFTER_ADL\"));\n    // @dev key for max pnl factor\n    bytes32 public constant MAX_PNL_FACTOR_FOR_DEPOSITS = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n    // @dev key for max pnl factor for withdrawals\n    bytes32 public constant MAX_PNL_FACTOR_FOR_WITHDRAWALS = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_WITHDRAWALS\"));\n    // @dev key for latest ADL at\n    bytes32 public constant LATEST_ADL_AT = keccak256(abi.encode(\"LATEST_ADL_AT\"));\n    // @dev key for whether ADL is enabled\n    bytes32 public constant IS_ADL_ENABLED = keccak256(abi.encode(\"IS_ADL_ENABLED\"));\n    // @dev key for funding factor\n    bytes32 public constant FUNDING_FACTOR = keccak256(abi.encode(\"FUNDING_FACTOR\"));\n    // @dev key for funding exponent factor\n    bytes32 public constant FUNDING_EXPONENT_FACTOR = keccak256(abi.encode(\"FUNDING_EXPONENT_FACTOR\"));\n    // @dev key for saved funding factor\n    bytes32 public constant SAVED_FUNDING_FACTOR_PER_SECOND = keccak256(abi.encode(\"SAVED_FUNDING_FACTOR_PER_SECOND\"));\n    // @dev key for funding increase factor\n    bytes32 public constant FUNDING_INCREASE_FACTOR_PER_SECOND = keccak256(abi.encode(\"FUNDING_INCREASE_FACTOR_PER_SECOND\"));\n    // @dev key for funding decrease factor\n    bytes32 public constant FUNDING_DECREASE_FACTOR_PER_SECOND = keccak256(abi.encode(\"FUNDING_DECREASE_FACTOR_PER_SECOND\"));\n    // @dev key for min funding factor\n    bytes32 public constant MIN_FUNDING_FACTOR_PER_SECOND = keccak256(abi.encode(\"MIN_FUNDING_FACTOR_PER_SECOND\"));\n    // @dev key for max funding factor\n    bytes32 public constant MAX_FUNDING_FACTOR_PER_SECOND = keccak256(abi.encode(\"MAX_FUNDING_FACTOR_PER_SECOND\"));\n    // @dev key for max funding factor limit\n    bytes32 public constant MAX_FUNDING_FACTOR_PER_SECOND_LIMIT = keccak256(abi.encode(\"MAX_FUNDING_FACTOR_PER_SECOND_LIMIT\"));\n    // @dev key for threshold for stable funding\n    bytes32 public constant THRESHOLD_FOR_STABLE_FUNDING = keccak256(abi.encode(\"THRESHOLD_FOR_STABLE_FUNDING\"));\n    // @dev key for threshold for decrease funding\n    bytes32 public constant THRESHOLD_FOR_DECREASE_FUNDING = keccak256(abi.encode(\"THRESHOLD_FOR_DECREASE_FUNDING\"));\n    // @dev key for funding fee amount per size\n    bytes32 public constant FUNDING_FEE_AMOUNT_PER_SIZE = keccak256(abi.encode(\"FUNDING_FEE_AMOUNT_PER_SIZE\"));\n    // @dev key for claimable funding amount per size\n    bytes32 public constant CLAIMABLE_FUNDING_AMOUNT_PER_SIZE = keccak256(abi.encode(\"CLAIMABLE_FUNDING_AMOUNT_PER_SIZE\"));\n    // @dev key for when funding was last updated at\n    bytes32 public constant FUNDING_UPDATED_AT = keccak256(abi.encode(\"FUNDING_UPDATED_AT\"));\n    // @dev key for claimable funding amount\n    bytes32 public constant CLAIMABLE_FUNDING_AMOUNT = keccak256(abi.encode(\"CLAIMABLE_FUNDING_AMOUNT\"));\n    // @dev key for claimable collateral amount\n    bytes32 public constant CLAIMABLE_COLLATERAL_AMOUNT = keccak256(abi.encode(\"CLAIMABLE_COLLATERAL_AMOUNT\"));\n    // @dev key for claimable collateral factor\n    bytes32 public constant CLAIMABLE_COLLATERAL_FACTOR = keccak256(abi.encode(\"CLAIMABLE_COLLATERAL_FACTOR\"));\n    // @dev key for claimable collateral time divisor\n    bytes32 public constant CLAIMABLE_COLLATERAL_TIME_DIVISOR = keccak256(abi.encode(\"CLAIMABLE_COLLATERAL_TIME_DIVISOR\"));\n    // @dev key for claimed collateral amount\n    bytes32 public constant CLAIMED_COLLATERAL_AMOUNT = keccak256(abi.encode(\"CLAIMED_COLLATERAL_AMOUNT\"));\n    // @dev key for optimal usage factor\n    bytes32 public constant OPTIMAL_USAGE_FACTOR = keccak256(abi.encode(\"OPTIMAL_USAGE_FACTOR\"));\n    // @dev key for base borrowing factor\n    bytes32 public constant BASE_BORROWING_FACTOR = keccak256(abi.encode(\"BASE_BORROWING_FACTOR\"));\n    // @dev key for above optimal usage borrowing factor\n    bytes32 public constant ABOVE_OPTIMAL_USAGE_BORROWING_FACTOR = keccak256(abi.encode(\"ABOVE_OPTIMAL_USAGE_BORROWING_FACTOR\"));\n    // @dev key for borrowing factor\n    bytes32 public constant BORROWING_FACTOR = keccak256(abi.encode(\"BORROWING_FACTOR\"));\n    // @dev key for borrowing factor\n    bytes32 public constant BORROWING_EXPONENT_FACTOR = keccak256(abi.encode(\"BORROWING_EXPONENT_FACTOR\"));\n    // @dev key for skipping the borrowing factor for the smaller side\n    bytes32 public constant SKIP_BORROWING_FEE_FOR_SMALLER_SIDE = keccak256(abi.encode(\"SKIP_BORROWING_FEE_FOR_SMALLER_SIDE\"));\n    // @dev key for cumulative borrowing factor\n    bytes32 public constant CUMULATIVE_BORROWING_FACTOR = keccak256(abi.encode(\"CUMULATIVE_BORROWING_FACTOR\"));\n    // @dev key for when the cumulative borrowing factor was last updated at\n    bytes32 public constant CUMULATIVE_BORROWING_FACTOR_UPDATED_AT = keccak256(abi.encode(\"CUMULATIVE_BORROWING_FACTOR_UPDATED_AT\"));\n    // @dev key for total borrowing amount\n    bytes32 public constant TOTAL_BORROWING = keccak256(abi.encode(\"TOTAL_BORROWING\"));\n    // @dev key for affiliate reward\n    bytes32 public constant AFFILIATE_REWARD = keccak256(abi.encode(\"AFFILIATE_REWARD\"));\n    // @dev key for max allowed subaccount action count\n    bytes32 public constant MAX_ALLOWED_SUBACCOUNT_ACTION_COUNT = keccak256(abi.encode(\"MAX_ALLOWED_SUBACCOUNT_ACTION_COUNT\"));\n    // @dev key for subaccount action count\n    bytes32 public constant SUBACCOUNT_ACTION_COUNT = keccak256(abi.encode(\"SUBACCOUNT_ACTION_COUNT\"));\n    // @dev key for subaccount auto top up amount\n    bytes32 public constant SUBACCOUNT_AUTO_TOP_UP_AMOUNT = keccak256(abi.encode(\"SUBACCOUNT_AUTO_TOP_UP_AMOUNT\"));\n    // @dev key for subaccount order action\n    bytes32 public constant SUBACCOUNT_ORDER_ACTION = keccak256(abi.encode(\"SUBACCOUNT_ORDER_ACTION\"));\n    // @dev key for fee distributor swap order token index\n    bytes32 public constant FEE_DISTRIBUTOR_SWAP_TOKEN_INDEX = keccak256(abi.encode(\"FEE_DISTRIBUTOR_SWAP_TOKEN_INDEX\"));\n    // @dev key for fee distributor swap fee batch\n    bytes32 public constant FEE_DISTRIBUTOR_SWAP_FEE_BATCH = keccak256(abi.encode(\"FEE_DISTRIBUTOR_SWAP_FEE_BATCH\"));\n\n    bytes32 public constant GLV_MAX_MARKET_COUNT = keccak256(abi.encode(\"GLV_MAX_MARKET_COUNT\"));\n    bytes32 public constant GLV_MAX_MARKET_TOKEN_BALANCE_USD = keccak256(abi.encode(\"GLV_MAX_MARKET_TOKEN_BALANCE_USD\"));\n    bytes32 public constant GLV_MAX_MARKET_TOKEN_BALANCE_AMOUNT = keccak256(abi.encode(\"GLV_MAX_MARKET_TOKEN_BALANCE_AMOUNT\"));\n    bytes32 public constant IS_GLV_MARKET_DISABLED = keccak256(abi.encode(\"IS_GLV_MARKET_DISABLED\"));\n    bytes32 public constant GLV_SHIFT_MAX_PRICE_IMPACT_FACTOR = keccak256(abi.encode(\"GLV_SHIFT_MAX_PRICE_IMPACT_FACTOR\"));\n    bytes32 public constant GLV_SHIFT_LAST_EXECUTED_AT = keccak256(abi.encode(\"GLV_SHIFT_LAST_EXECUTED_AT\"));\n    bytes32 public constant GLV_SHIFT_MIN_INTERVAL = keccak256(abi.encode(\"GLV_SHIFT_MIN_INTERVAL\"));\n    bytes32 public constant MIN_GLV_TOKENS_FOR_FIRST_DEPOSIT = keccak256(abi.encode(\"MIN_GLV_TOKENS_FOR_FIRST_DEPOSIT\"));\n\n    // @dev constant for user initiated cancel reason\n    string public constant USER_INITIATED_CANCEL = \"USER_INITIATED_CANCEL\";\n\n    // @dev key for the account deposit list\n    // @param account the account for the list\n    function accountDepositListKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ACCOUNT_DEPOSIT_LIST, account));\n    }\n\n    // @dev key for the account withdrawal list\n    // @param account the account for the list\n    function accountWithdrawalListKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ACCOUNT_WITHDRAWAL_LIST, account));\n    }\n\n    // @dev key for the account shift list\n    // @param account the account for the list\n    function accountShiftListKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ACCOUNT_SHIFT_LIST, account));\n    }\n\n    // @dev key for the account glv deposit list\n    // @param account the account for the list\n    function accountGlvDepositListKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ACCOUNT_GLV_DEPOSIT_LIST, account));\n    }\n\n    // @dev key for the account glv deposit list\n    // @param account the account for the list\n    function accountGlvWithdrawalListKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ACCOUNT_GLV_WITHDRAWAL_LIST, account));\n    }\n\n    // @dev key for the glv supported market list\n    // @param glv the glv for the supported market list\n    function glvSupportedMarketListKey(address glv) internal pure returns (bytes32) {\n        return keccak256(abi.encode(GLV_SUPPORTED_MARKET_LIST, glv));\n    }\n\n    // @dev key for the account position list\n    // @param account the account for the list\n    function accountPositionListKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ACCOUNT_POSITION_LIST, account));\n    }\n\n    // @dev key for the account order list\n    // @param account the account for the list\n    function accountOrderListKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ACCOUNT_ORDER_LIST, account));\n    }\n\n    // @dev key for the subaccount list\n    // @param account the account for the list\n    function subaccountListKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(SUBACCOUNT_LIST, account));\n    }\n\n    // @dev key for the auto cancel order list\n    // @param position key the position key for the list\n    function autoCancelOrderListKey(bytes32 positionKey) internal pure returns (bytes32) {\n        return keccak256(abi.encode(AUTO_CANCEL_ORDER_LIST, positionKey));\n    }\n\n    // @dev key for the claimable fee amount\n    // @param market the market for the fee\n    // @param token the token for the fee\n    function claimableFeeAmountKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(CLAIMABLE_FEE_AMOUNT, market, token));\n    }\n\n    // @dev key for the claimable ui fee amount\n    // @param market the market for the fee\n    // @param token the token for the fee\n    // @param account the account that can claim the ui fee\n    function claimableUiFeeAmountKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(CLAIMABLE_UI_FEE_AMOUNT, market, token));\n    }\n\n    // @dev key for the claimable ui fee amount for account\n    // @param market the market for the fee\n    // @param token the token for the fee\n    // @param account the account that can claim the ui fee\n    function claimableUiFeeAmountKey(address market, address token, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(CLAIMABLE_UI_FEE_AMOUNT, market, token, account));\n    }\n\n    // @dev key for deposit gas limit\n    // @param singleToken whether a single token or pair tokens are being deposited\n    // @return key for deposit gas limit\n    function depositGasLimitKey(bool singleToken) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            DEPOSIT_GAS_LIMIT,\n            singleToken\n        ));\n    }\n\n    // @dev key for withdrawal gas limit\n    // @return key for withdrawal gas limit\n    function withdrawalGasLimitKey() internal pure returns (bytes32) {\n        return WITHDRAWAL_GAS_LIMIT;\n    }\n\n    // @dev key for shift gas limit\n    // @return key for shift gas limit\n    function shiftGasLimitKey() internal pure returns (bytes32) {\n        return SHIFT_GAS_LIMIT;\n    }\n\n    function glvDepositGasLimitKey() internal pure returns (bytes32) {\n        return GLV_DEPOSIT_GAS_LIMIT;\n    }\n\n    function glvShiftGasLimitKey() internal pure returns (bytes32) {\n        return GLV_SHIFT_GAS_LIMIT;\n    }\n\n    function glvWithdrawalGasLimitKey() internal pure returns (bytes32) {\n        return GLV_WITHDRAWAL_GAS_LIMIT;\n    }\n\n    function glvPerMarketGasLimitKey() internal pure returns (bytes32) {\n        return GLV_PER_MARKET_GAS_LIMIT;\n    }\n\n    // @dev key for single swap gas limit\n    // @return key for single swap gas limit\n    function singleSwapGasLimitKey() internal pure returns (bytes32) {\n        return SINGLE_SWAP_GAS_LIMIT;\n    }\n\n    // @dev key for increase order gas limit\n    // @return key for increase order gas limit\n    function increaseOrderGasLimitKey() internal pure returns (bytes32) {\n        return INCREASE_ORDER_GAS_LIMIT;\n    }\n\n    // @dev key for decrease order gas limit\n    // @return key for decrease order gas limit\n    function decreaseOrderGasLimitKey() internal pure returns (bytes32) {\n        return DECREASE_ORDER_GAS_LIMIT;\n    }\n\n    // @dev key for swap order gas limit\n    // @return key for swap order gas limit\n    function swapOrderGasLimitKey() internal pure returns (bytes32) {\n        return SWAP_ORDER_GAS_LIMIT;\n    }\n\n    function swapPathMarketFlagKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SWAP_PATH_MARKET_FLAG,\n            market\n        ));\n    }\n\n    // @dev key for whether create glv deposit is disabled\n    // @param the create deposit module\n    // @return key for whether create deposit is disabled\n    function createGlvDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CREATE_GLV_DEPOSIT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether cancel glv deposit is disabled\n    // @param the cancel deposit module\n    // @return key for whether cancel deposit is disabled\n    function cancelGlvDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CANCEL_GLV_DEPOSIT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether execute glv deposit is disabled\n    // @param the execute deposit module\n    // @return key for whether execute deposit is disabled\n    function executeGlvDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_GLV_DEPOSIT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether create glv withdrawal is disabled\n    // @param the create withdrawal module\n    // @return key for whether create withdrawal is disabled\n    function createGlvWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CREATE_GLV_WITHDRAWAL_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether cancel glv withdrawal is disabled\n    // @param the cancel withdrawal module\n    // @return key for whether cancel withdrawal is disabled\n    function cancelGlvWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CANCEL_GLV_WITHDRAWAL_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether execute glv withdrawal is disabled\n    // @param the execute withdrawal module\n    // @return key for whether execute withdrawal is disabled\n    function executeGlvWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_GLV_WITHDRAWAL_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    function createGlvShiftFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CREATE_GLV_SHIFT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    function executeGlvShiftFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_GLV_SHIFT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n\n    // @dev key for whether create deposit is disabled\n    // @param the create deposit module\n    // @return key for whether create deposit is disabled\n    function createDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CREATE_DEPOSIT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether cancel deposit is disabled\n    // @param the cancel deposit module\n    // @return key for whether cancel deposit is disabled\n    function cancelDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CANCEL_DEPOSIT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether execute deposit is disabled\n    // @param the execute deposit module\n    // @return key for whether execute deposit is disabled\n    function executeDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_DEPOSIT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether create withdrawal is disabled\n    // @param the create withdrawal module\n    // @return key for whether create withdrawal is disabled\n    function createWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CREATE_WITHDRAWAL_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether cancel withdrawal is disabled\n    // @param the cancel withdrawal module\n    // @return key for whether cancel withdrawal is disabled\n    function cancelWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CANCEL_WITHDRAWAL_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether execute withdrawal is disabled\n    // @param the execute withdrawal module\n    // @return key for whether execute withdrawal is disabled\n    function executeWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_WITHDRAWAL_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether execute atomic withdrawal is disabled\n    // @param the execute atomic withdrawal module\n    // @return key for whether execute atomic withdrawal is disabled\n    function executeAtomicWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_ATOMIC_WITHDRAWAL_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether create shift is disabled\n    // @param the create shift module\n    // @return key for whether create shift is disabled\n    function createShiftFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CREATE_SHIFT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether cancel shift is disabled\n    // @param the cancel shift module\n    // @return key for whether cancel shift is disabled\n    function cancelShiftFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CANCEL_SHIFT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether execute shift is disabled\n    // @param the execute shift module\n    // @return key for whether execute shift is disabled\n    function executeShiftFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_SHIFT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether create order is disabled\n    // @param the create order module\n    // @return key for whether create order is disabled\n    function createOrderFeatureDisabledKey(address module, uint256 orderType) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CREATE_ORDER_FEATURE_DISABLED,\n            module,\n            orderType\n        ));\n    }\n\n    // @dev key for whether execute order is disabled\n    // @param the execute order module\n    // @return key for whether execute order is disabled\n    function executeOrderFeatureDisabledKey(address module, uint256 orderType) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_ORDER_FEATURE_DISABLED,\n            module,\n            orderType\n        ));\n    }\n\n    // @dev key for whether execute adl is disabled\n    // @param the execute adl module\n    // @return key for whether execute adl is disabled\n    function executeAdlFeatureDisabledKey(address module, uint256 orderType) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_ADL_FEATURE_DISABLED,\n            module,\n            orderType\n        ));\n    }\n\n    // @dev key for whether update order is disabled\n    // @param the update order module\n    // @return key for whether update order is disabled\n    function updateOrderFeatureDisabledKey(address module, uint256 orderType) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            UPDATE_ORDER_FEATURE_DISABLED,\n            module,\n            orderType\n        ));\n    }\n\n    // @dev key for whether cancel order is disabled\n    // @param the cancel order module\n    // @return key for whether cancel order is disabled\n    function cancelOrderFeatureDisabledKey(address module, uint256 orderType) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CANCEL_ORDER_FEATURE_DISABLED,\n            module,\n            orderType\n        ));\n    }\n\n    // @dev key for whether claim funding fees is disabled\n    // @param the claim funding fees module\n    function claimFundingFeesFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIM_FUNDING_FEES_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether claim colltareral is disabled\n    // @param the claim funding fees module\n    function claimCollateralFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIM_COLLATERAL_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether claim affiliate rewards is disabled\n    // @param the claim affiliate rewards module\n    function claimAffiliateRewardsFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIM_AFFILIATE_REWARDS_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether claim ui fees is disabled\n    // @param the claim ui fees module\n    function claimUiFeesFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIM_UI_FEES_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether subaccounts are disabled\n    // @param the subaccount module\n    function subaccountFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SUBACCOUNT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for ui fee factor\n    // @param account the fee receiver account\n    // @return key for ui fee factor\n    function uiFeeFactorKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            UI_FEE_FACTOR,\n            account\n        ));\n    }\n\n    // @dev key for whether an oracle provider is enabled\n    // @param provider the oracle provider\n    // @return key for whether an oracle provider is enabled\n    function isOracleProviderEnabledKey(address provider) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            IS_ORACLE_PROVIDER_ENABLED,\n            provider\n        ));\n    }\n\n    // @dev key for whether an oracle provider is allowed to be used for atomic actions\n    // @param provider the oracle provider\n    // @return key for whether an oracle provider is allowed to be used for atomic actions\n    function isAtomicOracleProviderKey(address provider) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            IS_ATOMIC_ORACLE_PROVIDER,\n            provider\n        ));\n    }\n\n    // @dev key for oracle timestamp adjustment\n    // @param provider the oracle provider\n    // @param token the token\n    // @return key for oracle timestamp adjustment\n    function oracleTimestampAdjustmentKey(address provider, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            ORACLE_TIMESTAMP_ADJUSTMENT,\n            provider,\n            token\n        ));\n    }\n\n    // @dev key for oracle provider for token\n    // @param token the token\n    // @return key for oracle provider for token\n    function oracleProviderForTokenKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            ORACLE_PROVIDER_FOR_TOKEN,\n            token\n        ));\n    }\n\n    // @dev key for gas to forward for token transfer\n    // @param the token to check\n    // @return key for gas to forward for token transfer\n    function tokenTransferGasLimit(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            TOKEN_TRANSFER_GAS_LIMIT,\n            token\n        ));\n   }\n\n   // @dev the default callback contract\n   // @param account the user's account\n   // @param market the address of the market\n   // @param callbackContract the callback contract\n   function savedCallbackContract(address account, address market) internal pure returns (bytes32) {\n       return keccak256(abi.encode(\n           SAVED_CALLBACK_CONTRACT,\n           account,\n           market\n       ));\n   }\n\n   // @dev the min collateral factor key\n   // @param the market for the min collateral factor\n   function minCollateralFactorKey(address market) internal pure returns (bytes32) {\n       return keccak256(abi.encode(\n           MIN_COLLATERAL_FACTOR,\n           market\n       ));\n   }\n\n   // @dev the min collateral factor for open interest multiplier key\n   // @param the market for the factor\n   function minCollateralFactorForOpenInterestMultiplierKey(address market, bool isLong) internal pure returns (bytes32) {\n       return keccak256(abi.encode(\n           MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER,\n           market,\n           isLong\n       ));\n   }\n\n   // @dev the key for the virtual token id\n   // @param the token to get the virtual id for\n   function virtualTokenIdKey(address token) internal pure returns (bytes32) {\n       return keccak256(abi.encode(\n           VIRTUAL_TOKEN_ID,\n           token\n       ));\n   }\n\n   // @dev the key for the virtual market id\n   // @param the market to get the virtual id for\n   function virtualMarketIdKey(address market) internal pure returns (bytes32) {\n       return keccak256(abi.encode(\n           VIRTUAL_MARKET_ID,\n           market\n       ));\n   }\n\n   // @dev the key for the virtual inventory for positions\n   // @param the virtualTokenId the virtual token id\n   function virtualInventoryForPositionsKey(bytes32 virtualTokenId) internal pure returns (bytes32) {\n       return keccak256(abi.encode(\n           VIRTUAL_INVENTORY_FOR_POSITIONS,\n           virtualTokenId\n       ));\n   }\n\n   // @dev the key for the virtual inventory for swaps\n   // @param the virtualMarketId the virtual market id\n   // @param the token to check the inventory for\n   function virtualInventoryForSwapsKey(bytes32 virtualMarketId, bool isLongToken) internal pure returns (bytes32) {\n       return keccak256(abi.encode(\n           VIRTUAL_INVENTORY_FOR_SWAPS,\n           virtualMarketId,\n           isLongToken\n       ));\n   }\n\n    // @dev key for position impact factor\n    // @param market the market address to check\n    // @param isPositive whether the impact is positive or negative\n    // @return key for position impact factor\n    function positionImpactFactorKey(address market, bool isPositive) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            POSITION_IMPACT_FACTOR,\n            market,\n            isPositive\n        ));\n   }\n\n    // @dev key for position impact exponent factor\n    // @param market the market address to check\n    // @return key for position impact exponent factor\n    function positionImpactExponentFactorKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            POSITION_IMPACT_EXPONENT_FACTOR,\n            market\n        ));\n    }\n\n    // @dev key for the max position impact factor\n    // @param market the market address to check\n    // @return key for the max position impact factor\n    function maxPositionImpactFactorKey(address market, bool isPositive) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_POSITION_IMPACT_FACTOR,\n            market,\n            isPositive\n        ));\n    }\n\n    // @dev key for the max position impact factor for liquidations\n    // @param market the market address to check\n    // @return key for the max position impact factor\n    function maxPositionImpactFactorForLiquidationsKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_POSITION_IMPACT_FACTOR_FOR_LIQUIDATIONS,\n            market\n        ));\n    }\n\n    // @dev key for position fee factor\n    // @param market the market address to check\n    // @param forPositiveImpact whether the fee is for an action that has a positive price impact\n    // @return key for position fee factor\n    function positionFeeFactorKey(address market, bool forPositiveImpact) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            POSITION_FEE_FACTOR,\n            market,\n            forPositiveImpact\n        ));\n    }\n\n    // @dev key for swap impact factor\n    // @param market the market address to check\n    // @param isPositive whether the impact is positive or negative\n    // @return key for swap impact factor\n    function swapImpactFactorKey(address market, bool isPositive) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SWAP_IMPACT_FACTOR,\n            market,\n            isPositive\n        ));\n    }\n\n    // @dev key for swap impact exponent factor\n    // @param market the market address to check\n    // @return key for swap impact exponent factor\n    function swapImpactExponentFactorKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SWAP_IMPACT_EXPONENT_FACTOR,\n            market\n        ));\n    }\n\n\n    // @dev key for swap fee factor\n    // @param market the market address to check\n    // @return key for swap fee factor\n    function swapFeeFactorKey(address market, bool forPositiveImpact) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SWAP_FEE_FACTOR,\n            market,\n            forPositiveImpact\n        ));\n    }\n\n    // @dev key for atomic swap fee factor\n    // @param market the market address to check\n    // @return key for atomic swap fee factor\n    function atomicSwapFeeFactorKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            ATOMIC_SWAP_FEE_FACTOR,\n            market\n        ));\n    }\n\n    // @dev key for oracle type\n    // @param token the token to check\n    // @return key for oracle type\n    function oracleTypeKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            ORACLE_TYPE,\n            token\n        ));\n    }\n\n    // @dev key for open interest\n    // @param market the market to check\n    // @param collateralToken the collateralToken to check\n    // @param isLong whether to check the long or short open interest\n    // @return key for open interest\n    function openInterestKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            OPEN_INTEREST,\n            market,\n            collateralToken,\n            isLong\n        ));\n    }\n\n    // @dev key for open interest in tokens\n    // @param market the market to check\n    // @param collateralToken the collateralToken to check\n    // @param isLong whether to check the long or short open interest\n    // @return key for open interest in tokens\n    function openInterestInTokensKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            OPEN_INTEREST_IN_TOKENS,\n            market,\n            collateralToken,\n            isLong\n        ));\n    }\n\n    // @dev key for collateral sum for a market\n    // @param market the market to check\n    // @param collateralToken the collateralToken to check\n    // @param isLong whether to check the long or short open interest\n    // @return key for collateral sum\n    function collateralSumKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            COLLATERAL_SUM,\n            market,\n            collateralToken,\n            isLong\n        ));\n    }\n\n    // @dev key for amount of tokens in a market's pool\n    // @param market the market to check\n    // @param token the token to check\n    // @return key for amount of tokens in a market's pool\n    function poolAmountKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            POOL_AMOUNT,\n            market,\n            token\n        ));\n    }\n\n    // @dev the key for the max amount of pool tokens\n    // @param market the market for the pool\n    // @param token the token for the pool\n    function maxPoolAmountKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_POOL_AMOUNT,\n            market,\n            token\n        ));\n    }\n\n    // @dev the key for the max usd of pool tokens for deposits\n    // @param market the market for the pool\n    // @param token the token for the pool\n    function maxPoolUsdForDepositKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_POOL_USD_FOR_DEPOSIT,\n            market,\n            token\n        ));\n    }\n\n    // @dev the key for the max open interest\n    // @param market the market for the pool\n    // @param isLong whether the key is for the long or short side\n    function maxOpenInterestKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_OPEN_INTEREST,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for amount of tokens in a market's position impact pool\n    // @param market the market to check\n    // @return key for amount of tokens in a market's position impact pool\n    function positionImpactPoolAmountKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            POSITION_IMPACT_POOL_AMOUNT,\n            market\n        ));\n    }\n\n    // @dev key for min amount of tokens in a market's position impact pool\n    // @param market the market to check\n    // @return key for min amount of tokens in a market's position impact pool\n    function minPositionImpactPoolAmountKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MIN_POSITION_IMPACT_POOL_AMOUNT,\n            market\n        ));\n    }\n\n    // @dev key for position impact pool distribution rate\n    // @param market the market to check\n    // @return key for position impact pool distribution rate\n    function positionImpactPoolDistributionRateKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            POSITION_IMPACT_POOL_DISTRIBUTION_RATE,\n            market\n        ));\n    }\n\n    // @dev key for position impact pool distributed at\n    // @param market the market to check\n    // @return key for position impact pool distributed at\n    function positionImpactPoolDistributedAtKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            POSITION_IMPACT_POOL_DISTRIBUTED_AT,\n            market\n        ));\n    }\n\n    // @dev key for amount of tokens in a market's swap impact pool\n    // @param market the market to check\n    // @param token the token to check\n    // @return key for amount of tokens in a market's swap impact pool\n    function swapImpactPoolAmountKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SWAP_IMPACT_POOL_AMOUNT,\n            market,\n            token\n        ));\n    }\n\n    // @dev key for reserve factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for reserve factor\n    function reserveFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            RESERVE_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for open interest reserve factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for open interest reserve factor\n    function openInterestReserveFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            OPEN_INTEREST_RESERVE_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for max pnl factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for max pnl factor\n    function maxPnlFactorKey(bytes32 pnlFactorType, address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_PNL_FACTOR,\n            pnlFactorType,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev the key for min PnL factor after ADL\n    // @param market the market for the pool\n    // @param isLong whether the key is for the long or short side\n    function minPnlFactorAfterAdlKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MIN_PNL_FACTOR_AFTER_ADL,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for latest adl time\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for latest adl time\n    function latestAdlAtKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            LATEST_ADL_AT,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for whether adl is enabled\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for whether adl is enabled\n    function isAdlEnabledKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            IS_ADL_ENABLED,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for funding factor\n    // @param market the market to check\n    // @return key for funding factor\n    function fundingFactorKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FUNDING_FACTOR,\n            market\n        ));\n    }\n\n    // @dev the key for funding exponent\n    // @param market the market for the pool\n    function fundingExponentFactorKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FUNDING_EXPONENT_FACTOR,\n            market\n        ));\n    }\n\n    // @dev the key for saved funding factor\n    // @param market the market for the pool\n    function savedFundingFactorPerSecondKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SAVED_FUNDING_FACTOR_PER_SECOND,\n            market\n        ));\n    }\n\n    // @dev the key for funding increase factor\n    // @param market the market for the pool\n    function fundingIncreaseFactorPerSecondKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FUNDING_INCREASE_FACTOR_PER_SECOND,\n            market\n        ));\n    }\n\n    // @dev the key for funding decrease factor\n    // @param market the market for the pool\n    function fundingDecreaseFactorPerSecondKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FUNDING_DECREASE_FACTOR_PER_SECOND,\n            market\n        ));\n    }\n\n    // @dev the key for min funding factor\n    // @param market the market for the pool\n    function minFundingFactorPerSecondKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MIN_FUNDING_FACTOR_PER_SECOND,\n            market\n        ));\n    }\n\n    // @dev the key for max funding factor\n    // @param market the market for the pool\n    function maxFundingFactorPerSecondKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_FUNDING_FACTOR_PER_SECOND,\n            market\n        ));\n    }\n\n    // @dev the key for threshold for stable funding\n    // @param market the market for the pool\n    function thresholdForStableFundingKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            THRESHOLD_FOR_STABLE_FUNDING,\n            market\n        ));\n    }\n\n    // @dev the key for threshold for decreasing funding\n    // @param market the market for the pool\n    function thresholdForDecreaseFundingKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            THRESHOLD_FOR_DECREASE_FUNDING,\n            market\n        ));\n    }\n\n    // @dev key for funding fee amount per size\n    // @param market the market to check\n    // @param collateralToken the collateralToken to get the key for\n    // @param isLong whether to get the key for the long or short side\n    // @return key for funding fee amount per size\n    function fundingFeeAmountPerSizeKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FUNDING_FEE_AMOUNT_PER_SIZE,\n            market,\n            collateralToken,\n            isLong\n        ));\n    }\n\n    // @dev key for claimabel funding amount per size\n    // @param market the market to check\n    // @param collateralToken the collateralToken to get the key for\n    // @param isLong whether to get the key for the long or short side\n    // @return key for claimable funding amount per size\n    function claimableFundingAmountPerSizeKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMABLE_FUNDING_AMOUNT_PER_SIZE,\n            market,\n            collateralToken,\n            isLong\n        ));\n    }\n\n    // @dev key for when funding was last updated\n    // @param market the market to check\n    // @return key for when funding was last updated\n    function fundingUpdatedAtKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FUNDING_UPDATED_AT,\n            market\n        ));\n    }\n\n    // @dev key for claimable funding amount\n    // @param market the market to check\n    // @param token the token to check\n    // @return key for claimable funding amount\n    function claimableFundingAmountKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMABLE_FUNDING_AMOUNT,\n            market,\n            token\n        ));\n    }\n\n    // @dev key for claimable funding amount by account\n    // @param market the market to check\n    // @param token the token to check\n    // @param account the account to check\n    // @return key for claimable funding amount\n    function claimableFundingAmountKey(address market, address token, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMABLE_FUNDING_AMOUNT,\n            market,\n            token,\n            account\n        ));\n    }\n\n    // @dev key for claimable collateral amount\n    // @param market the market to check\n    // @param token the token to check\n    // @param account the account to check\n    // @param timeKey the time key for the claimable amount\n    // @return key for claimable funding amount\n    function claimableCollateralAmountKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMABLE_COLLATERAL_AMOUNT,\n            market,\n            token\n        ));\n    }\n\n    // @dev key for claimable collateral amount for a timeKey for an account\n    // @param market the market to check\n    // @param token the token to check\n    // @param account the account to check\n    // @param timeKey the time key for the claimable amount\n    // @return key for claimable funding amount\n    function claimableCollateralAmountKey(address market, address token, uint256 timeKey, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMABLE_COLLATERAL_AMOUNT,\n            market,\n            token,\n            timeKey,\n            account\n        ));\n    }\n\n    // @dev key for claimable collateral factor for a timeKey\n    // @param market the market to check\n    // @param token the token to check\n    // @param timeKey the time key for the claimable amount\n    // @return key for claimable funding amount\n    function claimableCollateralFactorKey(address market, address token, uint256 timeKey) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMABLE_COLLATERAL_FACTOR,\n            market,\n            token,\n            timeKey\n        ));\n    }\n\n    // @dev key for claimable collateral factor for a timeKey for an account\n    // @param market the market to check\n    // @param token the token to check\n    // @param timeKey the time key for the claimable amount\n    // @param account the account to check\n    // @return key for claimable funding amount\n    function claimableCollateralFactorKey(address market, address token, uint256 timeKey, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMABLE_COLLATERAL_FACTOR,\n            market,\n            token,\n            timeKey,\n            account\n        ));\n    }\n\n    // @dev key for claimable collateral factor\n    // @param market the market to check\n    // @param token the token to check\n    // @param account the account to check\n    // @param timeKey the time key for the claimable amount\n    // @return key for claimable funding amount\n    function claimedCollateralAmountKey(address market, address token, uint256 timeKey, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMED_COLLATERAL_AMOUNT,\n            market,\n            token,\n            timeKey,\n            account\n        ));\n    }\n\n    // @dev key for optimal usage factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for optimal usage factor\n    function optimalUsageFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            OPTIMAL_USAGE_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for base borrowing factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for base borrowing factor\n    function baseBorrowingFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            BASE_BORROWING_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for above optimal usage borrowing factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for above optimal usage borrowing factor\n    function aboveOptimalUsageBorrowingFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            ABOVE_OPTIMAL_USAGE_BORROWING_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for borrowing factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for borrowing factor\n    function borrowingFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            BORROWING_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev the key for borrowing exponent\n    // @param market the market for the pool\n    // @param isLong whether to get the key for the long or short side\n    function borrowingExponentFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            BORROWING_EXPONENT_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for cumulative borrowing factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for cumulative borrowing factor\n    function cumulativeBorrowingFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CUMULATIVE_BORROWING_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for cumulative borrowing factor updated at\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for cumulative borrowing factor updated at\n    function cumulativeBorrowingFactorUpdatedAtKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CUMULATIVE_BORROWING_FACTOR_UPDATED_AT,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for total borrowing amount\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for total borrowing amount\n    function totalBorrowingKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            TOTAL_BORROWING,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for affiliate reward amount\n    // @param market the market to check\n    // @param token the token to get the key for\n    // @param account the account to get the key for\n    // @return key for affiliate reward amount\n    function affiliateRewardKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            AFFILIATE_REWARD,\n            market,\n            token\n        ));\n    }\n\n    function maxAllowedSubaccountActionCountKey(address account, address subaccount, bytes32 actionType) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_ALLOWED_SUBACCOUNT_ACTION_COUNT,\n            account,\n            subaccount,\n            actionType\n        ));\n    }\n\n    function subaccountActionCountKey(address account, address subaccount, bytes32 actionType) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SUBACCOUNT_ACTION_COUNT,\n            account,\n            subaccount,\n            actionType\n        ));\n    }\n\n    function subaccountAutoTopUpAmountKey(address account, address subaccount) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SUBACCOUNT_AUTO_TOP_UP_AMOUNT,\n            account,\n            subaccount\n        ));\n    }\n\n    // @dev key for affiliate reward amount for an account\n    // @param market the market to check\n    // @param token the token to get the key for\n    // @param account the account to get the key for\n    // @return key for affiliate reward amount\n    function affiliateRewardKey(address market, address token, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            AFFILIATE_REWARD,\n            market,\n            token,\n            account\n        ));\n    }\n\n    // @dev key for is market disabled\n    // @param market the market to check\n    // @return key for is market disabled\n    function isMarketDisabledKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            IS_MARKET_DISABLED,\n            market\n        ));\n    }\n\n    // @dev key for min market tokens for first deposit\n    // @param market the market to check\n    // @return key for min market tokens for first deposit\n    function minMarketTokensForFirstDepositKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MIN_MARKET_TOKENS_FOR_FIRST_DEPOSIT,\n            market\n        ));\n    }\n\n    // @dev key for price feed address\n    // @param token the token to get the key for\n    // @return key for price feed address\n    function priceFeedKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            PRICE_FEED,\n            token\n        ));\n    }\n\n    // @dev key for data stream feed ID\n    // @param token the token to get the key for\n    // @return key for data stream feed ID\n    function dataStreamIdKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            DATA_STREAM_ID,\n            token\n        ));\n    }\n\n    // @dev key for data stream feed multiplier\n    // @param token the token to get the key for\n    // @return key for data stream feed multiplier\n    function dataStreamMultiplierKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            DATA_STREAM_MULTIPLIER,\n            token\n        ));\n    }\n\n    // @dev key for price feed multiplier\n    // @param token the token to get the key for\n    // @return key for price feed multiplier\n    function priceFeedMultiplierKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            PRICE_FEED_MULTIPLIER,\n            token\n        ));\n    }\n\n    function priceFeedHeartbeatDurationKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            PRICE_FEED_HEARTBEAT_DURATION,\n            token\n        ));\n    }\n\n    // @dev key for stable price value\n    // @param token the token to get the key for\n    // @return key for stable price value\n    function stablePriceKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            STABLE_PRICE,\n            token\n        ));\n    }\n\n    // @dev key for fee distributor swap token index\n    // @param orderKey the swap order key\n    // @return key for fee distributor swap token index\n    function feeDistributorSwapTokenIndexKey(bytes32 orderKey) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FEE_DISTRIBUTOR_SWAP_TOKEN_INDEX,\n            orderKey\n        ));\n    }\n\n    // @dev key for fee distributor swap fee batch key\n    // @param orderKey the swap order key\n    // @return key for fee distributor swap fee batch key\n    function feeDistributorSwapFeeBatchKey(bytes32 orderKey) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FEE_DISTRIBUTOR_SWAP_FEE_BATCH,\n            orderKey\n        ));\n    }\n\n    // @dev key for max market token balance usd\n    // it is used to limit amount of funds deposited into each market\n    function glvMaxMarketTokenBalanceUsdKey(address glv, address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(GLV_MAX_MARKET_TOKEN_BALANCE_USD, glv, market));\n    }\n\n    // @dev key for max market token balance amount\n    // it is used to limit amount of funds deposited into each market\n    function glvMaxMarketTokenBalanceAmountKey(address glv, address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(GLV_MAX_MARKET_TOKEN_BALANCE_AMOUNT, glv, market));\n    }\n\n    // @dev key for is glv market disabled\n    function isGlvMarketDisabledKey(address glv, address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            IS_GLV_MARKET_DISABLED,\n            glv,\n            market\n        ));\n    }\n\n    // @dev key for max allowed price impact for glv shifts\n    // if effective price impact exceeds max price impact then glv shift fails\n    function glvShiftMaxPriceImpactFactorKey(address glv) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            GLV_SHIFT_MAX_PRICE_IMPACT_FACTOR,\n            glv\n        ));\n    }\n\n    // @dev key for time when glv shift was executed last\n    // used to validate glv shifts are not executed too frequently\n    function glvShiftLastExecutedAtKey(address glv) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            GLV_SHIFT_LAST_EXECUTED_AT,\n            glv\n        ));\n    }\n\n    // @dev key for min time interval between glv shifts in seconds\n    function glvShiftMinIntervalKey(address glv) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            GLV_SHIFT_MIN_INTERVAL,\n            glv\n        ));\n    }\n\n    function minGlvTokensForFirstGlvDepositKey(address glv) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MIN_GLV_TOKENS_FOR_FIRST_DEPOSIT,\n            glv\n        ));\n    }\n}\n"
    },
    "contracts/error/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nlibrary Errors {\n    // AdlHandler errors\n    error AdlNotRequired(int256 pnlToPoolFactor, uint256 maxPnlFactorForAdl);\n    error InvalidAdl(int256 nextPnlToPoolFactor, int256 pnlToPoolFactor);\n    error PnlOvercorrected(int256 nextPnlToPoolFactor, uint256 minPnlFactorForAdl);\n\n    // AdlUtils errors\n    error InvalidSizeDeltaForAdl(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\n    error AdlNotEnabled();\n\n    // AutoCancelUtils errors\n    error MaxAutoCancelOrdersExceeded(uint256 count, uint256 maxAutoCancelOrders);\n\n    // Bank errors\n    error SelfTransferNotSupported(address receiver);\n    error InvalidNativeTokenSender(address msgSender);\n\n    // BaseHandler errors\n    error RequestNotYetCancellable(uint256 requestAge, uint256 requestExpirationAge, string requestType);\n\n    // CallbackUtils errors\n    error MaxCallbackGasLimitExceeded(uint256 callbackGasLimit, uint256 maxCallbackGasLimit);\n    error InsufficientGasLeftForCallback(uint256 gasToBeForwarded, uint256 callbackGasLimit);\n\n    // Config errors\n    error InvalidBaseKey(bytes32 baseKey);\n    error ConfigValueExceedsAllowedRange(bytes32 baseKey, uint256 value);\n    error InvalidClaimableFactor(uint256 value);\n    error OracleProviderAlreadyExistsForToken(address token);\n    error PriceFeedAlreadyExistsForToken(address token);\n    error DataStreamIdAlreadyExistsForToken(address token);\n    error MaxFundingFactorPerSecondLimitExceeded(uint256 maxFundingFactorPerSecond, uint256 limit);\n\n    // Timelock errors\n    error ActionAlreadySignalled();\n    error ActionNotSignalled();\n    error SignalTimeNotYetPassed(uint256 signalTime);\n    error InvalidTimelockDelay(uint256 timelockDelay);\n    error MaxTimelockDelayExceeded(uint256 timelockDelay);\n    error InvalidFeeReceiver(address receiver);\n    error InvalidOracleSigner(address receiver);\n\n    // GlvDepositStoreUtils errors\n    error GlvDepositNotFound(bytes32 key);\n    // GlvShiftStoreUtils errors\n    error GlvShiftNotFound(bytes32 key);\n    // GlvWithdrawalStoreUtils errors\n    error GlvWithdrawalNotFound(bytes32 key);\n    // GlvDepositUtils errors\n    error EmptyGlvDepositAmounts();\n    error EmptyGlvMarketAmount();\n    error EmptyGlvDeposit();\n    error InvalidMinGlvTokensForFirstGlvDeposit(uint256 minGlvTokens, uint256 expectedMinGlvTokens);\n    error InvalidReceiverForFirstGlvDeposit(address receiver, address expectedReceiver);\n    // GlvWithdrawalUtils errors\n    error EmptyGlvWithdrawal();\n    error EmptyGlvWithdrawalAmount();\n    // GlvUtils errors\n    error EmptyGlv(address glv);\n    error EmptyGlvTokenSupply();\n    error GlvNegativeMarketPoolValue(address glv, address market);\n    error GlvUnsupportedMarket(address glv, address market);\n    error GlvDisabledMarket(address glv, address market);\n    error GlvEnabledMarket(address glv, address market);\n    error GlvNonZeroMarketBalance(address glv, address market);\n    error GlvMaxMarketCountExceeded(address glv, uint256 glvMaxMarketCount);\n    error GlvMaxMarketTokenBalanceUsdExceeded(address glv, address market, uint256 maxMarketTokenBalanceUsd, uint256 marketTokenBalanceUsd);\n    error GlvMaxMarketTokenBalanceAmountExceeded(address glv, address market, uint256 maxMarketTokenBalanceAmount, uint256 marketTokenBalanceAmount);\n    error GlvInsufficientMarketTokenBalance(address glv, address market, uint256 marketTokenBalance, uint256 marketTokenAmount);\n    error GlvMarketAlreadyExists(address glv, address market);\n    error GlvInvalidLongToken(address glv, address provided, address expected);\n    error GlvInvalidShortToken(address glv, address provided, address expected);\n    // GlvShiftUtils\n    error GlvShiftMaxPriceImpactExceeded(uint256 effectivePriceImpactFactor, uint256 glvMaxShiftPriceImpactFactor);\n    error GlvShiftIntervalNotYetPassed(uint256 currentTimestamp, uint256 lastGlvShiftExecutedAt, uint256 glvShiftMinInterval);\n    // GlvFactory\n    error GlvAlreadyExists(bytes32 salt, address glv);\n    error GlvSymbolTooLong();\n    error GlvNameTooLong();\n    // GlvStoreUtils\n    error GlvNotFound(address key);\n\n    // DepositStoreUtils errors\n    error DepositNotFound(bytes32 key);\n\n    // DepositUtils errors\n    error EmptyDeposit();\n    error EmptyDepositAmounts();\n\n    // ExecuteDepositUtils errors\n    error MinMarketTokens(uint256 received, uint256 expected);\n    error EmptyDepositAmountsAfterSwap();\n    error InvalidPoolValueForDeposit(int256 poolValue);\n    error InvalidSwapOutputToken(address outputToken, address expectedOutputToken);\n    error InvalidReceiverForFirstDeposit(address receiver, address expectedReceiver);\n    error InvalidMinMarketTokensForFirstDeposit(uint256 minMarketTokens, uint256 expectedMinMarketTokens);\n\n    // ExternalHandler errors\n    error ExternalCallFailed(bytes data);\n    error InvalidExternalCallInput(uint256 targetsLength, uint256 dataListLength);\n    error InvalidExternalReceiversInput(uint256 refundTokensLength, uint256 refundReceiversLength);\n    error InvalidExternalCallTarget(address target);\n\n    // FeeBatchStoreUtils errors\n    error FeeBatchNotFound(bytes32 key);\n\n    // FeeDistributor errors\n    error InvalidFeeBatchTokenIndex(uint256 tokenIndex, uint256 feeBatchTokensLength);\n    error InvalidAmountInForFeeBatch(uint256 amountIn, uint256 remainingAmount);\n    error InvalidSwapPathForV1(address[] path, address bridgingToken);\n\n    // GlpMigrator errors\n    error InvalidGlpAmount(uint256 totalGlpAmountToRedeem, uint256 totalGlpAmount);\n    error InvalidExecutionFeeForMigration(uint256 totalExecutionFee, uint256 msgValue);\n\n    // GlvHandler errors\n    error InvalidGlvDepositInitialLongToken(address initialLongToken);\n    error InvalidGlvDepositInitialShortToken(address initialShortToken);\n    error InvalidGlvDepositSwapPath(uint256 longTokenSwapPathLength, uint256 shortTokenSwapPathLength);\n    error MinGlvTokens(uint256 received, uint256 expected);\n\n    // OrderHandler errors\n    error OrderNotUpdatable(uint256 orderType);\n    error InvalidKeeperForFrozenOrder(address keeper);\n\n    // FeatureUtils errors\n    error DisabledFeature(bytes32 key);\n\n    // FeeHandler errors\n    error InvalidClaimFeesInput(uint256 marketsLength, uint256 tokensLength);\n\n    // GasUtils errors\n    error InsufficientExecutionFee(uint256 minExecutionFee, uint256 executionFee);\n    error InsufficientWntAmountForExecutionFee(uint256 wntAmount, uint256 executionFee);\n    error InsufficientExecutionGasForErrorHandling(uint256 startingGas, uint256 minHandleErrorGas);\n    error InsufficientExecutionGas(uint256 startingGas, uint256 estimatedGasLimit, uint256 minAdditionalGasForExecution);\n    error InsufficientHandleExecutionErrorGas(uint256 gas, uint256 minHandleExecutionErrorGas);\n    error InsufficientGasForCancellation(uint256 gas, uint256 minHandleExecutionErrorGas);\n\n    // MarketFactory errors\n    error MarketAlreadyExists(bytes32 salt, address existingMarketAddress);\n\n    // MarketStoreUtils errors\n    error MarketNotFound(address key);\n\n    // MarketUtils errors\n    error EmptyMarket();\n    error DisabledMarket(address market);\n    error MaxSwapPathLengthExceeded(uint256 swapPathLengh, uint256 maxSwapPathLength);\n    error InsufficientPoolAmount(uint256 poolAmount, uint256 amount);\n    error InsufficientReserve(uint256 reservedUsd, uint256 maxReservedUsd);\n    error InsufficientReserveForOpenInterest(uint256 reservedUsd, uint256 maxReservedUsd);\n    error UnableToGetOppositeToken(address inputToken, address market);\n    error UnexpectedTokenForVirtualInventory(address token, address market);\n    error EmptyMarketTokenSupply();\n    error InvalidSwapMarket(address market);\n    error UnableToGetCachedTokenPrice(address token, address market);\n    error CollateralAlreadyClaimed(uint256 adjustedClaimableAmount, uint256 claimedAmount);\n    error OpenInterestCannotBeUpdatedForSwapOnlyMarket(address market);\n    error MaxOpenInterestExceeded(uint256 openInterest, uint256 maxOpenInterest);\n    error MaxPoolAmountExceeded(uint256 poolAmount, uint256 maxPoolAmount);\n    error MaxPoolUsdForDepositExceeded(uint256 poolUsd, uint256 maxPoolUsdForDeposit);\n    error UnexpectedBorrowingFactor(uint256 positionBorrowingFactor, uint256 cumulativeBorrowingFactor);\n    error UnableToGetBorrowingFactorEmptyPoolUsd();\n    error UnableToGetFundingFactorEmptyOpenInterest();\n    error InvalidPositionMarket(address market);\n    error InvalidCollateralTokenForMarket(address market, address token);\n    error PnlFactorExceededForLongs(int256 pnlToPoolFactor, uint256 maxPnlFactor);\n    error PnlFactorExceededForShorts(int256 pnlToPoolFactor, uint256 maxPnlFactor);\n    error InvalidUiFeeFactor(uint256 uiFeeFactor, uint256 maxUiFeeFactor);\n    error EmptyAddressInMarketTokenBalanceValidation(address market, address token);\n    error InvalidMarketTokenBalance(address market, address token, uint256 balance, uint256 expectedMinBalance);\n    error InvalidMarketTokenBalanceForCollateralAmount(address market, address token, uint256 balance, uint256 collateralAmount);\n    error InvalidMarketTokenBalanceForClaimableFunding(address market, address token, uint256 balance, uint256 claimableFundingFeeAmount);\n    error UnexpectedPoolValue(int256 poolValue);\n\n    // Oracle errors\n    error SequencerDown();\n    error SequencerGraceDurationNotYetPassed(uint256 timeSinceUp, uint256 sequencerGraceDuration);\n    error EmptyValidatedPrices();\n    error InvalidOracleProvider(address provider);\n    error InvalidOracleProviderForToken(address provider, address expectedProvider);\n    error GmEmptySigner(uint256 signerIndex);\n    error InvalidOracleSetPricesProvidersParam(uint256 tokensLength, uint256 providersLength);\n    error InvalidOracleSetPricesDataParam(uint256 tokensLength, uint256 dataLength);\n    error GmInvalidBlockNumber(uint256 minOracleBlockNumber, uint256 currentBlockNumber);\n    error GmInvalidMinMaxBlockNumber(uint256 minOracleBlockNumber, uint256 maxOracleBlockNumber);\n    error EmptyDataStreamFeedId(address token);\n    error InvalidDataStreamFeedId(address token, bytes32 feedId, bytes32 expectedFeedId);\n    error InvalidDataStreamBidAsk(address token, int192 bid, int192 ask);\n    error InvalidDataStreamPrices(address token, int192 bid, int192 ask);\n    error MaxPriceAgeExceeded(uint256 oracleTimestamp, uint256 currentTimestamp);\n    error MaxOracleTimestampRangeExceeded(uint256 range, uint256 maxRange);\n    error GmMinOracleSigners(uint256 oracleSigners, uint256 minOracleSigners);\n    error GmMaxOracleSigners(uint256 oracleSigners, uint256 maxOracleSigners);\n    error BlockNumbersNotSorted(uint256 minOracleBlockNumber, uint256 prevMinOracleBlockNumber);\n    error GmMinPricesNotSorted(address token, uint256 price, uint256 prevPrice);\n    error GmMaxPricesNotSorted(address token, uint256 price, uint256 prevPrice);\n    error EmptyChainlinkPriceFeedMultiplier(address token);\n    error EmptyDataStreamMultiplier(address token);\n    error InvalidFeedPrice(address token, int256 price);\n    error ChainlinkPriceFeedNotUpdated(address token, uint256 timestamp, uint256 heartbeatDuration);\n    error GmMaxSignerIndex(uint256 signerIndex, uint256 maxSignerIndex);\n    error InvalidGmOraclePrice(address token);\n    error InvalidGmSignerMinMaxPrice(uint256 minPrice, uint256 maxPrice);\n    error InvalidGmMedianMinMaxPrice(uint256 minPrice, uint256 maxPrice);\n    error NonEmptyTokensWithPrices(uint256 tokensWithPricesLength);\n    error InvalidMinMaxForPrice(address token, uint256 min, uint256 max);\n    error EmptyChainlinkPriceFeed(address token);\n    error PriceAlreadySet(address token, uint256 minPrice, uint256 maxPrice);\n    error MaxRefPriceDeviationExceeded(\n        address token,\n        uint256 price,\n        uint256 refPrice,\n        uint256 maxRefPriceDeviationFactor\n    );\n    error InvalidBlockRangeSet(uint256 largestMinBlockNumber, uint256 smallestMaxBlockNumber);\n    error EmptyChainlinkPaymentToken();\n    error NonAtomicOracleProvider(address provider);\n\n    // OracleModule errors\n    error InvalidPrimaryPricesForSimulation(uint256 primaryTokensLength, uint256 primaryPricesLength);\n    error EndOfOracleSimulation();\n\n    // OracleUtils errors\n    error InvalidGmSignature(address recoveredSigner, address expectedSigner);\n\n    error EmptyPrimaryPrice(address token);\n\n    error OracleTimestampsAreSmallerThanRequired(uint256 minOracleTimestamp, uint256 expectedTimestamp);\n    error OracleTimestampsAreLargerThanRequestExpirationTime(uint256 maxOracleTimestamp, uint256 requestTimestamp, uint256 requestExpirationTime);\n\n    // BaseOrderUtils errors\n    error EmptyOrder();\n    error UnsupportedOrderType(uint256 orderType);\n    error InvalidOrderPrices(\n        uint256 primaryPriceMin,\n        uint256 primaryPriceMax,\n        uint256 triggerPrice,\n        uint256 orderType\n    );\n    error EmptySizeDeltaInTokens();\n    error PriceImpactLargerThanOrderSize(int256 priceImpactUsd, uint256 sizeDeltaUsd);\n    error NegativeExecutionPrice(int256 executionPrice, uint256 price, uint256 positionSizeInUsd, int256 priceImpactUsd, uint256 sizeDeltaUsd);\n    error OrderNotFulfillableAtAcceptablePrice(uint256 price, uint256 acceptablePrice);\n\n    // IncreaseOrderUtils errors\n    error UnexpectedPositionState();\n\n    // OrderUtils errors\n    error OrderTypeCannotBeCreated(uint256 orderType);\n    error OrderAlreadyFrozen();\n    error MaxTotalCallbackGasLimitForAutoCancelOrdersExceeded(uint256 totalCallbackGasLimit, uint256 maxTotalCallbackGasLimit);\n    error InvalidReceiver(address receiver);\n\n    // OrderStoreUtils errors\n    error OrderNotFound(bytes32 key);\n\n    // SwapOrderUtils errors\n    error UnexpectedMarket();\n\n    // DecreasePositionCollateralUtils errors\n    error InsufficientFundsToPayForCosts(uint256 remainingCostUsd, string step);\n    error InvalidOutputToken(address tokenOut, address expectedTokenOut);\n\n    // DecreasePositionUtils errors\n    error InvalidDecreaseOrderSize(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\n    error UnableToWithdrawCollateral(int256 estimatedRemainingCollateralUsd);\n    error InvalidDecreasePositionSwapType(uint256 decreasePositionSwapType);\n    error PositionShouldNotBeLiquidated(\n        string reason,\n        int256 remainingCollateralUsd,\n        int256 minCollateralUsd,\n        int256 minCollateralUsdForLeverage\n    );\n\n    // IncreasePositionUtils errors\n    error InsufficientCollateralAmount(uint256 collateralAmount, int256 collateralDeltaAmount);\n    error InsufficientCollateralUsd(int256 remainingCollateralUsd);\n\n    // PositionStoreUtils errors\n    error PositionNotFound(bytes32 key);\n\n    // PositionUtils errors\n    error LiquidatablePosition(\n        string reason,\n        int256 remainingCollateralUsd,\n        int256 minCollateralUsd,\n        int256 minCollateralUsdForLeverage\n    );\n\n    error EmptyPosition();\n    error InvalidPositionSizeValues(uint256 sizeInUsd, uint256 sizeInTokens);\n    error MinPositionSize(uint256 positionSizeInUsd, uint256 minPositionSizeUsd);\n\n    // PositionPricingUtils errors\n    error UsdDeltaExceedsLongOpenInterest(int256 usdDelta, uint256 longOpenInterest);\n    error UsdDeltaExceedsShortOpenInterest(int256 usdDelta, uint256 shortOpenInterest);\n\n    // ShiftStoreUtils errors\n    error ShiftNotFound(bytes32 key);\n\n    // ShiftUtils errors\n    error EmptyShift();\n    error EmptyShiftAmount();\n    error ShiftFromAndToMarketAreEqual(address market);\n    error LongTokensAreNotEqual(address fromMarketLongToken, address toMarketLongToken);\n    error ShortTokensAreNotEqual(address fromMarketLongToken, address toMarketLongToken);\n\n    // SwapPricingUtils errors\n    error UsdDeltaExceedsPoolValue(int256 usdDelta, uint256 poolUsd);\n\n    // RoleModule errors\n    error Unauthorized(address msgSender, string role);\n\n    // RoleStore errors\n    error ThereMustBeAtLeastOneRoleAdmin();\n    error ThereMustBeAtLeastOneTimelockMultiSig();\n\n    // ExchangeRouter errors\n    error InvalidClaimFundingFeesInput(uint256 marketsLength, uint256 tokensLength);\n    error InvalidClaimCollateralInput(uint256 marketsLength, uint256 tokensLength, uint256 timeKeysLength);\n    error InvalidClaimAffiliateRewardsInput(uint256 marketsLength, uint256 tokensLength);\n    error InvalidClaimUiFeesInput(uint256 marketsLength, uint256 tokensLength);\n\n    // SwapUtils errors\n    error InvalidTokenIn(address tokenIn, address market);\n    error InsufficientOutputAmount(uint256 outputAmount, uint256 minOutputAmount);\n    error InsufficientSwapOutputAmount(uint256 outputAmount, uint256 minOutputAmount);\n    error DuplicatedMarketInSwapPath(address market);\n    error SwapPriceImpactExceedsAmountIn(uint256 amountAfterFees, int256 negativeImpactAmount);\n\n    // SubaccountRouter errors\n    error InvalidReceiverForSubaccountOrder(address receiver, address expectedReceiver);\n\n    // SubaccountUtils errors\n    error SubaccountNotAuthorized(address account, address subaccount);\n    error MaxSubaccountActionCountExceeded(address account, address subaccount, uint256 count, uint256 maxCount);\n\n    // TokenUtils errors\n    error EmptyTokenTranferGasLimit(address token);\n    error TokenTransferError(address token, address receiver, uint256 amount);\n    error EmptyHoldingAddress();\n\n    // AccountUtils errors\n    error EmptyAccount();\n    error EmptyReceiver();\n\n    // Array errors\n    error CompactedArrayOutOfBounds(\n        uint256[] compactedValues,\n        uint256 index,\n        uint256 slotIndex,\n        string label\n    );\n\n    error ArrayOutOfBoundsUint256(\n        uint256[] values,\n        uint256 index,\n        string label\n    );\n\n    error ArrayOutOfBoundsBytes(\n        bytes[] values,\n        uint256 index,\n        string label\n    );\n\n    // WithdrawalHandler errors\n    error SwapsNotAllowedForAtomicWithdrawal(uint256 longTokenSwapPathLength, uint256 shortTokenSwapPathLength);\n\n    // WithdrawalStoreUtils errors\n    error WithdrawalNotFound(bytes32 key);\n\n    // WithdrawalUtils errors\n    error EmptyWithdrawal();\n    error EmptyWithdrawalAmount();\n    error MinLongTokens(uint256 received, uint256 expected);\n    error MinShortTokens(uint256 received, uint256 expected);\n    error InsufficientMarketTokens(uint256 balance, uint256 expected);\n    error InsufficientWntAmount(uint256 wntAmount, uint256 executionFee);\n    error InvalidPoolValueForWithdrawal(int256 poolValue);\n\n    // Uint256Mask errors\n    error MaskIndexOutOfBounds(uint256 index, string label);\n    error DuplicatedIndex(uint256 index, string label);\n}\n"
    },
    "contracts/error/ErrorUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nlibrary ErrorUtils {\n    // To get the revert reason, referenced from https://ethereum.stackexchange.com/a/83577\n    function getRevertMessage(bytes memory result) internal pure returns (string memory, bool) {\n        // If the result length is less than 68, then the transaction either panicked or failed silently\n        if (result.length < 68) {\n            return (\"\", false);\n        }\n\n        bytes4 errorSelector = getErrorSelectorFromData(result);\n\n        // 0x08c379a0 is the selector for Error(string)\n        // referenced from https://blog.soliditylang.org/2021/04/21/custom-errors/\n        if (errorSelector == bytes4(0x08c379a0)) {\n            assembly {\n                result := add(result, 0x04)\n            }\n\n            return (abi.decode(result, (string)), true);\n        }\n\n        // error may be a custom error, return an empty string for this case\n        return (\"\", false);\n    }\n\n    function getErrorSelectorFromData(bytes memory data) internal pure returns (bytes4) {\n        bytes4 errorSelector;\n\n        assembly {\n            errorSelector := mload(add(data, 0x20))\n        }\n\n        return errorSelector;\n    }\n\n    function revertWithParsedMessage(bytes memory result) internal pure {\n        (string memory revertMessage, bool hasRevertMessage) = getRevertMessage(result);\n\n        if (hasRevertMessage) {\n            revert(revertMessage);\n        } else {\n            revertWithCustomError(result);\n        }\n    }\n\n    function revertWithCustomError(bytes memory result) internal pure {\n        // referenced from https://ethereum.stackexchange.com/a/123588\n        uint256 length = result.length;\n        assembly {\n            revert(add(result, 0x20), length)\n        }\n    }\n}\n"
    },
    "contracts/event/EventEmitter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../role/RoleModule.sol\";\nimport \"./EventUtils.sol\";\n\n// @title EventEmitter\n// @dev Contract to emit events\n// This allows main events to be emitted from a single contract\n// Logic contracts can be updated while re-using the same eventEmitter contract\n// Peripheral services like monitoring or analytics would be able to continue\n// to work without an update and without segregating historical data\ncontract EventEmitter is RoleModule {\n    event EventLog(\n        address msgSender,\n        string eventName,\n        string indexed eventNameHash,\n        EventUtils.EventLogData eventData\n    );\n\n    event EventLog1(\n        address msgSender,\n        string eventName,\n        string indexed eventNameHash,\n        bytes32 indexed topic1,\n        EventUtils.EventLogData eventData\n    );\n\n    event EventLog2(\n        address msgSender,\n        string eventName,\n        string indexed eventNameHash,\n        bytes32 indexed topic1,\n        bytes32 indexed topic2,\n        EventUtils.EventLogData eventData\n    );\n\n    constructor(RoleStore _roleStore) RoleModule(_roleStore) {}\n\n    // @dev emit a general event log\n    // @param eventName the name of the event\n    // @param eventData the event data\n    function emitEventLog(\n        string memory eventName,\n        EventUtils.EventLogData memory eventData\n    ) external onlyController {\n        emit EventLog(\n            msg.sender,\n            eventName,\n            eventName,\n            eventData\n        );\n    }\n\n    // @dev emit a general event log\n    // @param eventName the name of the event\n    // @param topic1 topic1 for indexing\n    // @param eventData the event data\n    function emitEventLog1(\n        string memory eventName,\n        bytes32 topic1,\n        EventUtils.EventLogData memory eventData\n    ) external onlyController {\n        emit EventLog1(\n            msg.sender,\n            eventName,\n            eventName,\n            topic1,\n            eventData\n        );\n    }\n\n    // @dev emit a general event log\n    // @param eventName the name of the event\n    // @param topic1 topic1 for indexing\n    // @param topic2 topic2 for indexing\n    // @param eventData the event data\n    function emitEventLog2(\n        string memory eventName,\n        bytes32 topic1,\n        bytes32 topic2,\n        EventUtils.EventLogData memory eventData\n    ) external onlyController {\n        emit EventLog2(\n            msg.sender,\n            eventName,\n            eventName,\n            topic1,\n            topic2,\n            eventData\n        );\n    }\n    // @dev event log for general use\n    // @param topic1 event topic 1\n    // @param data additional data\n    function emitDataLog1(bytes32 topic1, bytes memory data) external onlyController {\n        uint256 len = data.length;\n        assembly {\n            log1(add(data, 32), len, topic1)\n        }\n    }\n\n    // @dev event log for general use\n    // @param topic1 event topic 1\n    // @param topic2 event topic 2\n    // @param data additional data\n    function emitDataLog2(bytes32 topic1, bytes32 topic2, bytes memory data) external onlyController {\n        uint256 len = data.length;\n        assembly {\n            log2(add(data, 32), len, topic1, topic2)\n        }\n    }\n\n    // @dev event log for general use\n    // @param topic1 event topic 1\n    // @param topic2 event topic 2\n    // @param topic3 event topic 3\n    // @param data additional data\n    function emitDataLog3(bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes memory data) external onlyController {\n        uint256 len = data.length;\n        assembly {\n            log3(add(data, 32), len, topic1, topic2, topic3)\n        }\n    }\n\n    // @dev event log for general use\n    // @param topic1 event topic 1\n    // @param topic2 event topic 2\n    // @param topic3 event topic 3\n    // @param topic4 event topic 4\n    // @param data additional data\n    function emitDataLog4(bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4, bytes memory data) external onlyController {\n        uint256 len = data.length;\n        assembly {\n            log4(add(data, 32), len, topic1, topic2, topic3, topic4)\n        }\n    }\n}\n"
    },
    "contracts/event/EventUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nlibrary EventUtils {\n    struct EmitPositionDecreaseParams {\n        bytes32 key;\n        address account;\n        address market;\n        address collateralToken;\n        bool isLong;\n    }\n\n    struct EventLogData {\n        AddressItems addressItems;\n        UintItems uintItems;\n        IntItems intItems;\n        BoolItems boolItems;\n        Bytes32Items bytes32Items;\n        BytesItems bytesItems;\n        StringItems stringItems;\n    }\n\n    struct AddressItems {\n        AddressKeyValue[] items;\n        AddressArrayKeyValue[] arrayItems;\n    }\n\n    struct UintItems {\n        UintKeyValue[] items;\n        UintArrayKeyValue[] arrayItems;\n    }\n\n    struct IntItems {\n        IntKeyValue[] items;\n        IntArrayKeyValue[] arrayItems;\n    }\n\n    struct BoolItems {\n        BoolKeyValue[] items;\n        BoolArrayKeyValue[] arrayItems;\n    }\n\n    struct Bytes32Items {\n        Bytes32KeyValue[] items;\n        Bytes32ArrayKeyValue[] arrayItems;\n    }\n\n    struct BytesItems {\n        BytesKeyValue[] items;\n        BytesArrayKeyValue[] arrayItems;\n    }\n\n    struct StringItems {\n        StringKeyValue[] items;\n        StringArrayKeyValue[] arrayItems;\n    }\n\n    struct AddressKeyValue {\n        string key;\n        address value;\n    }\n\n    struct AddressArrayKeyValue {\n        string key;\n        address[] value;\n    }\n\n    struct UintKeyValue {\n        string key;\n        uint256 value;\n    }\n\n    struct UintArrayKeyValue {\n        string key;\n        uint256[] value;\n    }\n\n    struct IntKeyValue {\n        string key;\n        int256 value;\n    }\n\n    struct IntArrayKeyValue {\n        string key;\n        int256[] value;\n    }\n\n    struct BoolKeyValue {\n        string key;\n        bool value;\n    }\n\n    struct BoolArrayKeyValue {\n        string key;\n        bool[] value;\n    }\n\n    struct Bytes32KeyValue {\n        string key;\n        bytes32 value;\n    }\n\n    struct Bytes32ArrayKeyValue {\n        string key;\n        bytes32[] value;\n    }\n\n    struct BytesKeyValue {\n        string key;\n        bytes value;\n    }\n\n    struct BytesArrayKeyValue {\n        string key;\n        bytes[] value;\n    }\n\n    struct StringKeyValue {\n        string key;\n        string value;\n    }\n\n    struct StringArrayKeyValue {\n        string key;\n        string[] value;\n    }\n\n    function initItems(AddressItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.AddressKeyValue[](size);\n    }\n\n    function initArrayItems(AddressItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.AddressArrayKeyValue[](size);\n    }\n\n    function setItem(AddressItems memory items, uint256 index, string memory key, address value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(AddressItems memory items, uint256 index, string memory key, address[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(UintItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.UintKeyValue[](size);\n    }\n\n    function initArrayItems(UintItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.UintArrayKeyValue[](size);\n    }\n\n    function setItem(UintItems memory items, uint256 index, string memory key, uint256 value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(UintItems memory items, uint256 index, string memory key, uint256[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(IntItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.IntKeyValue[](size);\n    }\n\n    function initArrayItems(IntItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.IntArrayKeyValue[](size);\n    }\n\n    function setItem(IntItems memory items, uint256 index, string memory key, int256 value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(IntItems memory items, uint256 index, string memory key, int256[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(BoolItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.BoolKeyValue[](size);\n    }\n\n    function initArrayItems(BoolItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.BoolArrayKeyValue[](size);\n    }\n\n    function setItem(BoolItems memory items, uint256 index, string memory key, bool value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(BoolItems memory items, uint256 index, string memory key, bool[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(Bytes32Items memory items, uint256 size) internal pure {\n        items.items = new EventUtils.Bytes32KeyValue[](size);\n    }\n\n    function initArrayItems(Bytes32Items memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.Bytes32ArrayKeyValue[](size);\n    }\n\n    function setItem(Bytes32Items memory items, uint256 index, string memory key, bytes32 value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(Bytes32Items memory items, uint256 index, string memory key, bytes32[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(BytesItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.BytesKeyValue[](size);\n    }\n\n    function initArrayItems(BytesItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.BytesArrayKeyValue[](size);\n    }\n\n    function setItem(BytesItems memory items, uint256 index, string memory key, bytes memory value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(BytesItems memory items, uint256 index, string memory key, bytes[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(StringItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.StringKeyValue[](size);\n    }\n\n    function initArrayItems(StringItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.StringArrayKeyValue[](size);\n    }\n\n    function setItem(StringItems memory items, uint256 index, string memory key, string memory value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(StringItems memory items, uint256 index, string memory key, string[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n}\n"
    },
    "contracts/glv/Glv.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\nlibrary Glv {\n    struct Props {\n        address glvToken;\n        address longToken;\n        address shortToken;\n    }\n}\n"
    },
    "contracts/glv/GlvFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./GlvToken.sol\";\nimport \"./Glv.sol\";\nimport \"./GlvStoreUtils.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../utils/Cast.sol\";\n\n// @title GlvFactory\n// @dev Contract to create glv\ncontract GlvFactory is RoleModule {\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    DataStore public immutable dataStore;\n    EventEmitter public immutable eventEmitter;\n\n    constructor(RoleStore _roleStore, DataStore _dataStore, EventEmitter _eventEmitter) RoleModule(_roleStore) {\n        dataStore = _dataStore;\n        eventEmitter = _eventEmitter;\n    }\n\n    function createGlv(\n        address longToken,\n        address shortToken,\n        bytes32 glvType,\n        string memory name,\n        string memory symbol\n    ) external onlyMarketKeeper returns (Glv.Props memory) {\n        // not the same as length in characters\n        if (bytes(symbol).length > 30) {\n            revert Errors.GlvSymbolTooLong();\n        }\n        if (bytes(name).length > 100) {\n            revert Errors.GlvNameTooLong();\n        }\n\n        bytes32 salt = keccak256(abi.encode(\"GMX_GLV\", longToken, shortToken, glvType));\n\n        address existingGlvAddress = dataStore.getAddress(GlvStoreUtils.getGlvSaltHash(salt));\n        if (existingGlvAddress != address(0)) {\n            revert Errors.GlvAlreadyExists(glvType, existingGlvAddress);\n        }\n\n        GlvToken glvToken = new GlvToken{salt: salt}(roleStore, dataStore, name, symbol);\n\n        Glv.Props memory glv = Glv.Props({glvToken: address(glvToken), longToken: longToken, shortToken: shortToken});\n\n        GlvStoreUtils.set(dataStore, address(glvToken), salt, glv);\n\n        emitGlvCreated(address(glvToken), salt, longToken, shortToken, glvType);\n\n        return glv;\n    }\n\n    function emitGlvCreated(address glvAddress, bytes32 salt, address longToken, address shortToken, bytes32 glvType) internal {\n        EventUtils.EventLogData memory eventData;\n\n        eventData.addressItems.initItems(3);\n        eventData.addressItems.setItem(0, \"glvToken\", glvAddress);\n        eventData.addressItems.setItem(1, \"longToken\", longToken);\n        eventData.addressItems.setItem(2, \"shortToken\", shortToken);\n\n        eventData.bytes32Items.initItems(2);\n        eventData.bytes32Items.setItem(0, \"salt\", salt);\n        eventData.bytes32Items.setItem(1, \"glvType\", glvType);\n\n        eventEmitter.emitEventLog1(\"GlvCreated\", Cast.toBytes32(glvAddress), eventData);\n    }\n}\n"
    },
    "contracts/glv/GlvStoreUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/Keys.sol\";\nimport \"../data/DataStore.sol\";\n\nimport \"./Glv.sol\";\n\nlibrary GlvStoreUtils {\n    using Glv for Glv.Props;\n\n    bytes32 public constant GLV_SALT = keccak256(abi.encode(\"GLV_SALT\"));\n    bytes32 public constant GLV_TOKEN = keccak256(abi.encode(\"GLV_TOKEN\"));\n    bytes32 public constant LONG_TOKEN = keccak256(abi.encode(\"LONG_TOKEN\"));\n    bytes32 public constant SHORT_TOKEN = keccak256(abi.encode(\"SHORT_TOKEN\"));\n\n    function get(DataStore dataStore, address key) public view returns (Glv.Props memory) {\n        Glv.Props memory glv;\n        if (!dataStore.containsAddress(Keys.GLV_LIST, key)) {\n            return glv;\n        }\n\n        glv.glvToken = dataStore.getAddress(\n            keccak256(abi.encode(key, GLV_TOKEN))\n        );\n\n        glv.longToken = dataStore.getAddress(\n            keccak256(abi.encode(key, LONG_TOKEN))\n        );\n\n        glv.shortToken = dataStore.getAddress(\n            keccak256(abi.encode(key, SHORT_TOKEN))\n        );\n\n        return glv;\n    }\n\n    function getBySalt(DataStore dataStore, bytes32 salt) external view returns (Glv.Props memory) {\n        address key = dataStore.getAddress(getGlvSaltHash(salt));\n        return get(dataStore, key);\n    }\n\n    function set(DataStore dataStore, address key, bytes32 salt, Glv.Props memory glv) external {\n        dataStore.addAddress(\n            Keys.GLV_LIST,\n            key\n        );\n\n        // the salt is based on the glv props while the key gives the glv's address\n        // use the salt to store a reference to the key to allow the key to be retrieved\n        // using just the salt value\n        dataStore.setAddress(\n            getGlvSaltHash(salt),\n            key\n        );\n\n        dataStore.setAddress(\n            keccak256(abi.encode(key, GLV_TOKEN)),\n            glv.glvToken\n        );\n\n\n        dataStore.setAddress(\n            keccak256(abi.encode(key, LONG_TOKEN)),\n            glv.longToken\n        );\n\n        dataStore.setAddress(\n            keccak256(abi.encode(key, SHORT_TOKEN)),\n            glv.shortToken\n        );\n    }\n\n    function remove(DataStore dataStore, address key) external {\n        if (!dataStore.containsAddress(Keys.GLV_LIST, key)) {\n            revert Errors.GlvNotFound(key);\n        }\n\n        dataStore.removeAddress(\n            Keys.GLV_LIST,\n            key\n        );\n\n        dataStore.removeAddress(\n            keccak256(abi.encode(key, GLV_TOKEN))\n        );\n\n        dataStore.removeAddress(\n            keccak256(abi.encode(key, LONG_TOKEN))\n        );\n\n        dataStore.removeAddress(\n            keccak256(abi.encode(key, SHORT_TOKEN))\n        );\n    }\n\n    function getGlvSaltHash(bytes32 salt) internal pure returns (bytes32) {\n        return keccak256(abi.encode(GLV_SALT, salt));\n    }\n\n    function getGlvCount(DataStore dataStore) internal view returns (uint256) {\n        return dataStore.getAddressCount(Keys.GLV_LIST);\n    }\n\n    function getGlvKeys(DataStore dataStore, uint256 start, uint256 end) internal view returns (address[] memory) {\n        return dataStore.getAddressValuesAt(Keys.GLV_LIST, start, end);\n    }\n}\n"
    },
    "contracts/glv/GlvToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../bank/StrictBank.sol\";\n\ncontract GlvToken is ERC20, StrictBank {\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) StrictBank(_roleStore, _dataStore) {}\n\n    function mint(address account, uint256 amount) external onlyController {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) external onlyController {\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/role/Role.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n/**\n * @title Role\n * @dev Library for role keys\n */\nlibrary Role {\n    /**\n     * @dev The ROLE_ADMIN role.\n     * Hash: 0x56908b85b56869d7c69cd020749874f238259af9646ca930287866cdd660b7d9\n     */\n    bytes32 public constant ROLE_ADMIN = keccak256(abi.encode(\"ROLE_ADMIN\"));\n\n    /**\n     * @dev The TIMELOCK_ADMIN role.\n     * Hash: 0xf49b0c86b385620e25b0985905d1a112a5f1bc1d51a7a292a8cdf112b3a7c47c\n     */\n    bytes32 public constant TIMELOCK_ADMIN = keccak256(abi.encode(\"TIMELOCK_ADMIN\"));\n\n    /**\n     * @dev The TIMELOCK_MULTISIG role.\n     * Hash: 0xe068a8d811c3c8290a8be34607cfa3184b26ffb8dea4dde7a451adfba9fa173a\n     */\n    bytes32 public constant TIMELOCK_MULTISIG = keccak256(abi.encode(\"TIMELOCK_MULTISIG\"));\n\n    /**\n     * @dev The CONFIG_KEEPER role.\n     * Hash: 0x901fb3de937a1dcb6ecaf26886fda47a088e74f36232a0673eade97079dc225b\n     */\n    bytes32 public constant CONFIG_KEEPER = keccak256(abi.encode(\"CONFIG_KEEPER\"));\n\n    /**\n     * @dev The LIMITED_CONFIG_KEEPER role.\n     * Hash: 0xb49beded4d572a2d32002662fc5c735817329f4337b3a488aab0b5e835c01ba7\n     */\n    bytes32 public constant LIMITED_CONFIG_KEEPER = keccak256(abi.encode(\"LIMITED_CONFIG_KEEPER\"));\n\n    /**\n     * @dev The CONTROLLER role.\n     * Hash: 0x97adf037b2472f4a6a9825eff7d2dd45e37f2dc308df2a260d6a72af4189a65b\n     */\n    bytes32 public constant CONTROLLER = keccak256(abi.encode(\"CONTROLLER\"));\n\n    /**\n     * @dev The GOV_TOKEN_CONTROLLER role.\n     * Hash: 0x16a157db08319d4eaf6b157a71f5d2e18c6500cab8a25bee0b4f9c753cb13690\n     */\n    bytes32 public constant GOV_TOKEN_CONTROLLER = keccak256(abi.encode(\"GOV_TOKEN_CONTROLLER\"));\n\n    /**\n     * @dev The ROUTER_PLUGIN role.\n     * Hash: 0xc82e6cc76072f8edb32d42796e58e13ab6e145524eb6b36c073be82f20d410f3\n     */\n    bytes32 public constant ROUTER_PLUGIN = keccak256(abi.encode(\"ROUTER_PLUGIN\"));\n\n    /**\n     * @dev The MARKET_KEEPER role.\n     * Hash: 0xd66692c70b60cf1337e643d6a6473f6865d8c03f3c26b460df3d19b504fb46ae\n     */\n    bytes32 public constant MARKET_KEEPER = keccak256(abi.encode(\"MARKET_KEEPER\"));\n\n    /**\n     * @dev The FEE_KEEPER role.\n     * Hash: 0xe0ff4cc0c6ecffab6db3f63ea62dd53f8091919ac57669f1bb3d9828278081d8\n     */\n    bytes32 public constant FEE_KEEPER = keccak256(abi.encode(\"FEE_KEEPER\"));\n\n    /**\n     * @dev The FEE_DISTRIBUTION_KEEPER role.\n     * Hash: 0xc23a98a1bf683201c11eeeb8344052ad3bc603c8ddcad06093edc1e8dafa96a2\n     */\n    bytes32 public constant FEE_DISTRIBUTION_KEEPER = keccak256(abi.encode(\"FEE_DISTRIBUTION_KEEPER\"));\n\n    /**\n     * @dev The ORDER_KEEPER role.\n     * Hash: 0x40a07f8f0fc57fcf18b093d96362a8e661eaac7b7e6edbf66f242111f83a6794\n     */\n    bytes32 public constant ORDER_KEEPER = keccak256(abi.encode(\"ORDER_KEEPER\"));\n\n    /**\n     * @dev The FROZEN_ORDER_KEEPER role.\n     * Hash: 0xcb6c7bc0d25d73c91008af44527b80c56dee4db8965845d926a25659a4a8bc07\n     */\n    bytes32 public constant FROZEN_ORDER_KEEPER = keccak256(abi.encode(\"FROZEN_ORDER_KEEPER\"));\n\n    /**\n     * @dev The PRICING_KEEPER role.\n     * Hash: 0x2700e36dc4e6a0daa977bffd4368adbd48f8058da74152919f91f58eddb42103\n     */\n    bytes32 public constant PRICING_KEEPER = keccak256(abi.encode(\"PRICING_KEEPER\"));\n    /**\n     * @dev The LIQUIDATION_KEEPER role.\n     * Hash: 0x556c788ffc0574ec93966d808c170833d96489c9c58f5bcb3dadf711ba28720e\n     */\n    bytes32 public constant LIQUIDATION_KEEPER = keccak256(abi.encode(\"LIQUIDATION_KEEPER\"));\n    /**\n     * @dev The ADL_KEEPER role.\n     * Hash: 0xb37d64edaeaf5e634c13682dbd813f5a12fec9eb4f74433a089e7a3c3289af91\n     */\n    bytes32 public constant ADL_KEEPER = keccak256(abi.encode(\"ADL_KEEPER\"));\n}\n"
    },
    "contracts/role/RoleModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./RoleStore.sol\";\n\n/**\n * @title RoleModule\n * @dev Contract for role validation functions\n */\ncontract RoleModule {\n    RoleStore public immutable roleStore;\n\n    /**\n     * @dev Constructor that initializes the role store for this contract.\n     *\n     * @param _roleStore The contract instance to use as the role store.\n     */\n    constructor(RoleStore _roleStore) {\n        roleStore = _roleStore;\n    }\n\n    /**\n     * @dev Only allows the contract's own address to call the function.\n     */\n    modifier onlySelf() {\n        if (msg.sender != address(this)) {\n            revert Errors.Unauthorized(msg.sender, \"SELF\");\n        }\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the TIMELOCK_MULTISIG role to call the function.\n     */\n    modifier onlyTimelockMultisig() {\n        _validateRole(Role.TIMELOCK_MULTISIG, \"TIMELOCK_MULTISIG\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the TIMELOCK_ADMIN role to call the function.\n     */\n    modifier onlyTimelockAdmin() {\n        _validateRole(Role.TIMELOCK_ADMIN, \"TIMELOCK_ADMIN\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the CONFIG_KEEPER role to call the function.\n     */\n    modifier onlyConfigKeeper() {\n        _validateRole(Role.CONFIG_KEEPER, \"CONFIG_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the CONTROLLER role to call the function.\n     */\n    modifier onlyController() {\n        _validateRole(Role.CONTROLLER, \"CONTROLLER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the GOV_TOKEN_CONTROLLER role to call the function.\n     */\n    modifier onlyGovTokenController() {\n        _validateRole(Role.GOV_TOKEN_CONTROLLER, \"GOV_TOKEN_CONTROLLER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the ROUTER_PLUGIN role to call the function.\n     */\n    modifier onlyRouterPlugin() {\n        _validateRole(Role.ROUTER_PLUGIN, \"ROUTER_PLUGIN\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the MARKET_KEEPER role to call the function.\n     */\n    modifier onlyMarketKeeper() {\n        _validateRole(Role.MARKET_KEEPER, \"MARKET_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the FEE_KEEPER role to call the function.\n     */\n    modifier onlyFeeKeeper() {\n        _validateRole(Role.FEE_KEEPER, \"FEE_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the FEE_DISTRIBUTION_KEEPER role to call the function.\n     */\n    modifier onlyFeeDistributionKeeper() {\n        _validateRole(Role.FEE_DISTRIBUTION_KEEPER, \"FEE_DISTRIBUTION_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the ORDER_KEEPER role to call the function.\n     */\n    modifier onlyOrderKeeper() {\n        _validateRole(Role.ORDER_KEEPER, \"ORDER_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the PRICING_KEEPER role to call the function.\n     */\n    modifier onlyPricingKeeper() {\n        _validateRole(Role.PRICING_KEEPER, \"PRICING_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the LIQUIDATION_KEEPER role to call the function.\n     */\n    modifier onlyLiquidationKeeper() {\n        _validateRole(Role.LIQUIDATION_KEEPER, \"LIQUIDATION_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the ADL_KEEPER role to call the function.\n     */\n    modifier onlyAdlKeeper() {\n        _validateRole(Role.ADL_KEEPER, \"ADL_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Validates that the caller has the specified role.\n     *\n     * If the caller does not have the specified role, the transaction is reverted.\n     *\n     * @param role The key of the role to validate.\n     * @param roleName The name of the role to validate.\n     */\n    function _validateRole(bytes32 role, string memory roleName) internal view {\n        if (!roleStore.hasRole(msg.sender, role)) {\n            revert Errors.Unauthorized(msg.sender, roleName);\n        }\n    }\n}\n"
    },
    "contracts/role/RoleStore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../utils/EnumerableValues.sol\";\nimport \"./Role.sol\";\nimport \"../error/Errors.sol\";\n\n/**\n * @title RoleStore\n * @dev Stores roles and their members.\n */\ncontract RoleStore {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableValues for EnumerableSet.AddressSet;\n    using EnumerableValues for EnumerableSet.Bytes32Set;\n\n    EnumerableSet.Bytes32Set internal roles;\n    mapping(bytes32 => EnumerableSet.AddressSet) internal roleMembers;\n    // checking if an account has a role is a frequently used function\n    // roleCache helps to save gas by offering a more efficient lookup\n    // vs calling roleMembers[key].contains(account)\n    mapping(address => mapping (bytes32 => bool)) roleCache;\n\n    modifier onlyRoleAdmin() {\n        if (!hasRole(msg.sender, Role.ROLE_ADMIN)) {\n            revert Errors.Unauthorized(msg.sender, \"ROLE_ADMIN\");\n        }\n        _;\n    }\n\n    constructor() {\n        _grantRole(msg.sender, Role.ROLE_ADMIN);\n    }\n\n    /**\n     * @dev Grants the specified role to the given account.\n     *\n     * @param account The address of the account.\n     * @param roleKey The key of the role to grant.\n     */\n    function grantRole(address account, bytes32 roleKey) external onlyRoleAdmin {\n        _grantRole(account, roleKey);\n    }\n\n    /**\n     * @dev Revokes the specified role from the given account.\n     *\n     * @param account The address of the account.\n     * @param roleKey The key of the role to revoke.\n     */\n    function revokeRole(address account, bytes32 roleKey) external onlyRoleAdmin {\n        _revokeRole(account, roleKey);\n    }\n\n    /**\n     * @dev Returns true if the given account has the specified role.\n     *\n     * @param account The address of the account.\n     * @param roleKey The key of the role.\n     * @return True if the account has the role, false otherwise.\n     */\n    function hasRole(address account, bytes32 roleKey) public view returns (bool) {\n        return roleCache[account][roleKey];\n    }\n\n    /**\n     * @dev Returns the number of roles stored in the contract.\n     *\n     * @return The number of roles.\n     */\n    function getRoleCount() external view returns (uint256) {\n        return roles.length();\n    }\n\n    /**\n     * @dev Returns the keys of the roles stored in the contract.\n     *\n     * @param start The starting index of the range of roles to return.\n     * @param end The ending index of the range of roles to return.\n     * @return The keys of the roles.\n     */\n    function getRoles(uint256 start, uint256 end) external view returns (bytes32[] memory) {\n        return roles.valuesAt(start, end);\n    }\n\n    /**\n     * @dev Returns the number of members of the specified role.\n     *\n     * @param roleKey The key of the role.\n     * @return The number of members of the role.\n     */\n    function getRoleMemberCount(bytes32 roleKey) external view returns (uint256) {\n        return roleMembers[roleKey].length();\n    }\n\n    /**\n     * @dev Returns the members of the specified role.\n     *\n     * @param roleKey The key of the role.\n     * @param start the start index, the value for this index will be included.\n     * @param end the end index, the value for this index will not be included.\n     * @return The members of the role.\n     */\n    function getRoleMembers(bytes32 roleKey, uint256 start, uint256 end) external view returns (address[] memory) {\n        return roleMembers[roleKey].valuesAt(start, end);\n    }\n\n    function _grantRole(address account, bytes32 roleKey) internal {\n        roles.add(roleKey);\n        roleMembers[roleKey].add(account);\n        roleCache[account][roleKey] = true;\n    }\n\n    function _revokeRole(address account, bytes32 roleKey) internal {\n        roleMembers[roleKey].remove(account);\n        roleCache[account][roleKey] = false;\n\n        if (roleMembers[roleKey].length() == 0) {\n            if (roleKey == Role.ROLE_ADMIN) {\n                revert Errors.ThereMustBeAtLeastOneRoleAdmin();\n            }\n            if (roleKey == Role.TIMELOCK_MULTISIG) {\n                revert Errors.ThereMustBeAtLeastOneTimelockMultiSig();\n            }\n        }\n    }\n}\n"
    },
    "contracts/token/IWNT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n/**\n * @title IWNT\n * @dev Interface for Wrapped Native Tokens, e.g. WETH\n * The contract is named WNT instead of WETH for a more general reference name\n * that can be used on any blockchain\n */\ninterface IWNT {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/token/TokenUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\nimport \"../error/ErrorUtils.sol\";\nimport \"../utils/AccountUtils.sol\";\n\nimport \"./IWNT.sol\";\n\n/**\n * @title TokenUtils\n * @dev Library for token functions, helps with transferring of tokens and\n * native token functions\n */\nlibrary TokenUtils {\n    using Address for address;\n    using SafeERC20 for IERC20;\n\n    event TokenTransferReverted(string reason, bytes returndata);\n    event NativeTokenTransferReverted(string reason);\n\n    /**\n     * @dev Returns the address of the WNT token.\n     * @param dataStore DataStore contract instance where the address of the WNT token is stored.\n     * @return The address of the WNT token.\n     */\n    function wnt(DataStore dataStore) internal view returns (address) {\n        return dataStore.getAddress(Keys.WNT);\n    }\n\n    /**\n     * @dev Transfers the specified amount of `token` from the caller to `receiver`.\n     * limit the amount of gas forwarded so that a user cannot intentionally\n     * construct a token call that would consume all gas and prevent necessary\n     * actions like request cancellation from being executed\n     *\n     * @param dataStore The data store that contains the `tokenTransferGasLimit` for the specified `token`.\n     * @param token The address of the ERC20 token that is being transferred.\n     * @param receiver The address of the recipient of the `token` transfer.\n     * @param amount The amount of `token` to transfer.\n     */\n    function transfer(\n        DataStore dataStore,\n        address token,\n        address receiver,\n        uint256 amount\n    ) internal {\n        if (amount == 0) { return; }\n        AccountUtils.validateReceiver(receiver);\n\n        uint256 gasLimit = dataStore.getUint(Keys.tokenTransferGasLimit(token));\n        if (gasLimit == 0) {\n            revert Errors.EmptyTokenTranferGasLimit(token);\n        }\n\n        (bool success0, /* bytes memory returndata */) = nonRevertingTransferWithGasLimit(\n            IERC20(token),\n            receiver,\n            amount,\n            gasLimit\n        );\n\n        if (success0) { return; }\n\n        address holdingAddress = dataStore.getAddress(Keys.HOLDING_ADDRESS);\n\n        if (holdingAddress == address(0)) {\n            revert Errors.EmptyHoldingAddress();\n        }\n\n        // in case transfers to the receiver fail due to blacklisting or other reasons\n        // send the tokens to a holding address to avoid possible gaming through reverting\n        // transfers\n        (bool success1, bytes memory returndata) = nonRevertingTransferWithGasLimit(\n            IERC20(token),\n            holdingAddress,\n            amount,\n            gasLimit\n        );\n\n        if (success1) { return; }\n\n        (string memory reason, /* bool hasRevertMessage */) = ErrorUtils.getRevertMessage(returndata);\n        emit TokenTransferReverted(reason, returndata);\n\n        // throw custom errors to prevent spoofing of errors\n        // this is necessary because contracts like DepositHandler, WithdrawalHandler, OrderHandler\n        // do not cancel requests for specific errors\n        revert Errors.TokenTransferError(token, receiver, amount);\n    }\n\n    function sendNativeToken(\n        DataStore dataStore,\n        address receiver,\n        uint256 amount\n    ) internal {\n        if (amount == 0) { return; }\n\n        AccountUtils.validateReceiver(receiver);\n\n        uint256 gasLimit = dataStore.getUint(Keys.NATIVE_TOKEN_TRANSFER_GAS_LIMIT);\n\n        bool success;\n        // use an assembly call to avoid loading large data into memory\n        // input mem[in…(in+insize)]\n        // output area mem[out…(out+outsize))]\n        assembly {\n            success := call(\n                gasLimit, // gas limit\n                receiver, // receiver\n                amount, // value\n                0, // in\n                0, // insize\n                0, // out\n                0 // outsize\n            )\n        }\n\n        if (success) { return; }\n\n        // if the transfer failed, re-wrap the token and send it to the receiver\n        depositAndSendWrappedNativeToken(\n            dataStore,\n            receiver,\n            amount\n        );\n    }\n\n    /**\n     * Deposits the specified amount of native token and sends the specified\n     * amount of wrapped native token to the specified receiver address.\n     *\n     * @param dataStore the data store to use for storing and retrieving data\n     * @param receiver the address of the recipient of the wrapped native token transfer\n     * @param amount the amount of native token to deposit and the amount of wrapped native token to send\n     */\n    function depositAndSendWrappedNativeToken(\n        DataStore dataStore,\n        address receiver,\n        uint256 amount\n    ) internal {\n        if (amount == 0) { return; }\n        AccountUtils.validateReceiver(receiver);\n\n        address _wnt = wnt(dataStore);\n        IWNT(_wnt).deposit{value: amount}();\n\n        transfer(\n            dataStore,\n            _wnt,\n            receiver,\n            amount\n        );\n    }\n\n    /**\n     * @dev Withdraws the specified amount of wrapped native token and sends the\n     * corresponding amount of native token to the specified receiver address.\n     *\n     * limit the amount of gas forwarded so that a user cannot intentionally\n     * construct a token call that would consume all gas and prevent necessary\n     * actions like request cancellation from being executed\n     *\n     * @param dataStore the data store to use for storing and retrieving data\n     * @param _wnt the address of the WNT contract to withdraw the wrapped native token from\n     * @param receiver the address of the recipient of the native token transfer\n     * @param amount the amount of wrapped native token to withdraw and the amount of native token to send\n     */\n    function withdrawAndSendNativeToken(\n        DataStore dataStore,\n        address _wnt,\n        address receiver,\n        uint256 amount\n    ) internal {\n        if (amount == 0) { return; }\n        AccountUtils.validateReceiver(receiver);\n\n        IWNT(_wnt).withdraw(amount);\n\n        uint256 gasLimit = dataStore.getUint(Keys.NATIVE_TOKEN_TRANSFER_GAS_LIMIT);\n\n        bool success;\n        // use an assembly call to avoid loading large data into memory\n        // input mem[in…(in+insize)]\n        // output area mem[out…(out+outsize))]\n        assembly {\n            success := call(\n                gasLimit, // gas limit\n                receiver, // receiver\n                amount, // value\n                0, // in\n                0, // insize\n                0, // out\n                0 // outsize\n            )\n        }\n\n        if (success) { return; }\n\n        // if the transfer failed, re-wrap the token and send it to the receiver\n        depositAndSendWrappedNativeToken(\n            dataStore,\n            receiver,\n            amount\n        );\n    }\n\n    /**\n     * @dev Transfers the specified amount of ERC20 token to the specified receiver\n     * address, with a gas limit to prevent the transfer from consuming all available gas.\n     * adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol\n     *\n     * @param token the ERC20 contract to transfer the tokens from\n     * @param to the address of the recipient of the token transfer\n     * @param amount the amount of tokens to transfer\n     * @param gasLimit the maximum amount of gas that the token transfer can consume\n     * @return a tuple containing a boolean indicating the success or failure of the\n     * token transfer, and a bytes value containing the return data from the token transfer\n     */\n    function nonRevertingTransferWithGasLimit(\n        IERC20 token,\n        address to,\n        uint256 amount,\n        uint256 gasLimit\n    ) internal returns (bool, bytes memory) {\n        bytes memory data = abi.encodeWithSelector(token.transfer.selector, to, amount);\n        (bool success, bytes memory returndata) = address(token).call{ gas: gasLimit }(data);\n\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                if (!address(token).isContract()) {\n                    return (false, \"Call to non-contract\");\n                }\n            }\n\n            // some tokens do not revert on a failed transfer, they will return a boolean instead\n            // validate that the returned boolean is true, otherwise indicate that the token transfer failed\n            if (returndata.length > 0 && !abi.decode(returndata, (bool))) {\n                return (false, returndata);\n            }\n\n            // transfers on some tokens do not return a boolean value, they will just revert if a transfer fails\n            // for these tokens, if success is true then the transfer should have completed\n            return (true, returndata);\n        }\n\n        return (false, returndata);\n    }\n}\n"
    },
    "contracts/utils/AccountUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../error/Errors.sol\";\n\nlibrary AccountUtils {\n    function validateAccount(address account) internal pure {\n        if (account == address(0)) {\n            revert Errors.EmptyAccount();\n        }\n    }\n\n    function validateReceiver(address receiver) internal pure {\n        if (receiver == address(0)) {\n            revert Errors.EmptyReceiver();\n        }\n    }\n}\n"
    },
    "contracts/utils/Calc.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @title Calc\n * @dev Library for math functions\n */\nlibrary Calc {\n    using SignedMath for int256;\n    using SafeCast for uint256;\n\n    // this method assumes that min is less than max\n    function boundMagnitude(int256 value, uint256 min, uint256 max) internal pure returns (int256) {\n        uint256 magnitude = value.abs();\n\n        if (magnitude < min) {\n            magnitude = min;\n        }\n\n        if (magnitude > max) {\n            magnitude = max;\n        }\n\n        int256 sign = value == 0 ? int256(1) : value / value.abs().toInt256();\n\n        return magnitude.toInt256() * sign;\n    }\n\n    /**\n     * @dev Calculates the result of dividing the first number by the second number,\n     * rounded up to the nearest integer.\n     *\n     * @param a the dividend\n     * @param b the divisor\n     * @return the result of dividing the first number by the second number, rounded up to the nearest integer\n     */\n    function roundUpDivision(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    /**\n     * Calculates the result of dividing the first number by the second number,\n     * rounded up to the nearest integer.\n     * The rounding is purely on the magnitude of a, if a is negative the result\n     * is a larger magnitude negative\n     *\n     * @param a the dividend\n     * @param b the divisor\n     * @return the result of dividing the first number by the second number, rounded up to the nearest integer\n     */\n    function roundUpMagnitudeDivision(int256 a, uint256 b) internal pure returns (int256) {\n        if (a < 0) {\n            return (a - b.toInt256() + 1) / b.toInt256();\n        }\n\n        return (a + b.toInt256() - 1) / b.toInt256();\n    }\n\n    /**\n     * Adds two numbers together and return a uint256 value, treating the second number as a signed integer.\n     *\n     * @param a the first number\n     * @param b the second number\n     * @return the result of adding the two numbers together\n     */\n    function sumReturnUint256(uint256 a, int256 b) internal pure returns (uint256) {\n        if (b > 0) {\n            return a + b.abs();\n        }\n\n        return a - b.abs();\n    }\n\n    /**\n     * Adds two numbers together and return an int256 value, treating the second number as a signed integer.\n     *\n     * @param a the first number\n     * @param b the second number\n     * @return the result of adding the two numbers together\n     */\n    function sumReturnInt256(uint256 a, int256 b) internal pure returns (int256) {\n        return a.toInt256() + b;\n    }\n\n    /**\n     * @dev Calculates the absolute difference between two numbers.\n     *\n     * @param a the first number\n     * @param b the second number\n     * @return the absolute difference between the two numbers\n     */\n    function diff(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    /**\n     * Adds two numbers together, the result is bounded to prevent overflows.\n     *\n     * @param a the first number\n     * @param b the second number\n     * @return the result of adding the two numbers together\n     */\n    function boundedAdd(int256 a, int256 b) internal pure returns (int256) {\n        // if either a or b is zero or if the signs are different there should not be any overflows\n        if (a == 0 || b == 0 || (a < 0 && b > 0) || (a > 0 && b < 0)) {\n            return a + b;\n        }\n\n        // if adding `b` to `a` would result in a value less than the min int256 value\n        // then return the min int256 value\n        if (a < 0 && b <= type(int256).min - a) {\n            return type(int256).min;\n        }\n\n        // if adding `b` to `a` would result in a value more than the max int256 value\n        // then return the max int256 value\n        if (a > 0 && b >= type(int256).max - a) {\n            return type(int256).max;\n        }\n\n        return a + b;\n    }\n\n    /**\n     * Returns a - b, the result is bounded to prevent overflows.\n     * Note that this will revert if b is type(int256).min because of the usage of \"-b\".\n     *\n     * @param a the first number\n     * @param b the second number\n     * @return the bounded result of a - b\n     */\n    function boundedSub(int256 a, int256 b) internal pure returns (int256) {\n        // if either a or b is zero or the signs are the same there should not be any overflow\n        if (a == 0 || b == 0 || (a > 0 && b > 0) || (a < 0 && b < 0)) {\n            return a - b;\n        }\n\n        // if adding `-b` to `a` would result in a value greater than the max int256 value\n        // then return the max int256 value\n        if (a > 0 && -b >= type(int256).max - a) {\n            return type(int256).max;\n        }\n\n        // if subtracting `b` from `a` would result in a value less than the min int256 value\n        // then return the min int256 value\n        if (a < 0 && -b <= type(int256).min - a) {\n            return type(int256).min;\n        }\n\n        return a - b;\n    }\n\n\n    /**\n     * Converts the given unsigned integer to a signed integer, using the given\n     * flag to determine whether the result should be positive or negative.\n     *\n     * @param a the unsigned integer to convert\n     * @param isPositive whether the result should be positive (if true) or negative (if false)\n     * @return the signed integer representation of the given unsigned integer\n     */\n    function toSigned(uint256 a, bool isPositive) internal pure returns (int256) {\n        if (isPositive) {\n            return a.toInt256();\n        } else {\n            return -a.toInt256();\n        }\n    }\n}\n"
    },
    "contracts/utils/Cast.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n/**\n * @title Cast\n * @dev Library for casting functions\n */\nlibrary Cast {\n    function toBytes32(address value) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(value)));\n    }\n}\n"
    },
    "contracts/utils/EnumerableValues.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/**\n * @title EnumerableValues\n * @dev Library to extend the EnumerableSet library with functions to get\n * valuesAt for a range\n */\nlibrary EnumerableValues {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * Returns an array of bytes32 values from the given set, starting at the given\n     * start index and ending before the given end index.\n     *\n     * @param set The set to get the values from.\n     * @param start The starting index.\n     * @param end The ending index.\n     * @return An array of bytes32 values.\n     */\n    function valuesAt(EnumerableSet.Bytes32Set storage set, uint256 start, uint256 end) internal view returns (bytes32[] memory) {\n        uint256 max = set.length();\n        if (end > max) { end = max; }\n\n        bytes32[] memory items = new bytes32[](end - start);\n        for (uint256 i = start; i < end; i++) {\n            items[i - start] = set.at(i);\n        }\n\n        return items;\n    }\n\n\n    /**\n     * Returns an array of address values from the given set, starting at the given\n     * start index and ending before the given end index.\n     *\n     * @param set The set to get the values from.\n     * @param start The starting index.\n     * @param end The ending index.\n     * @return An array of address values.\n     */\n    function valuesAt(EnumerableSet.AddressSet storage set, uint256 start, uint256 end) internal view returns (address[] memory) {\n        uint256 max = set.length();\n        if (end > max) { end = max; }\n\n        address[] memory items = new address[](end - start);\n        for (uint256 i = start; i < end; i++) {\n            items[i - start] = set.at(i);\n        }\n\n        return items;\n    }\n\n\n    /**\n     * Returns an array of uint256 values from the given set, starting at the given\n     * start index and ending before the given end index, the item at the end index will not be returned.\n     *\n     * @param set The set to get the values from.\n     * @param start The starting index (inclusive, item at the start index will be returned).\n     * @param end The ending index (exclusive, item at the end index will not be returned).\n     * @return An array of uint256 values.\n     */\n    function valuesAt(EnumerableSet.UintSet storage set, uint256 start, uint256 end) internal view returns (uint256[] memory) {\n        if (start >= set.length()) {\n            return new uint256[](0);\n        }\n\n        uint256 max = set.length();\n        if (end > max) { end = max; }\n\n        uint256[] memory items = new uint256[](end - start);\n        for (uint256 i = start; i < end; i++) {\n            items[i - start] = set.at(i);\n        }\n\n        return items;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10,
      "details": {
        "constantOptimizer": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}