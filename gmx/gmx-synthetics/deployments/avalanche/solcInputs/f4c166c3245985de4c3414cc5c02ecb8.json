{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/chain/ArbSys.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n// @title ArbSys\n// @dev Globally available variables for Arbitrum may have both an L1 and an L2\n// value, the ArbSys interface is used to retrieve the L2 value\ninterface ArbSys {\n    function arbBlockNumber() external view returns (uint256);\n    function arbBlockHash(uint256 blockNumber) external view returns (bytes32);\n}\n"
    },
    "contracts/chain/Chain.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./ArbSys.sol\";\n\n// @title Chain\n// @dev Wrap the calls to retrieve chain variables to handle differences\n// between chain implementations\nlibrary Chain {\n    // if the ARBITRUM_CHAIN_ID changes, a new version of this library\n    // and contracts depending on it would need to be deployed\n    uint256 public constant ARBITRUM_CHAIN_ID = 42161;\n    uint256 public constant ARBITRUM_SEPOLIA_CHAIN_ID = 421614;\n\n    ArbSys public constant arbSys = ArbSys(address(100));\n\n    // @dev return the current block's timestamp\n    // @return the current block's timestamp\n    function currentTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    // @dev return the current block's number\n    // @return the current block's number\n    function currentBlockNumber() internal view returns (uint256) {\n        if (shouldUseArbSysValues()) {\n            return arbSys.arbBlockNumber();\n        }\n\n        return block.number;\n    }\n\n    // @dev return the current block's hash\n    // @return the current block's hash\n    function getBlockHash(uint256 blockNumber) internal view returns (bytes32) {\n        if (shouldUseArbSysValues()) {\n            return arbSys.arbBlockHash(blockNumber);\n        }\n\n        return blockhash(blockNumber);\n    }\n\n    function shouldUseArbSysValues() internal view returns (bool) {\n        return block.chainid == ARBITRUM_CHAIN_ID || block.chainid == ARBITRUM_SEPOLIA_CHAIN_ID;\n    }\n}\n"
    },
    "contracts/config/AutoCancelConfig.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../data/DataStore.sol\";\nimport \"../data/Keys.sol\";\nimport \"../role/RoleModule.sol\";\nimport \"../event/EventEmitter.sol\";\nimport \"../utils/BasicMulticall.sol\";\nimport \"../order/OrderStoreUtils.sol\";\nimport \"../position/PositionStoreUtils.sol\";\nimport \"../order/AutoCancelUtils.sol\";\nimport \"../utils/Cast.sol\";\n\ncontract AutoCancelSyncer is ReentrancyGuard, RoleModule, BasicMulticall {\n    using EventUtils for EventUtils.AddressItems;\n    using EventUtils for EventUtils.UintItems;\n    using EventUtils for EventUtils.IntItems;\n    using EventUtils for EventUtils.BoolItems;\n    using EventUtils for EventUtils.Bytes32Items;\n    using EventUtils for EventUtils.BytesItems;\n    using EventUtils for EventUtils.StringItems;\n\n    using Order for Order.Props;\n\n    DataStore public immutable dataStore;\n    EventEmitter public immutable eventEmitter;\n\n    constructor(\n        RoleStore _roleStore,\n        DataStore _dataStore,\n        EventEmitter _eventEmitter\n    ) RoleModule(_roleStore) {\n        dataStore = _dataStore;\n        eventEmitter = _eventEmitter;\n    }\n\n    function syncAutoCancelOrderListForAccount(address account, uint256 start, uint256 end) external onlyConfigKeeper nonReentrant {\n        bytes32[] memory positionKeys = PositionStoreUtils.getAccountPositionKeys(dataStore, account, start, end);\n\n        for (uint256 i; i < positionKeys.length; i++) {\n            _syncAutoCancelOrderListForPosition(account, positionKeys[i]);\n        }\n    }\n\n    function syncAutoCancelOrderListForPosition(address account, bytes32 positionKey) external onlyConfigKeeper nonReentrant {\n        _syncAutoCancelOrderListForPosition(account, positionKey);\n    }\n\n    function _syncAutoCancelOrderListForPosition(address account, bytes32 positionKey) internal {\n        bytes32[] memory orderKeys = AutoCancelUtils.getAutoCancelOrderKeys(dataStore, positionKey);\n\n        for (uint256 j; j < orderKeys.length; j++) {\n            bytes32 orderKey = orderKeys[j];\n            Order.Props memory order = OrderStoreUtils.get(dataStore, orderKey);\n\n            if (order.account() == address(0) || (order.sizeDeltaUsd() == 0 && order.initialCollateralDeltaAmount() == 0)) {\n                AutoCancelUtils.removeAutoCancelOrderKey(dataStore, positionKey, orderKey);\n\n                EventUtils.EventLogData memory eventData;\n                eventData.addressItems.initItems(1);\n                eventData.addressItems.setItem(0, \"account\", account);\n                eventData.bytes32Items.initItems(2);\n                eventData.bytes32Items.setItem(0, \"positionKey\", positionKey);\n                eventData.bytes32Items.setItem(1, \"orderKey\", orderKey);\n                eventEmitter.emitEventLog1(\n                    \"ConfigSyncAutoCancelOrderList\",\n                    Cast.toBytes32(account),\n                    eventData\n                );\n            }\n        }\n    }\n}\n"
    },
    "contracts/data/DataStore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../role/RoleModule.sol\";\nimport \"../utils/Calc.sol\";\n\n// @title DataStore\n// @dev DataStore for all general state values\ncontract DataStore is RoleModule {\n    using SafeCast for int256;\n\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableValues for EnumerableSet.Bytes32Set;\n    using EnumerableValues for EnumerableSet.AddressSet;\n    using EnumerableValues for EnumerableSet.UintSet;\n\n    // store for uint values\n    mapping(bytes32 => uint256) public uintValues;\n    // store for int values\n    mapping(bytes32 => int256) public intValues;\n    // store for address values\n    mapping(bytes32 => address) public addressValues;\n    // store for bool values\n    mapping(bytes32 => bool) public boolValues;\n    // store for string values\n    mapping(bytes32 => string) public stringValues;\n    // store for bytes32 values\n    mapping(bytes32 => bytes32) public bytes32Values;\n\n    // store for uint[] values\n    mapping(bytes32 => uint256[]) public uintArrayValues;\n    // store for int[] values\n    mapping(bytes32 => int256[]) public intArrayValues;\n    // store for address[] values\n    mapping(bytes32 => address[]) public addressArrayValues;\n    // store for bool[] values\n    mapping(bytes32 => bool[]) public boolArrayValues;\n    // store for string[] values\n    mapping(bytes32 => string[]) public stringArrayValues;\n    // store for bytes32[] values\n    mapping(bytes32 => bytes32[]) public bytes32ArrayValues;\n\n    // store for bytes32 sets\n    mapping(bytes32 => EnumerableSet.Bytes32Set) internal bytes32Sets;\n    // store for address sets\n    mapping(bytes32 => EnumerableSet.AddressSet) internal addressSets;\n    // store for uint256 sets\n    mapping(bytes32 => EnumerableSet.UintSet) internal uintSets;\n\n    constructor(RoleStore _roleStore) RoleModule(_roleStore) {}\n\n    // @dev get the uint value for the given key\n    // @param key the key of the value\n    // @return the uint value for the key\n    function getUint(bytes32 key) external view returns (uint256) {\n        return uintValues[key];\n    }\n\n    // @dev set the uint value for the given key\n    // @param key the key of the value\n    // @param value the value to set\n    // @return the uint value for the key\n    function setUint(bytes32 key, uint256 value) external onlyController returns (uint256) {\n        uintValues[key] = value;\n        return value;\n    }\n\n    // @dev delete the uint value for the given key\n    // @param key the key of the value\n    function removeUint(bytes32 key) external onlyController {\n        delete uintValues[key];\n    }\n\n    // @dev add the input int value to the existing uint value\n    // @param key the key of the value\n    // @param value the input int value\n    // @return the new uint value\n    function applyDeltaToUint(bytes32 key, int256 value, string memory errorMessage) external onlyController returns (uint256) {\n        uint256 currValue = uintValues[key];\n        if (value < 0 && (-value).toUint256() > currValue) {\n            revert(errorMessage);\n        }\n        uint256 nextUint = Calc.sumReturnUint256(currValue, value);\n        uintValues[key] = nextUint;\n        return nextUint;\n    }\n\n    // @dev add the input uint value to the existing uint value\n    // @param key the key of the value\n    // @param value the input int value\n    // @return the new uint value\n    function applyDeltaToUint(bytes32 key, uint256 value) external onlyController returns (uint256) {\n        uint256 currValue = uintValues[key];\n        uint256 nextUint = currValue + value;\n        uintValues[key] = nextUint;\n        return nextUint;\n    }\n\n    // @dev add the input int value to the existing uint value, prevent the uint\n    // value from becoming negative\n    // @param key the key of the value\n    // @param value the input int value\n    // @return the new uint value\n    function applyBoundedDeltaToUint(bytes32 key, int256 value) external onlyController returns (uint256) {\n        uint256 uintValue = uintValues[key];\n        if (value < 0 && (-value).toUint256() > uintValue) {\n            uintValues[key] = 0;\n            return 0;\n        }\n\n        uint256 nextUint = Calc.sumReturnUint256(uintValue, value);\n        uintValues[key] = nextUint;\n        return nextUint;\n    }\n\n    // @dev add the input uint value to the existing uint value\n    // @param key the key of the value\n    // @param value the input uint value\n    // @return the new uint value\n    function incrementUint(bytes32 key, uint256 value) external onlyController returns (uint256) {\n        uint256 nextUint = uintValues[key] + value;\n        uintValues[key] = nextUint;\n        return nextUint;\n    }\n\n    // @dev subtract the input uint value from the existing uint value\n    // @param key the key of the value\n    // @param value the input uint value\n    // @return the new uint value\n    function decrementUint(bytes32 key, uint256 value) external onlyController returns (uint256) {\n        uint256 nextUint = uintValues[key] - value;\n        uintValues[key] = nextUint;\n        return nextUint;\n    }\n\n    // @dev get the int value for the given key\n    // @param key the key of the value\n    // @return the int value for the key\n    function getInt(bytes32 key) external view returns (int256) {\n        return intValues[key];\n    }\n\n    // @dev set the int value for the given key\n    // @param key the key of the value\n    // @param value the value to set\n    // @return the int value for the key\n    function setInt(bytes32 key, int256 value) external onlyController returns (int256) {\n        intValues[key] = value;\n        return value;\n    }\n\n    function removeInt(bytes32 key) external onlyController {\n        delete intValues[key];\n    }\n\n    // @dev add the input int value to the existing int value\n    // @param key the key of the value\n    // @param value the input int value\n    // @return the new int value\n    function applyDeltaToInt(bytes32 key, int256 value) external onlyController returns (int256) {\n        int256 nextInt = intValues[key] + value;\n        intValues[key] = nextInt;\n        return nextInt;\n    }\n\n    // @dev add the input int value to the existing int value\n    // @param key the key of the value\n    // @param value the input int value\n    // @return the new int value\n    function incrementInt(bytes32 key, int256 value) external onlyController returns (int256) {\n        int256 nextInt = intValues[key] + value;\n        intValues[key] = nextInt;\n        return nextInt;\n    }\n\n    // @dev subtract the input int value from the existing int value\n    // @param key the key of the value\n    // @param value the input int value\n    // @return the new int value\n    function decrementInt(bytes32 key, int256 value) external onlyController returns (int256) {\n        int256 nextInt = intValues[key] - value;\n        intValues[key] = nextInt;\n        return nextInt;\n    }\n\n    // @dev get the address value for the given key\n    // @param key the key of the value\n    // @return the address value for the key\n    function getAddress(bytes32 key) external view returns (address) {\n        return addressValues[key];\n    }\n\n    // @dev set the address value for the given key\n    // @param key the key of the value\n    // @param value the value to set\n    // @return the address value for the key\n    function setAddress(bytes32 key, address value) external onlyController returns (address) {\n        addressValues[key] = value;\n        return value;\n    }\n\n    // @dev delete the address value for the given key\n    // @param key the key of the value\n    function removeAddress(bytes32 key) external onlyController {\n        delete addressValues[key];\n    }\n\n    // @dev get the bool value for the given key\n    // @param key the key of the value\n    // @return the bool value for the key\n    function getBool(bytes32 key) external view returns (bool) {\n        return boolValues[key];\n    }\n\n    // @dev set the bool value for the given key\n    // @param key the key of the value\n    // @param value the value to set\n    // @return the bool value for the key\n    function setBool(bytes32 key, bool value) external onlyController returns (bool) {\n        boolValues[key] = value;\n        return value;\n    }\n\n    // @dev delete the bool value for the given key\n    // @param key the key of the value\n    function removeBool(bytes32 key) external onlyController {\n        delete boolValues[key];\n    }\n\n    // @dev get the string value for the given key\n    // @param key the key of the value\n    // @return the string value for the key\n    function getString(bytes32 key) external view returns (string memory) {\n        return stringValues[key];\n    }\n\n    // @dev set the string value for the given key\n    // @param key the key of the value\n    // @param value the value to set\n    // @return the string value for the key\n    function setString(bytes32 key, string memory value) external onlyController returns (string memory) {\n        stringValues[key] = value;\n        return value;\n    }\n\n    // @dev delete the string value for the given key\n    // @param key the key of the value\n    function removeString(bytes32 key) external onlyController {\n        delete stringValues[key];\n    }\n\n    // @dev get the bytes32 value for the given key\n    // @param key the key of the value\n    // @return the bytes32 value for the key\n    function getBytes32(bytes32 key) external view returns (bytes32) {\n        return bytes32Values[key];\n    }\n\n    // @dev set the bytes32 value for the given key\n    // @param key the key of the value\n    // @param value the value to set\n    // @return the bytes32 value for the key\n    function setBytes32(bytes32 key, bytes32 value) external onlyController returns (bytes32) {\n        bytes32Values[key] = value;\n        return value;\n    }\n\n    // @dev delete the bytes32 value for the given key\n    // @param key the key of the value\n    function removeBytes32(bytes32 key) external onlyController {\n        delete bytes32Values[key];\n    }\n\n    // @dev get the uint array for the given key\n    // @param key the key of the uint array\n    // @return the uint array for the key\n    function getUintArray(bytes32 key) external view returns (uint256[] memory) {\n        return uintArrayValues[key];\n    }\n\n    // @dev set the uint array for the given key\n    // @param key the key of the uint array\n    // @param value the value of the uint array\n    function setUintArray(bytes32 key, uint256[] memory value) external onlyController {\n        uintArrayValues[key] = value;\n    }\n\n    // @dev delete the uint array for the given key\n    // @param key the key of the uint array\n    // @param value the value of the uint array\n    function removeUintArray(bytes32 key) external onlyController {\n        delete uintArrayValues[key];\n    }\n\n    // @dev get the int array for the given key\n    // @param key the key of the int array\n    // @return the int array for the key\n    function getIntArray(bytes32 key) external view returns (int256[] memory) {\n        return intArrayValues[key];\n    }\n\n    // @dev set the int array for the given key\n    // @param key the key of the int array\n    // @param value the value of the int array\n    function setIntArray(bytes32 key, int256[] memory value) external onlyController {\n        intArrayValues[key] = value;\n    }\n\n    // @dev delete the int array for the given key\n    // @param key the key of the int array\n    // @param value the value of the int array\n    function removeIntArray(bytes32 key) external onlyController {\n        delete intArrayValues[key];\n    }\n\n    // @dev get the address array for the given key\n    // @param key the key of the address array\n    // @return the address array for the key\n    function getAddressArray(bytes32 key) external view returns (address[] memory) {\n        return addressArrayValues[key];\n    }\n\n    // @dev set the address array for the given key\n    // @param key the key of the address array\n    // @param value the value of the address array\n    function setAddressArray(bytes32 key, address[] memory value) external onlyController {\n        addressArrayValues[key] = value;\n    }\n\n    // @dev delete the address array for the given key\n    // @param key the key of the address array\n    // @param value the value of the address array\n    function removeAddressArray(bytes32 key) external onlyController {\n        delete addressArrayValues[key];\n    }\n\n    // @dev get the bool array for the given key\n    // @param key the key of the bool array\n    // @return the bool array for the key\n    function getBoolArray(bytes32 key) external view returns (bool[] memory) {\n        return boolArrayValues[key];\n    }\n\n    // @dev set the bool array for the given key\n    // @param key the key of the bool array\n    // @param value the value of the bool array\n    function setBoolArray(bytes32 key, bool[] memory value) external onlyController {\n        boolArrayValues[key] = value;\n    }\n\n    // @dev delete the bool array for the given key\n    // @param key the key of the bool array\n    // @param value the value of the bool array\n    function removeBoolArray(bytes32 key) external onlyController {\n        delete boolArrayValues[key];\n    }\n\n    // @dev get the string array for the given key\n    // @param key the key of the string array\n    // @return the string array for the key\n    function getStringArray(bytes32 key) external view returns (string[] memory) {\n        return stringArrayValues[key];\n    }\n\n    // @dev set the string array for the given key\n    // @param key the key of the string array\n    // @param value the value of the string array\n    function setStringArray(bytes32 key, string[] memory value) external onlyController {\n        stringArrayValues[key] = value;\n    }\n\n    // @dev delete the string array for the given key\n    // @param key the key of the string array\n    // @param value the value of the string array\n    function removeStringArray(bytes32 key) external onlyController {\n        delete stringArrayValues[key];\n    }\n\n    // @dev get the bytes32 array for the given key\n    // @param key the key of the bytes32 array\n    // @return the bytes32 array for the key\n    function getBytes32Array(bytes32 key) external view returns (bytes32[] memory) {\n        return bytes32ArrayValues[key];\n    }\n\n    // @dev set the bytes32 array for the given key\n    // @param key the key of the bytes32 array\n    // @param value the value of the bytes32 array\n    function setBytes32Array(bytes32 key, bytes32[] memory value) external onlyController {\n        bytes32ArrayValues[key] = value;\n    }\n\n    // @dev delete the bytes32 array for the given key\n    // @param key the key of the bytes32 array\n    // @param value the value of the bytes32 array\n    function removeBytes32Array(bytes32 key) external onlyController {\n        delete bytes32ArrayValues[key];\n    }\n\n    // @dev check whether the given value exists in the set\n    // @param setKey the key of the set\n    // @param value the value to check\n    function containsBytes32(bytes32 setKey, bytes32 value) external view returns (bool) {\n        return bytes32Sets[setKey].contains(value);\n    }\n\n    // @dev get the length of the set\n    // @param setKey the key of the set\n    function getBytes32Count(bytes32 setKey) external view returns (uint256) {\n        return bytes32Sets[setKey].length();\n    }\n\n    // @dev get the values of the set in the given range\n    // @param setKey the key of the set\n    // @param the start of the range, values at the start index will be returned\n    // in the result\n    // @param the end of the range, values at the end index will not be returned\n    // in the result\n    function getBytes32ValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (bytes32[] memory) {\n        return bytes32Sets[setKey].valuesAt(start, end);\n    }\n\n    // @dev add the given value to the set\n    // @param setKey the key of the set\n    // @param value the value to add\n    function addBytes32(bytes32 setKey, bytes32 value) external onlyController {\n        bytes32Sets[setKey].add(value);\n    }\n\n    // @dev remove the given value from the set\n    // @param setKey the key of the set\n    // @param value the value to remove\n    function removeBytes32(bytes32 setKey, bytes32 value) external onlyController {\n        bytes32Sets[setKey].remove(value);\n    }\n\n    // @dev check whether the given value exists in the set\n    // @param setKey the key of the set\n    // @param value the value to check\n    function containsAddress(bytes32 setKey, address value) external view returns (bool) {\n        return addressSets[setKey].contains(value);\n    }\n\n    // @dev get the length of the set\n    // @param setKey the key of the set\n    function getAddressCount(bytes32 setKey) external view returns (uint256) {\n        return addressSets[setKey].length();\n    }\n\n    // @dev get the values of the set in the given range\n    // @param setKey the key of the set\n    // @param the start of the range, values at the start index will be returned\n    // in the result\n    // @param the end of the range, values at the end index will not be returned\n    // in the result\n    function getAddressValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (address[] memory) {\n        return addressSets[setKey].valuesAt(start, end);\n    }\n\n    // @dev add the given value to the set\n    // @param setKey the key of the set\n    // @param value the value to add\n    function addAddress(bytes32 setKey, address value) external onlyController {\n        addressSets[setKey].add(value);\n    }\n\n    // @dev remove the given value from the set\n    // @param setKey the key of the set\n    // @param value the value to remove\n    function removeAddress(bytes32 setKey, address value) external onlyController {\n        addressSets[setKey].remove(value);\n    }\n\n    // @dev check whether the given value exists in the set\n    // @param setKey the key of the set\n    // @param value the value to check\n    function containsUint(bytes32 setKey, uint256 value) external view returns (bool) {\n        return uintSets[setKey].contains(value);\n    }\n\n    // @dev get the length of the set\n    // @param setKey the key of the set\n    function getUintCount(bytes32 setKey) external view returns (uint256) {\n        return uintSets[setKey].length();\n    }\n\n    // @dev get the values of the set in the given range\n    // @param setKey the key of the set\n    // @param the start of the range, values at the start index will be returned\n    // in the result\n    // @param the end of the range, values at the end index will not be returned\n    // in the result\n    function getUintValuesAt(bytes32 setKey, uint256 start, uint256 end) external view returns (uint256[] memory) {\n        return uintSets[setKey].valuesAt(start, end);\n    }\n\n    // @dev add the given value to the set\n    // @param setKey the key of the set\n    // @param value the value to add\n    function addUint(bytes32 setKey, uint256 value) external onlyController {\n        uintSets[setKey].add(value);\n    }\n\n    // @dev remove the given value from the set\n    // @param setKey the key of the set\n    // @param value the value to remove\n    function removeUint(bytes32 setKey, uint256 value) external onlyController {\n        uintSets[setKey].remove(value);\n    }\n}\n"
    },
    "contracts/data/Keys.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n// @title Keys\n// @dev Keys for values in the DataStore\nlibrary Keys {\n    // @dev key for the address of the wrapped native token\n    bytes32 public constant WNT = keccak256(abi.encode(\"WNT\"));\n    // @dev key for the nonce value used in NonceUtils\n    bytes32 public constant NONCE = keccak256(abi.encode(\"NONCE\"));\n\n    // @dev for sending received fees\n    bytes32 public constant FEE_RECEIVER = keccak256(abi.encode(\"FEE_RECEIVER\"));\n\n    // @dev for holding tokens that could not be sent out\n    bytes32 public constant HOLDING_ADDRESS = keccak256(abi.encode(\"HOLDING_ADDRESS\"));\n\n    // @dev key for the minimum gas for execution error\n    bytes32 public constant MIN_HANDLE_EXECUTION_ERROR_GAS = keccak256(abi.encode(\"MIN_HANDLE_EXECUTION_ERROR_GAS\"));\n\n    // @dev key for the minimum gas that should be forwarded for execution error handling\n    bytes32 public constant MIN_HANDLE_EXECUTION_ERROR_GAS_TO_FORWARD = keccak256(abi.encode(\"MIN_HANDLE_EXECUTION_ERROR_GAS_TO_FORWARD\"));\n\n    // @dev key for the min additional gas for execution\n    bytes32 public constant MIN_ADDITIONAL_GAS_FOR_EXECUTION = keccak256(abi.encode(\"MIN_ADDITIONAL_GAS_FOR_EXECUTION\"));\n\n    // @dev for a global reentrancy guard\n    bytes32 public constant REENTRANCY_GUARD_STATUS = keccak256(abi.encode(\"REENTRANCY_GUARD_STATUS\"));\n\n    // @dev key for deposit fees\n    bytes32 public constant DEPOSIT_FEE_TYPE = keccak256(abi.encode(\"DEPOSIT_FEE_TYPE\"));\n    // @dev key for withdrawal fees\n    bytes32 public constant WITHDRAWAL_FEE_TYPE = keccak256(abi.encode(\"WITHDRAWAL_FEE_TYPE\"));\n    // @dev key for swap fees\n    bytes32 public constant SWAP_FEE_TYPE = keccak256(abi.encode(\"SWAP_FEE_TYPE\"));\n    // @dev key for position fees\n    bytes32 public constant POSITION_FEE_TYPE = keccak256(abi.encode(\"POSITION_FEE_TYPE\"));\n    // @dev key for ui deposit fees\n    bytes32 public constant UI_DEPOSIT_FEE_TYPE = keccak256(abi.encode(\"UI_DEPOSIT_FEE_TYPE\"));\n    // @dev key for ui withdrawal fees\n    bytes32 public constant UI_WITHDRAWAL_FEE_TYPE = keccak256(abi.encode(\"UI_WITHDRAWAL_FEE_TYPE\"));\n    // @dev key for ui swap fees\n    bytes32 public constant UI_SWAP_FEE_TYPE = keccak256(abi.encode(\"UI_SWAP_FEE_TYPE\"));\n    // @dev key for ui position fees\n    bytes32 public constant UI_POSITION_FEE_TYPE = keccak256(abi.encode(\"UI_POSITION_FEE_TYPE\"));\n\n    // @dev key for ui fee factor\n    bytes32 public constant UI_FEE_FACTOR = keccak256(abi.encode(\"UI_FEE_FACTOR\"));\n    // @dev key for max ui fee receiver factor\n    bytes32 public constant MAX_UI_FEE_FACTOR = keccak256(abi.encode(\"MAX_UI_FEE_FACTOR\"));\n\n    // @dev key for the claimable fee amount\n    bytes32 public constant CLAIMABLE_FEE_AMOUNT = keccak256(abi.encode(\"CLAIMABLE_FEE_AMOUNT\"));\n    // @dev key for the claimable ui fee amount\n    bytes32 public constant CLAIMABLE_UI_FEE_AMOUNT = keccak256(abi.encode(\"CLAIMABLE_UI_FEE_AMOUNT\"));\n    // @dev key for the max number of auto cancel orders\n    bytes32 public constant MAX_AUTO_CANCEL_ORDERS = keccak256(abi.encode(\"MAX_AUTO_CANCEL_ORDERS\"));\n    // @dev key for the max total callback gas limit for auto cancel orders\n    bytes32 public constant MAX_TOTAL_CALLBACK_GAS_LIMIT_FOR_AUTO_CANCEL_ORDERS = keccak256(abi.encode(\"MAX_TOTAL_CALLBACK_GAS_LIMIT_FOR_AUTO_CANCEL_ORDERS\"));\n\n    // @dev key for the market list\n    bytes32 public constant MARKET_LIST = keccak256(abi.encode(\"MARKET_LIST\"));\n\n    // @dev key for the fee batch list\n    bytes32 public constant FEE_BATCH_LIST = keccak256(abi.encode(\"FEE_BATCH_LIST\"));\n\n    // @dev key for the deposit list\n    bytes32 public constant DEPOSIT_LIST = keccak256(abi.encode(\"DEPOSIT_LIST\"));\n    // @dev key for the account deposit list\n    bytes32 public constant ACCOUNT_DEPOSIT_LIST = keccak256(abi.encode(\"ACCOUNT_DEPOSIT_LIST\"));\n\n    // @dev key for the withdrawal list\n    bytes32 public constant WITHDRAWAL_LIST = keccak256(abi.encode(\"WITHDRAWAL_LIST\"));\n    // @dev key for the account withdrawal list\n    bytes32 public constant ACCOUNT_WITHDRAWAL_LIST = keccak256(abi.encode(\"ACCOUNT_WITHDRAWAL_LIST\"));\n\n    // @dev key for the shift list\n    bytes32 public constant SHIFT_LIST = keccak256(abi.encode(\"SHIFT_LIST\"));\n    // @dev key for the account shift list\n    bytes32 public constant ACCOUNT_SHIFT_LIST = keccak256(abi.encode(\"ACCOUNT_SHIFT_LIST\"));\n\n    // @dev key for the glv list\n    bytes32 public constant GLV_LIST = keccak256(abi.encode(\"GLV_LIST\"));\n\n    // @dev key for the glv deposit list\n    bytes32 public constant GLV_DEPOSIT_LIST = keccak256(abi.encode(\"GLV_DEPOSIT_LIST\"));\n    // @dev key for the account glv deposit list\n    bytes32 public constant ACCOUNT_GLV_DEPOSIT_LIST = keccak256(abi.encode(\"ACCOUNT_GLV_DEPOSIT_LIST\"));\n    // @dev key for the account glv supported market list\n    bytes32 public constant GLV_SUPPORTED_MARKET_LIST = keccak256(abi.encode(\"GLV_SUPPORTED_MARKET_LIST\"));\n\n    // @dev key for the position list\n    bytes32 public constant POSITION_LIST = keccak256(abi.encode(\"POSITION_LIST\"));\n    // @dev key for the account position list\n    bytes32 public constant ACCOUNT_POSITION_LIST = keccak256(abi.encode(\"ACCOUNT_POSITION_LIST\"));\n\n    // @dev key for the order list\n    bytes32 public constant ORDER_LIST = keccak256(abi.encode(\"ORDER_LIST\"));\n    // @dev key for the account order list\n    bytes32 public constant ACCOUNT_ORDER_LIST = keccak256(abi.encode(\"ACCOUNT_ORDER_LIST\"));\n\n    // @dev key for the subaccount list\n    bytes32 public constant SUBACCOUNT_LIST = keccak256(abi.encode(\"SUBACCOUNT_LIST\"));\n\n    // @dev key for the auto cancel order list\n    bytes32 public constant AUTO_CANCEL_ORDER_LIST = keccak256(abi.encode(\"AUTO_CANCEL_ORDER_LIST\"));\n\n    // @dev key for is market disabled\n    bytes32 public constant IS_MARKET_DISABLED = keccak256(abi.encode(\"IS_MARKET_DISABLED\"));\n\n    // @dev key for the max swap path length allowed\n    bytes32 public constant MAX_SWAP_PATH_LENGTH = keccak256(abi.encode(\"MAX_SWAP_PATH_LENGTH\"));\n    // @dev key used to store markets observed in a swap path, to ensure that a swap path contains unique markets\n    bytes32 public constant SWAP_PATH_MARKET_FLAG = keccak256(abi.encode(\"SWAP_PATH_MARKET_FLAG\"));\n    // @dev key used to store the min market tokens for the first deposit for a market\n    bytes32 public constant MIN_MARKET_TOKENS_FOR_FIRST_DEPOSIT = keccak256(abi.encode(\"MIN_MARKET_TOKENS_FOR_FIRST_DEPOSIT\"));\n\n    // @dev key for whether the create glv deposit feature is disabled\n    bytes32 public constant CREATE_GLV_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\"CREATE_GLV_DEPOSIT_FEATURE_DISABLED\"));\n    // @dev key for whether the cancel glv deposit feature is disabled\n    bytes32 public constant CANCEL_GLV_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\"CANCEL_GLV_DEPOSIT_FEATURE_DISABLED\"));\n    // @dev key for whether the execute glv deposit feature is disabled\n    bytes32 public constant EXECUTE_GLV_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_GLV_DEPOSIT_FEATURE_DISABLED\"));\n    // @dev key for whether the glv shift feature is disabled\n    bytes32 public constant GLV_SHIFT_FEATURE_DISABLED = keccak256(abi.encode(\"GLV_SHIFT_FEATURE_DISABLED\"));\n\n    // @dev key for whether the create deposit feature is disabled\n    bytes32 public constant CREATE_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\"CREATE_DEPOSIT_FEATURE_DISABLED\"));\n    // @dev key for whether the cancel deposit feature is disabled\n    bytes32 public constant CANCEL_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\"CANCEL_DEPOSIT_FEATURE_DISABLED\"));\n    // @dev key for whether the execute deposit feature is disabled\n    bytes32 public constant EXECUTE_DEPOSIT_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_DEPOSIT_FEATURE_DISABLED\"));\n\n    // @dev key for whether the create withdrawal feature is disabled\n    bytes32 public constant CREATE_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\"CREATE_WITHDRAWAL_FEATURE_DISABLED\"));\n    // @dev key for whether the cancel withdrawal feature is disabled\n    bytes32 public constant CANCEL_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\"CANCEL_WITHDRAWAL_FEATURE_DISABLED\"));\n    // @dev key for whether the execute withdrawal feature is disabled\n    bytes32 public constant EXECUTE_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_WITHDRAWAL_FEATURE_DISABLED\"));\n    // @dev key for whether the execute atomic withdrawal feature is disabled\n    bytes32 public constant EXECUTE_ATOMIC_WITHDRAWAL_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_ATOMIC_WITHDRAWAL_FEATURE_DISABLED\"));\n\n    // @dev key for whether the create shift feature is disabled\n    bytes32 public constant CREATE_SHIFT_FEATURE_DISABLED = keccak256(abi.encode(\"CREATE_SHIFT_FEATURE_DISABLED\"));\n    // @dev key for whether the cancel shift feature is disabled\n    bytes32 public constant CANCEL_SHIFT_FEATURE_DISABLED = keccak256(abi.encode(\"CANCEL_SHIFT_FEATURE_DISABLED\"));\n    // @dev key for whether the execute shift feature is disabled\n    bytes32 public constant EXECUTE_SHIFT_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_SHIFT_FEATURE_DISABLED\"));\n\n    // @dev key for whether the create order feature is disabled\n    bytes32 public constant CREATE_ORDER_FEATURE_DISABLED = keccak256(abi.encode(\"CREATE_ORDER_FEATURE_DISABLED\"));\n    // @dev key for whether the execute order feature is disabled\n    bytes32 public constant EXECUTE_ORDER_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_ORDER_FEATURE_DISABLED\"));\n    // @dev key for whether the execute adl feature is disabled\n    // for liquidations, it can be disabled by using the EXECUTE_ORDER_FEATURE_DISABLED key with the Liquidation\n    // order type, ADL orders have a MarketDecrease order type, so a separate key is needed to disable it\n    bytes32 public constant EXECUTE_ADL_FEATURE_DISABLED = keccak256(abi.encode(\"EXECUTE_ADL_FEATURE_DISABLED\"));\n    // @dev key for whether the update order feature is disabled\n    bytes32 public constant UPDATE_ORDER_FEATURE_DISABLED = keccak256(abi.encode(\"UPDATE_ORDER_FEATURE_DISABLED\"));\n    // @dev key for whether the cancel order feature is disabled\n    bytes32 public constant CANCEL_ORDER_FEATURE_DISABLED = keccak256(abi.encode(\"CANCEL_ORDER_FEATURE_DISABLED\"));\n\n    // @dev key for whether the claim funding fees feature is disabled\n    bytes32 public constant CLAIM_FUNDING_FEES_FEATURE_DISABLED = keccak256(abi.encode(\"CLAIM_FUNDING_FEES_FEATURE_DISABLED\"));\n    // @dev key for whether the claim collateral feature is disabled\n    bytes32 public constant CLAIM_COLLATERAL_FEATURE_DISABLED = keccak256(abi.encode(\"CLAIM_COLLATERAL_FEATURE_DISABLED\"));\n    // @dev key for whether the claim affiliate rewards feature is disabled\n    bytes32 public constant CLAIM_AFFILIATE_REWARDS_FEATURE_DISABLED = keccak256(abi.encode(\"CLAIM_AFFILIATE_REWARDS_FEATURE_DISABLED\"));\n    // @dev key for whether the claim ui fees feature is disabled\n    bytes32 public constant CLAIM_UI_FEES_FEATURE_DISABLED = keccak256(abi.encode(\"CLAIM_UI_FEES_FEATURE_DISABLED\"));\n    // @dev key for whether the subaccount feature is disabled\n    bytes32 public constant SUBACCOUNT_FEATURE_DISABLED = keccak256(abi.encode(\"SUBACCOUNT_FEATURE_DISABLED\"));\n\n    // @dev key for the minimum required oracle signers for an oracle observation\n    bytes32 public constant MIN_ORACLE_SIGNERS = keccak256(abi.encode(\"MIN_ORACLE_SIGNERS\"));\n    // @dev key for the minimum block confirmations before blockhash can be excluded for oracle signature validation\n    bytes32 public constant MIN_ORACLE_BLOCK_CONFIRMATIONS = keccak256(abi.encode(\"MIN_ORACLE_BLOCK_CONFIRMATIONS\"));\n    // @dev key for the maximum usable oracle price age in seconds\n    bytes32 public constant MAX_ORACLE_PRICE_AGE = keccak256(abi.encode(\"MAX_ORACLE_PRICE_AGE\"));\n    // @dev key for the maximum oracle timestamp range\n    bytes32 public constant MAX_ORACLE_TIMESTAMP_RANGE = keccak256(abi.encode(\"MAX_ORACLE_TIMESTAMP_RANGE\"));\n    // @dev key for the maximum oracle price deviation factor from the ref price\n    bytes32 public constant MAX_ORACLE_REF_PRICE_DEVIATION_FACTOR = keccak256(abi.encode(\"MAX_ORACLE_REF_PRICE_DEVIATION_FACTOR\"));\n    // @dev key for whether an oracle provider is enabled\n    bytes32 public constant IS_ORACLE_PROVIDER_ENABLED = keccak256(abi.encode(\"IS_ORACLE_PROVIDER_ENABLED\"));\n    // @dev key for whether an oracle provider can be used for atomic actions\n    bytes32 public constant IS_ATOMIC_ORACLE_PROVIDER = keccak256(abi.encode(\"IS_ATOMIC_ORACLE_PROVIDER\"));\n    // @dev key for oracle timestamp adjustment\n    bytes32 public constant ORACLE_TIMESTAMP_ADJUSTMENT = keccak256(abi.encode(\"ORACLE_TIMESTAMP_ADJUSTMENT\"));\n    // @dev key for oracle provider for token\n    bytes32 public constant ORACLE_PROVIDER_FOR_TOKEN = keccak256(abi.encode(\"ORACLE_PROVIDER_FOR_TOKEN\"));\n    // @dev key for the chainlink payment token\n    bytes32 public constant CHAINLINK_PAYMENT_TOKEN = keccak256(abi.encode(\"CHAINLINK_PAYMENT_TOKEN\"));\n    // @dev key for the sequencer grace duration\n    bytes32 public constant SEQUENCER_GRACE_DURATION = keccak256(abi.encode(\"SEQUENCER_GRACE_DURATION\"));\n\n    // @dev key for the percentage amount of position fees to be received\n    bytes32 public constant POSITION_FEE_RECEIVER_FACTOR = keccak256(abi.encode(\"POSITION_FEE_RECEIVER_FACTOR\"));\n    // @dev key for the percentage amount of swap fees to be received\n    bytes32 public constant SWAP_FEE_RECEIVER_FACTOR = keccak256(abi.encode(\"SWAP_FEE_RECEIVER_FACTOR\"));\n    // @dev key for the percentage amount of borrowing fees to be received\n    bytes32 public constant BORROWING_FEE_RECEIVER_FACTOR = keccak256(abi.encode(\"BORROWING_FEE_RECEIVER_FACTOR\"));\n\n    // @dev key for the base gas limit used when estimating execution fee\n    bytes32 public constant ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1 = keccak256(abi.encode(\"ESTIMATED_GAS_FEE_BASE_AMOUNT_V2_1\"));\n    // @dev key for the gas limit used for each oracle price when estimating execution fee\n    bytes32 public constant ESTIMATED_GAS_FEE_PER_ORACLE_PRICE = keccak256(abi.encode(\"ESTIMATED_GAS_FEE_PER_ORACLE_PRICE\"));\n    // @dev key for the multiplier used when estimating execution fee\n    bytes32 public constant ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR = keccak256(abi.encode(\"ESTIMATED_GAS_FEE_MULTIPLIER_FACTOR\"));\n\n    // @dev key for the base gas limit used when calculating execution fee\n    bytes32 public constant EXECUTION_GAS_FEE_BASE_AMOUNT_V2_1 = keccak256(abi.encode(\"EXECUTION_GAS_FEE_BASE_AMOUNT_V2_1\"));\n    // @dev key for the gas limit used for each oracle price\n    bytes32 public constant EXECUTION_GAS_FEE_PER_ORACLE_PRICE = keccak256(abi.encode(\"EXECUTION_GAS_FEE_PER_ORACLE_PRICE\"));\n    // @dev key for the multiplier used when calculating execution fee\n    bytes32 public constant EXECUTION_GAS_FEE_MULTIPLIER_FACTOR = keccak256(abi.encode(\"EXECUTION_GAS_FEE_MULTIPLIER_FACTOR\"));\n\n    // @dev key for the estimated gas limit for deposits\n    bytes32 public constant DEPOSIT_GAS_LIMIT = keccak256(abi.encode(\"DEPOSIT_GAS_LIMIT\"));\n    // @dev key for the estimated gas limit for withdrawals\n    bytes32 public constant WITHDRAWAL_GAS_LIMIT = keccak256(abi.encode(\"WITHDRAWAL_GAS_LIMIT\"));\n    // @dev key for the estimated gas limit for each glv market\n    bytes32 public constant GLV_DEPOSIT_GAS_LIMIT = keccak256(abi.encode(\"GLV_DEPOSIT_GAS_LIMIT\"));\n    // @dev key for the estimated gas limit for shifts\n    bytes32 public constant GLV_PER_MARKET_GAS_LIMIT = keccak256(abi.encode(\"GLV_PER_MARKET_GAS_LIMIT\"));\n    // @dev key for the estimated gas limit for shifts\n    bytes32 public constant SHIFT_GAS_LIMIT = keccak256(abi.encode(\"SHIFT_GAS_LIMIT\"));\n    // @dev key for the estimated gas limit for single swaps\n    bytes32 public constant SINGLE_SWAP_GAS_LIMIT = keccak256(abi.encode(\"SINGLE_SWAP_GAS_LIMIT\"));\n    // @dev key for the estimated gas limit for increase orders\n    bytes32 public constant INCREASE_ORDER_GAS_LIMIT = keccak256(abi.encode(\"INCREASE_ORDER_GAS_LIMIT\"));\n    // @dev key for the estimated gas limit for decrease orders\n    bytes32 public constant DECREASE_ORDER_GAS_LIMIT = keccak256(abi.encode(\"DECREASE_ORDER_GAS_LIMIT\"));\n    // @dev key for the estimated gas limit for swap orders\n    bytes32 public constant SWAP_ORDER_GAS_LIMIT = keccak256(abi.encode(\"SWAP_ORDER_GAS_LIMIT\"));\n    // @dev key for the amount of gas to forward for token transfers\n    bytes32 public constant TOKEN_TRANSFER_GAS_LIMIT = keccak256(abi.encode(\"TOKEN_TRANSFER_GAS_LIMIT\"));\n    // @dev key for the amount of gas to forward for native token transfers\n    bytes32 public constant NATIVE_TOKEN_TRANSFER_GAS_LIMIT = keccak256(abi.encode(\"NATIVE_TOKEN_TRANSFER_GAS_LIMIT\"));\n    // @dev key for the request expiration time, after which the request will be considered expired\n    bytes32 public constant REQUEST_EXPIRATION_TIME = keccak256(abi.encode(\"REQUEST_EXPIRATION_TIME\"));\n\n    bytes32 public constant MAX_CALLBACK_GAS_LIMIT = keccak256(abi.encode(\"MAX_CALLBACK_GAS_LIMIT\"));\n    bytes32 public constant REFUND_EXECUTION_FEE_GAS_LIMIT = keccak256(abi.encode(\"REFUND_EXECUTION_FEE_GAS_LIMIT\"));\n    bytes32 public constant SAVED_CALLBACK_CONTRACT = keccak256(abi.encode(\"SAVED_CALLBACK_CONTRACT\"));\n\n    // @dev key for the min collateral factor\n    bytes32 public constant MIN_COLLATERAL_FACTOR = keccak256(abi.encode(\"MIN_COLLATERAL_FACTOR\"));\n    // @dev key for the min collateral factor for open interest multiplier\n    bytes32 public constant MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER = keccak256(abi.encode(\"MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER\"));\n    // @dev key for the min allowed collateral in USD\n    bytes32 public constant MIN_COLLATERAL_USD = keccak256(abi.encode(\"MIN_COLLATERAL_USD\"));\n    // @dev key for the min allowed position size in USD\n    bytes32 public constant MIN_POSITION_SIZE_USD = keccak256(abi.encode(\"MIN_POSITION_SIZE_USD\"));\n\n    // @dev key for the virtual id of tokens\n    bytes32 public constant VIRTUAL_TOKEN_ID = keccak256(abi.encode(\"VIRTUAL_TOKEN_ID\"));\n    // @dev key for the virtual id of markets\n    bytes32 public constant VIRTUAL_MARKET_ID = keccak256(abi.encode(\"VIRTUAL_MARKET_ID\"));\n    // @dev key for the virtual inventory for swaps\n    bytes32 public constant VIRTUAL_INVENTORY_FOR_SWAPS = keccak256(abi.encode(\"VIRTUAL_INVENTORY_FOR_SWAPS\"));\n    // @dev key for the virtual inventory for positions\n    bytes32 public constant VIRTUAL_INVENTORY_FOR_POSITIONS = keccak256(abi.encode(\"VIRTUAL_INVENTORY_FOR_POSITIONS\"));\n\n    // @dev key for the position impact factor\n    bytes32 public constant POSITION_IMPACT_FACTOR = keccak256(abi.encode(\"POSITION_IMPACT_FACTOR\"));\n    // @dev key for the position impact exponent factor\n    bytes32 public constant POSITION_IMPACT_EXPONENT_FACTOR = keccak256(abi.encode(\"POSITION_IMPACT_EXPONENT_FACTOR\"));\n    // @dev key for the max decrease position impact factor\n    bytes32 public constant MAX_POSITION_IMPACT_FACTOR = keccak256(abi.encode(\"MAX_POSITION_IMPACT_FACTOR\"));\n    // @dev key for the max position impact factor for liquidations\n    bytes32 public constant MAX_POSITION_IMPACT_FACTOR_FOR_LIQUIDATIONS = keccak256(abi.encode(\"MAX_POSITION_IMPACT_FACTOR_FOR_LIQUIDATIONS\"));\n    // @dev key for the position fee factor\n    bytes32 public constant POSITION_FEE_FACTOR = keccak256(abi.encode(\"POSITION_FEE_FACTOR\"));\n    // @dev key for the swap impact factor\n    bytes32 public constant SWAP_IMPACT_FACTOR = keccak256(abi.encode(\"SWAP_IMPACT_FACTOR\"));\n    // @dev key for the swap impact exponent factor\n    bytes32 public constant SWAP_IMPACT_EXPONENT_FACTOR = keccak256(abi.encode(\"SWAP_IMPACT_EXPONENT_FACTOR\"));\n    // @dev key for the swap fee factor\n    bytes32 public constant SWAP_FEE_FACTOR = keccak256(abi.encode(\"SWAP_FEE_FACTOR\"));\n    // @dev key for the atomic swap fee factor\n    bytes32 public constant ATOMIC_SWAP_FEE_FACTOR = keccak256(abi.encode(\"ATOMIC_SWAP_FEE_FACTOR\"));\n    // @dev key for the oracle type\n    bytes32 public constant ORACLE_TYPE = keccak256(abi.encode(\"ORACLE_TYPE\"));\n    // @dev key for open interest\n    bytes32 public constant OPEN_INTEREST = keccak256(abi.encode(\"OPEN_INTEREST\"));\n    // @dev key for open interest in tokens\n    bytes32 public constant OPEN_INTEREST_IN_TOKENS = keccak256(abi.encode(\"OPEN_INTEREST_IN_TOKENS\"));\n    // @dev key for collateral sum for a market\n    bytes32 public constant COLLATERAL_SUM = keccak256(abi.encode(\"COLLATERAL_SUM\"));\n    // @dev key for pool amount\n    bytes32 public constant POOL_AMOUNT = keccak256(abi.encode(\"POOL_AMOUNT\"));\n    // @dev key for max pool amount\n    bytes32 public constant MAX_POOL_AMOUNT = keccak256(abi.encode(\"MAX_POOL_AMOUNT\"));\n    // @dev key for max pool usd for deposit\n    bytes32 public constant MAX_POOL_USD_FOR_DEPOSIT = keccak256(abi.encode(\"MAX_POOL_USD_FOR_DEPOSIT\"));\n    // @dev key for max open interest\n    bytes32 public constant MAX_OPEN_INTEREST = keccak256(abi.encode(\"MAX_OPEN_INTEREST\"));\n    // @dev key for position impact pool amount\n    bytes32 public constant POSITION_IMPACT_POOL_AMOUNT = keccak256(abi.encode(\"POSITION_IMPACT_POOL_AMOUNT\"));\n    // @dev key for min position impact pool amount\n    bytes32 public constant MIN_POSITION_IMPACT_POOL_AMOUNT = keccak256(abi.encode(\"MIN_POSITION_IMPACT_POOL_AMOUNT\"));\n    // @dev key for position impact pool distribution rate\n    bytes32 public constant POSITION_IMPACT_POOL_DISTRIBUTION_RATE = keccak256(abi.encode(\"POSITION_IMPACT_POOL_DISTRIBUTION_RATE\"));\n    // @dev key for position impact pool distributed at\n    bytes32 public constant POSITION_IMPACT_POOL_DISTRIBUTED_AT = keccak256(abi.encode(\"POSITION_IMPACT_POOL_DISTRIBUTED_AT\"));\n    // @dev key for swap impact pool amount\n    bytes32 public constant SWAP_IMPACT_POOL_AMOUNT = keccak256(abi.encode(\"SWAP_IMPACT_POOL_AMOUNT\"));\n    // @dev key for price feed\n    bytes32 public constant PRICE_FEED = keccak256(abi.encode(\"PRICE_FEED\"));\n    // @dev key for price feed multiplier\n    bytes32 public constant PRICE_FEED_MULTIPLIER = keccak256(abi.encode(\"PRICE_FEED_MULTIPLIER\"));\n    // @dev key for price feed heartbeat\n    bytes32 public constant PRICE_FEED_HEARTBEAT_DURATION = keccak256(abi.encode(\"PRICE_FEED_HEARTBEAT_DURATION\"));\n    // @dev key for data stream feed id\n    bytes32 public constant DATA_STREAM_ID = keccak256(abi.encode(\"DATA_STREAM_ID\"));\n    // @dev key for data stream feed multipler\n    bytes32 public constant DATA_STREAM_MULTIPLIER = keccak256(abi.encode(\"DATA_STREAM_MULTIPLIER\"));\n    // @dev key for stable price\n    bytes32 public constant STABLE_PRICE = keccak256(abi.encode(\"STABLE_PRICE\"));\n    // @dev key for reserve factor\n    bytes32 public constant RESERVE_FACTOR = keccak256(abi.encode(\"RESERVE_FACTOR\"));\n    // @dev key for open interest reserve factor\n    bytes32 public constant OPEN_INTEREST_RESERVE_FACTOR = keccak256(abi.encode(\"OPEN_INTEREST_RESERVE_FACTOR\"));\n    // @dev key for max pnl factor\n    bytes32 public constant MAX_PNL_FACTOR = keccak256(abi.encode(\"MAX_PNL_FACTOR\"));\n    // @dev key for max pnl factor\n    bytes32 public constant MAX_PNL_FACTOR_FOR_TRADERS = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_TRADERS\"));\n    // @dev key for max pnl factor for adl\n    bytes32 public constant MAX_PNL_FACTOR_FOR_ADL = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_ADL\"));\n    // @dev key for min pnl factor for adl\n    bytes32 public constant MIN_PNL_FACTOR_AFTER_ADL = keccak256(abi.encode(\"MIN_PNL_FACTOR_AFTER_ADL\"));\n    // @dev key for max pnl factor\n    bytes32 public constant MAX_PNL_FACTOR_FOR_DEPOSITS = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_DEPOSITS\"));\n    // @dev key for max pnl factor for withdrawals\n    bytes32 public constant MAX_PNL_FACTOR_FOR_WITHDRAWALS = keccak256(abi.encode(\"MAX_PNL_FACTOR_FOR_WITHDRAWALS\"));\n    // @dev key for latest ADL at\n    bytes32 public constant LATEST_ADL_AT = keccak256(abi.encode(\"LATEST_ADL_AT\"));\n    // @dev key for whether ADL is enabled\n    bytes32 public constant IS_ADL_ENABLED = keccak256(abi.encode(\"IS_ADL_ENABLED\"));\n    // @dev key for funding factor\n    bytes32 public constant FUNDING_FACTOR = keccak256(abi.encode(\"FUNDING_FACTOR\"));\n    // @dev key for funding exponent factor\n    bytes32 public constant FUNDING_EXPONENT_FACTOR = keccak256(abi.encode(\"FUNDING_EXPONENT_FACTOR\"));\n    // @dev key for saved funding factor\n    bytes32 public constant SAVED_FUNDING_FACTOR_PER_SECOND = keccak256(abi.encode(\"SAVED_FUNDING_FACTOR_PER_SECOND\"));\n    // @dev key for funding increase factor\n    bytes32 public constant FUNDING_INCREASE_FACTOR_PER_SECOND = keccak256(abi.encode(\"FUNDING_INCREASE_FACTOR_PER_SECOND\"));\n    // @dev key for funding decrease factor\n    bytes32 public constant FUNDING_DECREASE_FACTOR_PER_SECOND = keccak256(abi.encode(\"FUNDING_DECREASE_FACTOR_PER_SECOND\"));\n    // @dev key for min funding factor\n    bytes32 public constant MIN_FUNDING_FACTOR_PER_SECOND = keccak256(abi.encode(\"MIN_FUNDING_FACTOR_PER_SECOND\"));\n    // @dev key for max funding factor\n    bytes32 public constant MAX_FUNDING_FACTOR_PER_SECOND = keccak256(abi.encode(\"MAX_FUNDING_FACTOR_PER_SECOND\"));\n    // @dev key for max funding factor limit\n    bytes32 public constant MAX_FUNDING_FACTOR_PER_SECOND_LIMIT = keccak256(abi.encode(\"MAX_FUNDING_FACTOR_PER_SECOND_LIMIT\"));\n    // @dev key for threshold for stable funding\n    bytes32 public constant THRESHOLD_FOR_STABLE_FUNDING = keccak256(abi.encode(\"THRESHOLD_FOR_STABLE_FUNDING\"));\n    // @dev key for threshold for decrease funding\n    bytes32 public constant THRESHOLD_FOR_DECREASE_FUNDING = keccak256(abi.encode(\"THRESHOLD_FOR_DECREASE_FUNDING\"));\n    // @dev key for funding fee amount per size\n    bytes32 public constant FUNDING_FEE_AMOUNT_PER_SIZE = keccak256(abi.encode(\"FUNDING_FEE_AMOUNT_PER_SIZE\"));\n    // @dev key for claimable funding amount per size\n    bytes32 public constant CLAIMABLE_FUNDING_AMOUNT_PER_SIZE = keccak256(abi.encode(\"CLAIMABLE_FUNDING_AMOUNT_PER_SIZE\"));\n    // @dev key for when funding was last updated at\n    bytes32 public constant FUNDING_UPDATED_AT = keccak256(abi.encode(\"FUNDING_UPDATED_AT\"));\n    // @dev key for claimable funding amount\n    bytes32 public constant CLAIMABLE_FUNDING_AMOUNT = keccak256(abi.encode(\"CLAIMABLE_FUNDING_AMOUNT\"));\n    // @dev key for claimable collateral amount\n    bytes32 public constant CLAIMABLE_COLLATERAL_AMOUNT = keccak256(abi.encode(\"CLAIMABLE_COLLATERAL_AMOUNT\"));\n    // @dev key for claimable collateral factor\n    bytes32 public constant CLAIMABLE_COLLATERAL_FACTOR = keccak256(abi.encode(\"CLAIMABLE_COLLATERAL_FACTOR\"));\n    // @dev key for claimable collateral time divisor\n    bytes32 public constant CLAIMABLE_COLLATERAL_TIME_DIVISOR = keccak256(abi.encode(\"CLAIMABLE_COLLATERAL_TIME_DIVISOR\"));\n    // @dev key for claimed collateral amount\n    bytes32 public constant CLAIMED_COLLATERAL_AMOUNT = keccak256(abi.encode(\"CLAIMED_COLLATERAL_AMOUNT\"));\n    // @dev key for optimal usage factor\n    bytes32 public constant OPTIMAL_USAGE_FACTOR = keccak256(abi.encode(\"OPTIMAL_USAGE_FACTOR\"));\n    // @dev key for base borrowing factor\n    bytes32 public constant BASE_BORROWING_FACTOR = keccak256(abi.encode(\"BASE_BORROWING_FACTOR\"));\n    // @dev key for above optimal usage borrowing factor\n    bytes32 public constant ABOVE_OPTIMAL_USAGE_BORROWING_FACTOR = keccak256(abi.encode(\"ABOVE_OPTIMAL_USAGE_BORROWING_FACTOR\"));\n    // @dev key for borrowing factor\n    bytes32 public constant BORROWING_FACTOR = keccak256(abi.encode(\"BORROWING_FACTOR\"));\n    // @dev key for borrowing factor\n    bytes32 public constant BORROWING_EXPONENT_FACTOR = keccak256(abi.encode(\"BORROWING_EXPONENT_FACTOR\"));\n    // @dev key for skipping the borrowing factor for the smaller side\n    bytes32 public constant SKIP_BORROWING_FEE_FOR_SMALLER_SIDE = keccak256(abi.encode(\"SKIP_BORROWING_FEE_FOR_SMALLER_SIDE\"));\n    // @dev key for cumulative borrowing factor\n    bytes32 public constant CUMULATIVE_BORROWING_FACTOR = keccak256(abi.encode(\"CUMULATIVE_BORROWING_FACTOR\"));\n    // @dev key for when the cumulative borrowing factor was last updated at\n    bytes32 public constant CUMULATIVE_BORROWING_FACTOR_UPDATED_AT = keccak256(abi.encode(\"CUMULATIVE_BORROWING_FACTOR_UPDATED_AT\"));\n    // @dev key for total borrowing amount\n    bytes32 public constant TOTAL_BORROWING = keccak256(abi.encode(\"TOTAL_BORROWING\"));\n    // @dev key for affiliate reward\n    bytes32 public constant AFFILIATE_REWARD = keccak256(abi.encode(\"AFFILIATE_REWARD\"));\n    // @dev key for max allowed subaccount action count\n    bytes32 public constant MAX_ALLOWED_SUBACCOUNT_ACTION_COUNT = keccak256(abi.encode(\"MAX_ALLOWED_SUBACCOUNT_ACTION_COUNT\"));\n    // @dev key for subaccount action count\n    bytes32 public constant SUBACCOUNT_ACTION_COUNT = keccak256(abi.encode(\"SUBACCOUNT_ACTION_COUNT\"));\n    // @dev key for subaccount auto top up amount\n    bytes32 public constant SUBACCOUNT_AUTO_TOP_UP_AMOUNT = keccak256(abi.encode(\"SUBACCOUNT_AUTO_TOP_UP_AMOUNT\"));\n    // @dev key for subaccount order action\n    bytes32 public constant SUBACCOUNT_ORDER_ACTION = keccak256(abi.encode(\"SUBACCOUNT_ORDER_ACTION\"));\n    // @dev key for fee distributor swap order token index\n    bytes32 public constant FEE_DISTRIBUTOR_SWAP_TOKEN_INDEX = keccak256(abi.encode(\"FEE_DISTRIBUTOR_SWAP_TOKEN_INDEX\"));\n    // @dev key for fee distributor swap fee batch\n    bytes32 public constant FEE_DISTRIBUTOR_SWAP_FEE_BATCH = keccak256(abi.encode(\"FEE_DISTRIBUTOR_SWAP_FEE_BATCH\"));\n\n    // @dev key for the glv pending shift\n    bytes32 public constant GLV_PENDING_SHIFT = keccak256(abi.encode(\"GLV_PENDING_SHIFT\"));\n    bytes32 public constant GLV_PENDING_SHIFT_BACKREF = keccak256(abi.encode(\"GLV_PENDING_SHIFT_BACKREF\"));\n    // @dev key for the max market token balance usd for glv\n    bytes32 public constant GLV_MAX_MARKET_TOKEN_BALANCE_USD = keccak256(abi.encode(\"GLV_MAX_MARKET_TOKEN_BALANCE_USD\"));\n    // @dev key for is glv market disabled\n    bytes32 public constant IS_GLV_MARKET_DISABLED = keccak256(abi.encode(\"IS_GLV_MARKET_DISABLED\"));\n\n    // @dev constant for user initiated cancel reason\n    string public constant USER_INITIATED_CANCEL = \"USER_INITIATED_CANCEL\";\n\n    // @dev key for the account deposit list\n    // @param account the account for the list\n    function accountDepositListKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ACCOUNT_DEPOSIT_LIST, account));\n    }\n\n    // @dev key for the account withdrawal list\n    // @param account the account for the list\n    function accountWithdrawalListKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ACCOUNT_WITHDRAWAL_LIST, account));\n    }\n\n    // @dev key for the account shift list\n    // @param account the account for the list\n    function accountShiftListKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ACCOUNT_SHIFT_LIST, account));\n    }\n\n    // @dev key for the account glv deposit list\n    // @param account the account for the list\n    function accountGlvDepositListKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ACCOUNT_GLV_DEPOSIT_LIST, account));\n    }\n\n    // @dev key for the glv supported market list\n    // @param glv the glv for the supported market list\n    function glvSupportedMarketListKey(address glv) internal pure returns (bytes32) {\n        return keccak256(abi.encode(GLV_SUPPORTED_MARKET_LIST, glv));\n    }\n\n    // @dev key for the account position list\n    // @param account the account for the list\n    function accountPositionListKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ACCOUNT_POSITION_LIST, account));\n    }\n\n    // @dev key for the account order list\n    // @param account the account for the list\n    function accountOrderListKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ACCOUNT_ORDER_LIST, account));\n    }\n\n    // @dev key for the subaccount list\n    // @param account the account for the list\n    function subaccountListKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(SUBACCOUNT_LIST, account));\n    }\n\n    // @dev key for the auto cancel order list\n    // @param position key the position key for the list\n    function autoCancelOrderListKey(bytes32 positionKey) internal pure returns (bytes32) {\n        return keccak256(abi.encode(AUTO_CANCEL_ORDER_LIST, positionKey));\n    }\n\n    // @dev key for the claimable fee amount\n    // @param market the market for the fee\n    // @param token the token for the fee\n    function claimableFeeAmountKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(CLAIMABLE_FEE_AMOUNT, market, token));\n    }\n\n    // @dev key for the claimable ui fee amount\n    // @param market the market for the fee\n    // @param token the token for the fee\n    // @param account the account that can claim the ui fee\n    function claimableUiFeeAmountKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(CLAIMABLE_UI_FEE_AMOUNT, market, token));\n    }\n\n    // @dev key for the claimable ui fee amount for account\n    // @param market the market for the fee\n    // @param token the token for the fee\n    // @param account the account that can claim the ui fee\n    function claimableUiFeeAmountKey(address market, address token, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(CLAIMABLE_UI_FEE_AMOUNT, market, token, account));\n    }\n\n    // @dev key for deposit gas limit\n    // @param singleToken whether a single token or pair tokens are being deposited\n    // @return key for deposit gas limit\n    function depositGasLimitKey(bool singleToken) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            DEPOSIT_GAS_LIMIT,\n            singleToken\n        ));\n    }\n\n    // @dev key for withdrawal gas limit\n    // @return key for withdrawal gas limit\n    function withdrawalGasLimitKey() internal pure returns (bytes32) {\n        return WITHDRAWAL_GAS_LIMIT;\n    }\n\n    // @dev key for shift gas limit\n    // @return key for shift gas limit\n    function shiftGasLimitKey() internal pure returns (bytes32) {\n        return SHIFT_GAS_LIMIT;\n    }\n\n    function glvDepositGasLimitKey() internal pure returns (bytes32) {\n        return GLV_DEPOSIT_GAS_LIMIT;\n    }\n\n    function glvPerMarketGasLimitKey() internal pure returns (bytes32) {\n        return GLV_PER_MARKET_GAS_LIMIT;\n    }\n\n    // @dev key for single swap gas limit\n    // @return key for single swap gas limit\n    function singleSwapGasLimitKey() internal pure returns (bytes32) {\n        return SINGLE_SWAP_GAS_LIMIT;\n    }\n\n    // @dev key for increase order gas limit\n    // @return key for increase order gas limit\n    function increaseOrderGasLimitKey() internal pure returns (bytes32) {\n        return INCREASE_ORDER_GAS_LIMIT;\n    }\n\n    // @dev key for decrease order gas limit\n    // @return key for decrease order gas limit\n    function decreaseOrderGasLimitKey() internal pure returns (bytes32) {\n        return DECREASE_ORDER_GAS_LIMIT;\n    }\n\n    // @dev key for swap order gas limit\n    // @return key for swap order gas limit\n    function swapOrderGasLimitKey() internal pure returns (bytes32) {\n        return SWAP_ORDER_GAS_LIMIT;\n    }\n\n    function swapPathMarketFlagKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SWAP_PATH_MARKET_FLAG,\n            market\n        ));\n    }\n\n    // @dev key for whether create glv deposit is disabled\n    // @param the create deposit module\n    // @return key for whether create deposit is disabled\n    function createGlvDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CREATE_GLV_DEPOSIT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether cancel glv deposit is disabled\n    // @param the cancel deposit module\n    // @return key for whether cancel deposit is disabled\n    function cancelGlvDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CANCEL_GLV_DEPOSIT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether execute glv deposit is disabled\n    // @param the execute deposit module\n    // @return key for whether execute deposit is disabled\n    function executeGlvDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_GLV_DEPOSIT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether shift deposit is disabled\n    // @param the execute deposit module\n    // @return key for whether execute deposit is disabled\n    function glvShiftFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            GLV_SHIFT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n\n    // @dev key for whether create deposit is disabled\n    // @param the create deposit module\n    // @return key for whether create deposit is disabled\n    function createDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CREATE_DEPOSIT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether cancel deposit is disabled\n    // @param the cancel deposit module\n    // @return key for whether cancel deposit is disabled\n    function cancelDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CANCEL_DEPOSIT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether execute deposit is disabled\n    // @param the execute deposit module\n    // @return key for whether execute deposit is disabled\n    function executeDepositFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_DEPOSIT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether create withdrawal is disabled\n    // @param the create withdrawal module\n    // @return key for whether create withdrawal is disabled\n    function createWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CREATE_WITHDRAWAL_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether cancel withdrawal is disabled\n    // @param the cancel withdrawal module\n    // @return key for whether cancel withdrawal is disabled\n    function cancelWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CANCEL_WITHDRAWAL_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether execute withdrawal is disabled\n    // @param the execute withdrawal module\n    // @return key for whether execute withdrawal is disabled\n    function executeWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_WITHDRAWAL_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether execute atomic withdrawal is disabled\n    // @param the execute atomic withdrawal module\n    // @return key for whether execute atomic withdrawal is disabled\n    function executeAtomicWithdrawalFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_ATOMIC_WITHDRAWAL_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether create shift is disabled\n    // @param the create shift module\n    // @return key for whether create shift is disabled\n    function createShiftFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CREATE_SHIFT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether cancel shift is disabled\n    // @param the cancel shift module\n    // @return key for whether cancel shift is disabled\n    function cancelShiftFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CANCEL_SHIFT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether execute shift is disabled\n    // @param the execute shift module\n    // @return key for whether execute shift is disabled\n    function executeShiftFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_SHIFT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether create order is disabled\n    // @param the create order module\n    // @return key for whether create order is disabled\n    function createOrderFeatureDisabledKey(address module, uint256 orderType) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CREATE_ORDER_FEATURE_DISABLED,\n            module,\n            orderType\n        ));\n    }\n\n    // @dev key for whether execute order is disabled\n    // @param the execute order module\n    // @return key for whether execute order is disabled\n    function executeOrderFeatureDisabledKey(address module, uint256 orderType) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_ORDER_FEATURE_DISABLED,\n            module,\n            orderType\n        ));\n    }\n\n    // @dev key for whether execute adl is disabled\n    // @param the execute adl module\n    // @return key for whether execute adl is disabled\n    function executeAdlFeatureDisabledKey(address module, uint256 orderType) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            EXECUTE_ADL_FEATURE_DISABLED,\n            module,\n            orderType\n        ));\n    }\n\n    // @dev key for whether update order is disabled\n    // @param the update order module\n    // @return key for whether update order is disabled\n    function updateOrderFeatureDisabledKey(address module, uint256 orderType) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            UPDATE_ORDER_FEATURE_DISABLED,\n            module,\n            orderType\n        ));\n    }\n\n    // @dev key for whether cancel order is disabled\n    // @param the cancel order module\n    // @return key for whether cancel order is disabled\n    function cancelOrderFeatureDisabledKey(address module, uint256 orderType) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CANCEL_ORDER_FEATURE_DISABLED,\n            module,\n            orderType\n        ));\n    }\n\n    // @dev key for whether claim funding fees is disabled\n    // @param the claim funding fees module\n    function claimFundingFeesFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIM_FUNDING_FEES_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether claim colltareral is disabled\n    // @param the claim funding fees module\n    function claimCollateralFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIM_COLLATERAL_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether claim affiliate rewards is disabled\n    // @param the claim affiliate rewards module\n    function claimAffiliateRewardsFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIM_AFFILIATE_REWARDS_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether claim ui fees is disabled\n    // @param the claim ui fees module\n    function claimUiFeesFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIM_UI_FEES_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for whether subaccounts are disabled\n    // @param the subaccount module\n    function subaccountFeatureDisabledKey(address module) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SUBACCOUNT_FEATURE_DISABLED,\n            module\n        ));\n    }\n\n    // @dev key for ui fee factor\n    // @param account the fee receiver account\n    // @return key for ui fee factor\n    function uiFeeFactorKey(address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            UI_FEE_FACTOR,\n            account\n        ));\n    }\n\n    // @dev key for whether an oracle provider is enabled\n    // @param provider the oracle provider\n    // @return key for whether an oracle provider is enabled\n    function isOracleProviderEnabledKey(address provider) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            IS_ORACLE_PROVIDER_ENABLED,\n            provider\n        ));\n    }\n\n    // @dev key for whether an oracle provider is allowed to be used for atomic actions\n    // @param provider the oracle provider\n    // @return key for whether an oracle provider is allowed to be used for atomic actions\n    function isAtomicOracleProviderKey(address provider) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            IS_ATOMIC_ORACLE_PROVIDER,\n            provider\n        ));\n    }\n\n    // @dev key for oracle timestamp adjustment\n    // @param provider the oracle provider\n    // @param token the token\n    // @return key for oracle timestamp adjustment\n    function oracleTimestampAdjustmentKey(address provider, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            ORACLE_TIMESTAMP_ADJUSTMENT,\n            provider,\n            token\n        ));\n    }\n\n    // @dev key for oracle provider for token\n    // @param token the token\n    // @return key for oracle provider for token\n    function oracleProviderForTokenKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            ORACLE_PROVIDER_FOR_TOKEN,\n            token\n        ));\n    }\n\n    // @dev key for gas to forward for token transfer\n    // @param the token to check\n    // @return key for gas to forward for token transfer\n    function tokenTransferGasLimit(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            TOKEN_TRANSFER_GAS_LIMIT,\n            token\n        ));\n   }\n\n   // @dev the default callback contract\n   // @param account the user's account\n   // @param market the address of the market\n   // @param callbackContract the callback contract\n   function savedCallbackContract(address account, address market) internal pure returns (bytes32) {\n       return keccak256(abi.encode(\n           SAVED_CALLBACK_CONTRACT,\n           account,\n           market\n       ));\n   }\n\n   // @dev the min collateral factor key\n   // @param the market for the min collateral factor\n   function minCollateralFactorKey(address market) internal pure returns (bytes32) {\n       return keccak256(abi.encode(\n           MIN_COLLATERAL_FACTOR,\n           market\n       ));\n   }\n\n   // @dev the min collateral factor for open interest multiplier key\n   // @param the market for the factor\n   function minCollateralFactorForOpenInterestMultiplierKey(address market, bool isLong) internal pure returns (bytes32) {\n       return keccak256(abi.encode(\n           MIN_COLLATERAL_FACTOR_FOR_OPEN_INTEREST_MULTIPLIER,\n           market,\n           isLong\n       ));\n   }\n\n   // @dev the key for the virtual token id\n   // @param the token to get the virtual id for\n   function virtualTokenIdKey(address token) internal pure returns (bytes32) {\n       return keccak256(abi.encode(\n           VIRTUAL_TOKEN_ID,\n           token\n       ));\n   }\n\n   // @dev the key for the virtual market id\n   // @param the market to get the virtual id for\n   function virtualMarketIdKey(address market) internal pure returns (bytes32) {\n       return keccak256(abi.encode(\n           VIRTUAL_MARKET_ID,\n           market\n       ));\n   }\n\n   // @dev the key for the virtual inventory for positions\n   // @param the virtualTokenId the virtual token id\n   function virtualInventoryForPositionsKey(bytes32 virtualTokenId) internal pure returns (bytes32) {\n       return keccak256(abi.encode(\n           VIRTUAL_INVENTORY_FOR_POSITIONS,\n           virtualTokenId\n       ));\n   }\n\n   // @dev the key for the virtual inventory for swaps\n   // @param the virtualMarketId the virtual market id\n   // @param the token to check the inventory for\n   function virtualInventoryForSwapsKey(bytes32 virtualMarketId, bool isLongToken) internal pure returns (bytes32) {\n       return keccak256(abi.encode(\n           VIRTUAL_INVENTORY_FOR_SWAPS,\n           virtualMarketId,\n           isLongToken\n       ));\n   }\n\n    // @dev key for position impact factor\n    // @param market the market address to check\n    // @param isPositive whether the impact is positive or negative\n    // @return key for position impact factor\n    function positionImpactFactorKey(address market, bool isPositive) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            POSITION_IMPACT_FACTOR,\n            market,\n            isPositive\n        ));\n   }\n\n    // @dev key for position impact exponent factor\n    // @param market the market address to check\n    // @return key for position impact exponent factor\n    function positionImpactExponentFactorKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            POSITION_IMPACT_EXPONENT_FACTOR,\n            market\n        ));\n    }\n\n    // @dev key for the max position impact factor\n    // @param market the market address to check\n    // @return key for the max position impact factor\n    function maxPositionImpactFactorKey(address market, bool isPositive) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_POSITION_IMPACT_FACTOR,\n            market,\n            isPositive\n        ));\n    }\n\n    // @dev key for the max position impact factor for liquidations\n    // @param market the market address to check\n    // @return key for the max position impact factor\n    function maxPositionImpactFactorForLiquidationsKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_POSITION_IMPACT_FACTOR_FOR_LIQUIDATIONS,\n            market\n        ));\n    }\n\n    // @dev key for position fee factor\n    // @param market the market address to check\n    // @param forPositiveImpact whether the fee is for an action that has a positive price impact\n    // @return key for position fee factor\n    function positionFeeFactorKey(address market, bool forPositiveImpact) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            POSITION_FEE_FACTOR,\n            market,\n            forPositiveImpact\n        ));\n    }\n\n    // @dev key for swap impact factor\n    // @param market the market address to check\n    // @param isPositive whether the impact is positive or negative\n    // @return key for swap impact factor\n    function swapImpactFactorKey(address market, bool isPositive) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SWAP_IMPACT_FACTOR,\n            market,\n            isPositive\n        ));\n    }\n\n    // @dev key for swap impact exponent factor\n    // @param market the market address to check\n    // @return key for swap impact exponent factor\n    function swapImpactExponentFactorKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SWAP_IMPACT_EXPONENT_FACTOR,\n            market\n        ));\n    }\n\n\n    // @dev key for swap fee factor\n    // @param market the market address to check\n    // @return key for swap fee factor\n    function swapFeeFactorKey(address market, bool forPositiveImpact) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SWAP_FEE_FACTOR,\n            market,\n            forPositiveImpact\n        ));\n    }\n\n    // @dev key for atomic swap fee factor\n    // @param market the market address to check\n    // @return key for atomic swap fee factor\n    function atomicSwapFeeFactorKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            ATOMIC_SWAP_FEE_FACTOR,\n            market\n        ));\n    }\n\n    // @dev key for oracle type\n    // @param token the token to check\n    // @return key for oracle type\n    function oracleTypeKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            ORACLE_TYPE,\n            token\n        ));\n    }\n\n    // @dev key for open interest\n    // @param market the market to check\n    // @param collateralToken the collateralToken to check\n    // @param isLong whether to check the long or short open interest\n    // @return key for open interest\n    function openInterestKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            OPEN_INTEREST,\n            market,\n            collateralToken,\n            isLong\n        ));\n    }\n\n    // @dev key for open interest in tokens\n    // @param market the market to check\n    // @param collateralToken the collateralToken to check\n    // @param isLong whether to check the long or short open interest\n    // @return key for open interest in tokens\n    function openInterestInTokensKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            OPEN_INTEREST_IN_TOKENS,\n            market,\n            collateralToken,\n            isLong\n        ));\n    }\n\n    // @dev key for collateral sum for a market\n    // @param market the market to check\n    // @param collateralToken the collateralToken to check\n    // @param isLong whether to check the long or short open interest\n    // @return key for collateral sum\n    function collateralSumKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            COLLATERAL_SUM,\n            market,\n            collateralToken,\n            isLong\n        ));\n    }\n\n    // @dev key for amount of tokens in a market's pool\n    // @param market the market to check\n    // @param token the token to check\n    // @return key for amount of tokens in a market's pool\n    function poolAmountKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            POOL_AMOUNT,\n            market,\n            token\n        ));\n    }\n\n    // @dev the key for the max amount of pool tokens\n    // @param market the market for the pool\n    // @param token the token for the pool\n    function maxPoolAmountKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_POOL_AMOUNT,\n            market,\n            token\n        ));\n    }\n\n    // @dev the key for the max usd of pool tokens for deposits\n    // @param market the market for the pool\n    // @param token the token for the pool\n    function maxPoolUsdForDepositKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_POOL_USD_FOR_DEPOSIT,\n            market,\n            token\n        ));\n    }\n\n    // @dev the key for the max open interest\n    // @param market the market for the pool\n    // @param isLong whether the key is for the long or short side\n    function maxOpenInterestKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_OPEN_INTEREST,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for amount of tokens in a market's position impact pool\n    // @param market the market to check\n    // @return key for amount of tokens in a market's position impact pool\n    function positionImpactPoolAmountKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            POSITION_IMPACT_POOL_AMOUNT,\n            market\n        ));\n    }\n\n    // @dev key for min amount of tokens in a market's position impact pool\n    // @param market the market to check\n    // @return key for min amount of tokens in a market's position impact pool\n    function minPositionImpactPoolAmountKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MIN_POSITION_IMPACT_POOL_AMOUNT,\n            market\n        ));\n    }\n\n    // @dev key for position impact pool distribution rate\n    // @param market the market to check\n    // @return key for position impact pool distribution rate\n    function positionImpactPoolDistributionRateKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            POSITION_IMPACT_POOL_DISTRIBUTION_RATE,\n            market\n        ));\n    }\n\n    // @dev key for position impact pool distributed at\n    // @param market the market to check\n    // @return key for position impact pool distributed at\n    function positionImpactPoolDistributedAtKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            POSITION_IMPACT_POOL_DISTRIBUTED_AT,\n            market\n        ));\n    }\n\n    // @dev key for amount of tokens in a market's swap impact pool\n    // @param market the market to check\n    // @param token the token to check\n    // @return key for amount of tokens in a market's swap impact pool\n    function swapImpactPoolAmountKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SWAP_IMPACT_POOL_AMOUNT,\n            market,\n            token\n        ));\n    }\n\n    // @dev key for reserve factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for reserve factor\n    function reserveFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            RESERVE_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for open interest reserve factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for open interest reserve factor\n    function openInterestReserveFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            OPEN_INTEREST_RESERVE_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for max pnl factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for max pnl factor\n    function maxPnlFactorKey(bytes32 pnlFactorType, address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_PNL_FACTOR,\n            pnlFactorType,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev the key for min PnL factor after ADL\n    // @param market the market for the pool\n    // @param isLong whether the key is for the long or short side\n    function minPnlFactorAfterAdlKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MIN_PNL_FACTOR_AFTER_ADL,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for latest adl time\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for latest adl time\n    function latestAdlAtKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            LATEST_ADL_AT,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for whether adl is enabled\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for whether adl is enabled\n    function isAdlEnabledKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            IS_ADL_ENABLED,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for funding factor\n    // @param market the market to check\n    // @return key for funding factor\n    function fundingFactorKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FUNDING_FACTOR,\n            market\n        ));\n    }\n\n    // @dev the key for funding exponent\n    // @param market the market for the pool\n    function fundingExponentFactorKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FUNDING_EXPONENT_FACTOR,\n            market\n        ));\n    }\n\n    // @dev the key for saved funding factor\n    // @param market the market for the pool\n    function savedFundingFactorPerSecondKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SAVED_FUNDING_FACTOR_PER_SECOND,\n            market\n        ));\n    }\n\n    // @dev the key for funding increase factor\n    // @param market the market for the pool\n    function fundingIncreaseFactorPerSecondKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FUNDING_INCREASE_FACTOR_PER_SECOND,\n            market\n        ));\n    }\n\n    // @dev the key for funding decrease factor\n    // @param market the market for the pool\n    function fundingDecreaseFactorPerSecondKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FUNDING_DECREASE_FACTOR_PER_SECOND,\n            market\n        ));\n    }\n\n    // @dev the key for min funding factor\n    // @param market the market for the pool\n    function minFundingFactorPerSecondKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MIN_FUNDING_FACTOR_PER_SECOND,\n            market\n        ));\n    }\n\n    // @dev the key for max funding factor\n    // @param market the market for the pool\n    function maxFundingFactorPerSecondKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_FUNDING_FACTOR_PER_SECOND,\n            market\n        ));\n    }\n\n    // @dev the key for threshold for stable funding\n    // @param market the market for the pool\n    function thresholdForStableFundingKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            THRESHOLD_FOR_STABLE_FUNDING,\n            market\n        ));\n    }\n\n    // @dev the key for threshold for decreasing funding\n    // @param market the market for the pool\n    function thresholdForDecreaseFundingKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            THRESHOLD_FOR_DECREASE_FUNDING,\n            market\n        ));\n    }\n\n    // @dev key for funding fee amount per size\n    // @param market the market to check\n    // @param collateralToken the collateralToken to get the key for\n    // @param isLong whether to get the key for the long or short side\n    // @return key for funding fee amount per size\n    function fundingFeeAmountPerSizeKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FUNDING_FEE_AMOUNT_PER_SIZE,\n            market,\n            collateralToken,\n            isLong\n        ));\n    }\n\n    // @dev key for claimabel funding amount per size\n    // @param market the market to check\n    // @param collateralToken the collateralToken to get the key for\n    // @param isLong whether to get the key for the long or short side\n    // @return key for claimable funding amount per size\n    function claimableFundingAmountPerSizeKey(address market, address collateralToken, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMABLE_FUNDING_AMOUNT_PER_SIZE,\n            market,\n            collateralToken,\n            isLong\n        ));\n    }\n\n    // @dev key for when funding was last updated\n    // @param market the market to check\n    // @return key for when funding was last updated\n    function fundingUpdatedAtKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FUNDING_UPDATED_AT,\n            market\n        ));\n    }\n\n    // @dev key for claimable funding amount\n    // @param market the market to check\n    // @param token the token to check\n    // @return key for claimable funding amount\n    function claimableFundingAmountKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMABLE_FUNDING_AMOUNT,\n            market,\n            token\n        ));\n    }\n\n    // @dev key for claimable funding amount by account\n    // @param market the market to check\n    // @param token the token to check\n    // @param account the account to check\n    // @return key for claimable funding amount\n    function claimableFundingAmountKey(address market, address token, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMABLE_FUNDING_AMOUNT,\n            market,\n            token,\n            account\n        ));\n    }\n\n    // @dev key for claimable collateral amount\n    // @param market the market to check\n    // @param token the token to check\n    // @param account the account to check\n    // @param timeKey the time key for the claimable amount\n    // @return key for claimable funding amount\n    function claimableCollateralAmountKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMABLE_COLLATERAL_AMOUNT,\n            market,\n            token\n        ));\n    }\n\n    // @dev key for claimable collateral amount for a timeKey for an account\n    // @param market the market to check\n    // @param token the token to check\n    // @param account the account to check\n    // @param timeKey the time key for the claimable amount\n    // @return key for claimable funding amount\n    function claimableCollateralAmountKey(address market, address token, uint256 timeKey, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMABLE_COLLATERAL_AMOUNT,\n            market,\n            token,\n            timeKey,\n            account\n        ));\n    }\n\n    // @dev key for claimable collateral factor for a timeKey\n    // @param market the market to check\n    // @param token the token to check\n    // @param timeKey the time key for the claimable amount\n    // @return key for claimable funding amount\n    function claimableCollateralFactorKey(address market, address token, uint256 timeKey) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMABLE_COLLATERAL_FACTOR,\n            market,\n            token,\n            timeKey\n        ));\n    }\n\n    // @dev key for claimable collateral factor for a timeKey for an account\n    // @param market the market to check\n    // @param token the token to check\n    // @param timeKey the time key for the claimable amount\n    // @param account the account to check\n    // @return key for claimable funding amount\n    function claimableCollateralFactorKey(address market, address token, uint256 timeKey, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMABLE_COLLATERAL_FACTOR,\n            market,\n            token,\n            timeKey,\n            account\n        ));\n    }\n\n    // @dev key for claimable collateral factor\n    // @param market the market to check\n    // @param token the token to check\n    // @param account the account to check\n    // @param timeKey the time key for the claimable amount\n    // @return key for claimable funding amount\n    function claimedCollateralAmountKey(address market, address token, uint256 timeKey, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CLAIMED_COLLATERAL_AMOUNT,\n            market,\n            token,\n            timeKey,\n            account\n        ));\n    }\n\n    // @dev key for optimal usage factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for optimal usage factor\n    function optimalUsageFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            OPTIMAL_USAGE_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for base borrowing factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for base borrowing factor\n    function baseBorrowingFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            BASE_BORROWING_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for above optimal usage borrowing factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for above optimal usage borrowing factor\n    function aboveOptimalUsageBorrowingFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            ABOVE_OPTIMAL_USAGE_BORROWING_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for borrowing factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for borrowing factor\n    function borrowingFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            BORROWING_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev the key for borrowing exponent\n    // @param market the market for the pool\n    // @param isLong whether to get the key for the long or short side\n    function borrowingExponentFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            BORROWING_EXPONENT_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for cumulative borrowing factor\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for cumulative borrowing factor\n    function cumulativeBorrowingFactorKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CUMULATIVE_BORROWING_FACTOR,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for cumulative borrowing factor updated at\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for cumulative borrowing factor updated at\n    function cumulativeBorrowingFactorUpdatedAtKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            CUMULATIVE_BORROWING_FACTOR_UPDATED_AT,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for total borrowing amount\n    // @param market the market to check\n    // @param isLong whether to get the key for the long or short side\n    // @return key for total borrowing amount\n    function totalBorrowingKey(address market, bool isLong) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            TOTAL_BORROWING,\n            market,\n            isLong\n        ));\n    }\n\n    // @dev key for affiliate reward amount\n    // @param market the market to check\n    // @param token the token to get the key for\n    // @param account the account to get the key for\n    // @return key for affiliate reward amount\n    function affiliateRewardKey(address market, address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            AFFILIATE_REWARD,\n            market,\n            token\n        ));\n    }\n\n    function maxAllowedSubaccountActionCountKey(address account, address subaccount, bytes32 actionType) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MAX_ALLOWED_SUBACCOUNT_ACTION_COUNT,\n            account,\n            subaccount,\n            actionType\n        ));\n    }\n\n    function subaccountActionCountKey(address account, address subaccount, bytes32 actionType) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SUBACCOUNT_ACTION_COUNT,\n            account,\n            subaccount,\n            actionType\n        ));\n    }\n\n    function subaccountAutoTopUpAmountKey(address account, address subaccount) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            SUBACCOUNT_AUTO_TOP_UP_AMOUNT,\n            account,\n            subaccount\n        ));\n    }\n\n    // @dev key for affiliate reward amount for an account\n    // @param market the market to check\n    // @param token the token to get the key for\n    // @param account the account to get the key for\n    // @return key for affiliate reward amount\n    function affiliateRewardKey(address market, address token, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            AFFILIATE_REWARD,\n            market,\n            token,\n            account\n        ));\n    }\n\n    // @dev key for is market disabled\n    // @param market the market to check\n    // @return key for is market disabled\n    function isMarketDisabledKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            IS_MARKET_DISABLED,\n            market\n        ));\n    }\n\n    // @dev key for min market tokens for first deposit\n    // @param market the market to check\n    // @return key for min market tokens for first deposit\n    function minMarketTokensForFirstDepositKey(address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            MIN_MARKET_TOKENS_FOR_FIRST_DEPOSIT,\n            market\n        ));\n    }\n\n    // @dev key for price feed address\n    // @param token the token to get the key for\n    // @return key for price feed address\n    function priceFeedKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            PRICE_FEED,\n            token\n        ));\n    }\n\n    // @dev key for data stream feed ID\n    // @param token the token to get the key for\n    // @return key for data stream feed ID\n    function dataStreamIdKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            DATA_STREAM_ID,\n            token\n        ));\n    }\n\n    // @dev key for data stream feed multiplier\n    // @param token the token to get the key for\n    // @return key for data stream feed multiplier\n    function dataStreamMultiplierKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            DATA_STREAM_MULTIPLIER,\n            token\n        ));\n    }\n\n    // @dev key for price feed multiplier\n    // @param token the token to get the key for\n    // @return key for price feed multiplier\n    function priceFeedMultiplierKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            PRICE_FEED_MULTIPLIER,\n            token\n        ));\n    }\n\n    function priceFeedHeartbeatDurationKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            PRICE_FEED_HEARTBEAT_DURATION,\n            token\n        ));\n    }\n\n    // @dev key for stable price value\n    // @param token the token to get the key for\n    // @return key for stable price value\n    function stablePriceKey(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            STABLE_PRICE,\n            token\n        ));\n    }\n\n    // @dev key for fee distributor swap token index\n    // @param orderKey the swap order key\n    // @return key for fee distributor swap token index\n    function feeDistributorSwapTokenIndexKey(bytes32 orderKey) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FEE_DISTRIBUTOR_SWAP_TOKEN_INDEX,\n            orderKey\n        ));\n    }\n\n    // @dev key for fee distributor swap fee batch key\n    // @param orderKey the swap order key\n    // @return key for fee distributor swap fee batch key\n    function feeDistributorSwapFeeBatchKey(bytes32 orderKey) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            FEE_DISTRIBUTOR_SWAP_FEE_BATCH,\n            orderKey\n        ));\n    }\n\n    // @dev key for glv pending shift\n    // @param glv the glv for the pending shift\n    function glvPendingShiftKey(address glv) internal pure returns (bytes32) {\n        return keccak256(abi.encode(GLV_PENDING_SHIFT, glv));\n    }\n\n    function glvPendingShiftBackrefKey(bytes32 shiftKey) internal pure returns (bytes32) {\n        return keccak256(abi.encode(GLV_PENDING_SHIFT_BACKREF, shiftKey));\n    }\n\n    // @dev key for max market token balance for glv\n    // @param glv the glv to check the market token balance for\n    // @param market the market to check balance\n    function glvMaxMarketTokenBalanceUsdKey(address glv, address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(GLV_MAX_MARKET_TOKEN_BALANCE_USD, glv, market));\n    }\n\n    // @dev key for is glv market disabled\n    // @param glv the glv to check\n    // @param market the market to check\n    // @return key for is market disabled\n    function isGlvMarketDisabledKey(address glv, address market) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            IS_GLV_MARKET_DISABLED,\n            glv,\n            market\n        ));\n    }\n}\n"
    },
    "contracts/error/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nlibrary Errors {\n    // AdlHandler errors\n    error AdlNotRequired(int256 pnlToPoolFactor, uint256 maxPnlFactorForAdl);\n    error InvalidAdl(int256 nextPnlToPoolFactor, int256 pnlToPoolFactor);\n    error PnlOvercorrected(int256 nextPnlToPoolFactor, uint256 minPnlFactorForAdl);\n\n    // AdlUtils errors\n    error InvalidSizeDeltaForAdl(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\n    error AdlNotEnabled();\n\n    // AutoCancelUtils errors\n    error MaxAutoCancelOrdersExceeded(uint256 count, uint256 maxAutoCancelOrders);\n\n    // Bank errors\n    error SelfTransferNotSupported(address receiver);\n    error InvalidNativeTokenSender(address msgSender);\n\n    // BaseHandler errors\n    error RequestNotYetCancellable(uint256 requestAge, uint256 requestExpirationAge, string requestType);\n\n    // CallbackUtils errors\n    error MaxCallbackGasLimitExceeded(uint256 callbackGasLimit, uint256 maxCallbackGasLimit);\n    error InsufficientGasLeftForCallback(uint256 gasToBeForwarded, uint256 callbackGasLimit);\n\n    // Config errors\n    error InvalidBaseKey(bytes32 baseKey);\n    error ConfigValueExceedsAllowedRange(bytes32 baseKey, uint256 value);\n    error InvalidClaimableFactor(uint256 value);\n    error OracleProviderAlreadyExistsForToken(address token);\n    error PriceFeedAlreadyExistsForToken(address token);\n    error DataStreamIdAlreadyExistsForToken(address token);\n    error MaxFundingFactorPerSecondLimitExceeded(uint256 maxFundingFactorPerSecond, uint256 limit);\n\n    // Timelock errors\n    error ActionAlreadySignalled();\n    error ActionNotSignalled();\n    error SignalTimeNotYetPassed(uint256 signalTime);\n    error InvalidTimelockDelay(uint256 timelockDelay);\n    error MaxTimelockDelayExceeded(uint256 timelockDelay);\n    error InvalidFeeReceiver(address receiver);\n    error InvalidOracleSigner(address receiver);\n\n    // GlvDepositStoreUtils errors\n    error GlvDepositNotFound(bytes32 key);\n    // GlvDepositUtils errors\n    error EmptyGlvDepositAmounts();\n    error EmptyGlvDeposit();\n    // GlvUtils errors\n    error EmptyGlv(address glv);\n    error GlvUnsupportedMarket(address glv, address market);\n    error GlvDisabledMarket(address glv, address market);\n    error GlvMaxMarketTokenBalanceExceeded(address glv, address market, uint256 maxMarketTokenBalanceUsd, uint256 marketTokenBalanceUsd);\n    error GlvInsufficientMarketTokenBalance(address glv, address market, uint256 marketTokenBalance, uint256 marketTokenAmount);\n    error GlvHasPendingShift(address glv);\n    error GlvShiftNotFound(bytes32 shiftKey);\n    error GlvInvalidReceiver(address glv, address receiver);\n    error GlvInvalidCallbackContract(address glvHandler, address callbackContract);\n    error GlvMarketAlreadyExists(address glv, address market);\n    error InvalidMarketTokenPrice(address market, int256 price);\n    // GlvFactory\n    error GlvAlreadyExists(address glv);\n\n    // DepositStoreUtils errors\n    error DepositNotFound(bytes32 key);\n\n    // DepositUtils errors\n    error EmptyDeposit();\n    error EmptyDepositAmounts();\n\n    // ExecuteDepositUtils errors\n    error MinMarketTokens(uint256 received, uint256 expected);\n    error EmptyDepositAmountsAfterSwap();\n    error InvalidPoolValueForDeposit(int256 poolValue);\n    error InvalidSwapOutputToken(address outputToken, address expectedOutputToken);\n    error InvalidReceiverForFirstDeposit(address receiver, address expectedReceiver);\n    error InvalidMinMarketTokensForFirstDeposit(uint256 minMarketTokens, uint256 expectedMinMarketTokens);\n\n    // ExternalHandler errors\n    error ExternalCallFailed(bytes data);\n    error InvalidExternalCallInput(uint256 targetsLength, uint256 dataListLength);\n    error InvalidExternalReceiversInput(uint256 refundTokensLength, uint256 refundReceiversLength);\n    error InvalidExternalCallTarget(address target);\n\n    // FeeBatchStoreUtils errors\n    error FeeBatchNotFound(bytes32 key);\n\n    // FeeDistributor errors\n    error InvalidFeeBatchTokenIndex(uint256 tokenIndex, uint256 feeBatchTokensLength);\n    error InvalidAmountInForFeeBatch(uint256 amountIn, uint256 remainingAmount);\n    error InvalidSwapPathForV1(address[] path, address bridgingToken);\n\n    // GlpMigrator errors\n    error InvalidGlpAmount(uint256 totalGlpAmountToRedeem, uint256 totalGlpAmount);\n    error InvalidExecutionFeeForMigration(uint256 totalExecutionFee, uint256 msgValue);\n\n    // GlvHandler errors\n    error InvalidGlvDepositInitialShortToken(address initialLongToken, address initialShortToken);\n    error InvalidGlvDepositSwapPath(uint256 longTokenSwapPathLength, uint256 shortTokenSwapPathLength);\n    error MinGlvTokens(uint256 received, uint256 expected);\n\n    // OrderHandler errors\n    error OrderNotUpdatable(uint256 orderType);\n    error InvalidKeeperForFrozenOrder(address keeper);\n\n    // FeatureUtils errors\n    error DisabledFeature(bytes32 key);\n\n    // FeeHandler errors\n    error InvalidClaimFeesInput(uint256 marketsLength, uint256 tokensLength);\n\n    // GasUtils errors\n    error InsufficientExecutionFee(uint256 minExecutionFee, uint256 executionFee);\n    error InsufficientWntAmountForExecutionFee(uint256 wntAmount, uint256 executionFee);\n    error InsufficientExecutionGasForErrorHandling(uint256 startingGas, uint256 minHandleErrorGas);\n    error InsufficientExecutionGas(uint256 startingGas, uint256 estimatedGasLimit, uint256 minAdditionalGasForExecution);\n    error InsufficientHandleExecutionErrorGas(uint256 gas, uint256 minHandleExecutionErrorGas);\n    error InsufficientGasForCancellation(uint256 gas, uint256 minHandleExecutionErrorGas);\n\n    // MarketFactory errors\n    error MarketAlreadyExists(bytes32 salt, address existingMarketAddress);\n\n    // MarketStoreUtils errors\n    error MarketNotFound(address key);\n\n    // MarketUtils errors\n    error EmptyMarket();\n    error DisabledMarket(address market);\n    error MaxSwapPathLengthExceeded(uint256 swapPathLengh, uint256 maxSwapPathLength);\n    error InsufficientPoolAmount(uint256 poolAmount, uint256 amount);\n    error InsufficientReserve(uint256 reservedUsd, uint256 maxReservedUsd);\n    error InsufficientReserveForOpenInterest(uint256 reservedUsd, uint256 maxReservedUsd);\n    error UnableToGetOppositeToken(address inputToken, address market);\n    error UnexpectedTokenForVirtualInventory(address token, address market);\n    error EmptyMarketTokenSupply();\n    error InvalidSwapMarket(address market);\n    error UnableToGetCachedTokenPrice(address token, address market);\n    error CollateralAlreadyClaimed(uint256 adjustedClaimableAmount, uint256 claimedAmount);\n    error OpenInterestCannotBeUpdatedForSwapOnlyMarket(address market);\n    error MaxOpenInterestExceeded(uint256 openInterest, uint256 maxOpenInterest);\n    error MaxPoolAmountExceeded(uint256 poolAmount, uint256 maxPoolAmount);\n    error MaxPoolUsdForDepositExceeded(uint256 poolUsd, uint256 maxPoolUsdForDeposit);\n    error UnexpectedBorrowingFactor(uint256 positionBorrowingFactor, uint256 cumulativeBorrowingFactor);\n    error UnableToGetBorrowingFactorEmptyPoolUsd();\n    error UnableToGetFundingFactorEmptyOpenInterest();\n    error InvalidPositionMarket(address market);\n    error InvalidCollateralTokenForMarket(address market, address token);\n    error PnlFactorExceededForLongs(int256 pnlToPoolFactor, uint256 maxPnlFactor);\n    error PnlFactorExceededForShorts(int256 pnlToPoolFactor, uint256 maxPnlFactor);\n    error InvalidUiFeeFactor(uint256 uiFeeFactor, uint256 maxUiFeeFactor);\n    error EmptyAddressInMarketTokenBalanceValidation(address market, address token);\n    error InvalidMarketTokenBalance(address market, address token, uint256 balance, uint256 expectedMinBalance);\n    error InvalidMarketTokenBalanceForCollateralAmount(address market, address token, uint256 balance, uint256 collateralAmount);\n    error InvalidMarketTokenBalanceForClaimableFunding(address market, address token, uint256 balance, uint256 claimableFundingFeeAmount);\n    error UnexpectedPoolValue(int256 poolValue);\n\n    // Oracle errors\n    error SequencerDown();\n    error SequencerGraceDurationNotYetPassed(uint256 timeSinceUp, uint256 sequencerGraceDuration);\n    error EmptyValidatedPrices();\n    error InvalidOracleProvider(address provider);\n    error InvalidOracleProviderForToken(address provider, address expectedProvider);\n    error GmEmptySigner(uint256 signerIndex);\n    error InvalidOracleSetPricesProvidersParam(uint256 tokensLength, uint256 providersLength);\n    error InvalidOracleSetPricesDataParam(uint256 tokensLength, uint256 dataLength);\n    error GmInvalidBlockNumber(uint256 minOracleBlockNumber, uint256 currentBlockNumber);\n    error GmInvalidMinMaxBlockNumber(uint256 minOracleBlockNumber, uint256 maxOracleBlockNumber);\n    error EmptyDataStreamFeedId(address token);\n    error InvalidDataStreamFeedId(address token, bytes32 feedId, bytes32 expectedFeedId);\n    error InvalidDataStreamBidAsk(address token, int192 bid, int192 ask);\n    error InvalidDataStreamPrices(address token, int192 bid, int192 ask);\n    error MaxPriceAgeExceeded(uint256 oracleTimestamp, uint256 currentTimestamp);\n    error MaxOracleTimestampRangeExceeded(uint256 range, uint256 maxRange);\n    error GmMinOracleSigners(uint256 oracleSigners, uint256 minOracleSigners);\n    error GmMaxOracleSigners(uint256 oracleSigners, uint256 maxOracleSigners);\n    error BlockNumbersNotSorted(uint256 minOracleBlockNumber, uint256 prevMinOracleBlockNumber);\n    error GmMinPricesNotSorted(address token, uint256 price, uint256 prevPrice);\n    error GmMaxPricesNotSorted(address token, uint256 price, uint256 prevPrice);\n    error EmptyChainlinkPriceFeedMultiplier(address token);\n    error EmptyDataStreamMultiplier(address token);\n    error InvalidFeedPrice(address token, int256 price);\n    error ChainlinkPriceFeedNotUpdated(address token, uint256 timestamp, uint256 heartbeatDuration);\n    error GmMaxSignerIndex(uint256 signerIndex, uint256 maxSignerIndex);\n    error InvalidGmOraclePrice(address token);\n    error InvalidGmSignerMinMaxPrice(uint256 minPrice, uint256 maxPrice);\n    error InvalidGmMedianMinMaxPrice(uint256 minPrice, uint256 maxPrice);\n    error NonEmptyTokensWithPrices(uint256 tokensWithPricesLength);\n    error InvalidMinMaxForPrice(address token, uint256 min, uint256 max);\n    error EmptyChainlinkPriceFeed(address token);\n    error PriceAlreadySet(address token, uint256 minPrice, uint256 maxPrice);\n    error MaxRefPriceDeviationExceeded(\n        address token,\n        uint256 price,\n        uint256 refPrice,\n        uint256 maxRefPriceDeviationFactor\n    );\n    error InvalidBlockRangeSet(uint256 largestMinBlockNumber, uint256 smallestMaxBlockNumber);\n    error EmptyChainlinkPaymentToken();\n    error NonAtomicOracleProvider(address provider);\n\n    // OracleModule errors\n    error InvalidPrimaryPricesForSimulation(uint256 primaryTokensLength, uint256 primaryPricesLength);\n    error EndOfOracleSimulation();\n\n    // OracleUtils errors\n    error InvalidGmSignature(address recoveredSigner, address expectedSigner);\n\n    error EmptyPrimaryPrice(address token);\n\n    error OracleTimestampsAreSmallerThanRequired(uint256 minOracleTimestamp, uint256 expectedTimestamp);\n    error OracleTimestampsAreLargerThanRequestExpirationTime(uint256 maxOracleTimestamp, uint256 requestTimestamp, uint256 requestExpirationTime);\n\n    // BaseOrderUtils errors\n    error EmptyOrder();\n    error UnsupportedOrderType(uint256 orderType);\n    error InvalidOrderPrices(\n        uint256 primaryPriceMin,\n        uint256 primaryPriceMax,\n        uint256 triggerPrice,\n        uint256 orderType\n    );\n    error EmptySizeDeltaInTokens();\n    error PriceImpactLargerThanOrderSize(int256 priceImpactUsd, uint256 sizeDeltaUsd);\n    error NegativeExecutionPrice(int256 executionPrice, uint256 price, uint256 positionSizeInUsd, int256 priceImpactUsd, uint256 sizeDeltaUsd);\n    error OrderNotFulfillableAtAcceptablePrice(uint256 price, uint256 acceptablePrice);\n\n    // IncreaseOrderUtils errors\n    error UnexpectedPositionState();\n\n    // OrderUtils errors\n    error OrderTypeCannotBeCreated(uint256 orderType);\n    error OrderAlreadyFrozen();\n    error MaxTotalCallbackGasLimitForAutoCancelOrdersExceeded(uint256 totalCallbackGasLimit, uint256 maxTotalCallbackGasLimit);\n    error InvalidReceiver(address receiver);\n\n    // OrderStoreUtils errors\n    error OrderNotFound(bytes32 key);\n\n    // SwapOrderUtils errors\n    error UnexpectedMarket();\n\n    // DecreasePositionCollateralUtils errors\n    error InsufficientFundsToPayForCosts(uint256 remainingCostUsd, string step);\n    error InvalidOutputToken(address tokenOut, address expectedTokenOut);\n\n    // DecreasePositionUtils errors\n    error InvalidDecreaseOrderSize(uint256 sizeDeltaUsd, uint256 positionSizeInUsd);\n    error UnableToWithdrawCollateral(int256 estimatedRemainingCollateralUsd);\n    error InvalidDecreasePositionSwapType(uint256 decreasePositionSwapType);\n    error PositionShouldNotBeLiquidated(\n        string reason,\n        int256 remainingCollateralUsd,\n        int256 minCollateralUsd,\n        int256 minCollateralUsdForLeverage\n    );\n\n    // IncreasePositionUtils errors\n    error InsufficientCollateralAmount(uint256 collateralAmount, int256 collateralDeltaAmount);\n    error InsufficientCollateralUsd(int256 remainingCollateralUsd);\n\n    // PositionStoreUtils errors\n    error PositionNotFound(bytes32 key);\n\n    // PositionUtils errors\n    error LiquidatablePosition(\n        string reason,\n        int256 remainingCollateralUsd,\n        int256 minCollateralUsd,\n        int256 minCollateralUsdForLeverage\n    );\n\n    error EmptyPosition();\n    error InvalidPositionSizeValues(uint256 sizeInUsd, uint256 sizeInTokens);\n    error MinPositionSize(uint256 positionSizeInUsd, uint256 minPositionSizeUsd);\n\n    // PositionPricingUtils errors\n    error UsdDeltaExceedsLongOpenInterest(int256 usdDelta, uint256 longOpenInterest);\n    error UsdDeltaExceedsShortOpenInterest(int256 usdDelta, uint256 shortOpenInterest);\n\n    // ShiftStoreUtils errors\n    error ShiftNotFound(bytes32 key);\n\n    // ShiftUtils errors\n    error EmptyShift();\n    error EmptyShiftAmount();\n    error ShiftFromAndToMarketAreEqual(address market);\n    error LongTokensAreNotEqual(address fromMarketLongToken, address toMarketLongToken);\n    error ShortTokensAreNotEqual(address fromMarketLongToken, address toMarketLongToken);\n\n    // SwapPricingUtils errors\n    error UsdDeltaExceedsPoolValue(int256 usdDelta, uint256 poolUsd);\n\n    // RoleModule errors\n    error Unauthorized(address msgSender, string role);\n\n    // RoleStore errors\n    error ThereMustBeAtLeastOneRoleAdmin();\n    error ThereMustBeAtLeastOneTimelockMultiSig();\n\n    // ExchangeRouter errors\n    error InvalidClaimFundingFeesInput(uint256 marketsLength, uint256 tokensLength);\n    error InvalidClaimCollateralInput(uint256 marketsLength, uint256 tokensLength, uint256 timeKeysLength);\n    error InvalidClaimAffiliateRewardsInput(uint256 marketsLength, uint256 tokensLength);\n    error InvalidClaimUiFeesInput(uint256 marketsLength, uint256 tokensLength);\n\n    // SwapUtils errors\n    error InvalidTokenIn(address tokenIn, address market);\n    error InsufficientOutputAmount(uint256 outputAmount, uint256 minOutputAmount);\n    error InsufficientSwapOutputAmount(uint256 outputAmount, uint256 minOutputAmount);\n    error DuplicatedMarketInSwapPath(address market);\n    error SwapPriceImpactExceedsAmountIn(uint256 amountAfterFees, int256 negativeImpactAmount);\n\n    // SubaccountRouter errors\n    error InvalidReceiverForSubaccountOrder(address receiver, address expectedReceiver);\n\n    // SubaccountUtils errors\n    error SubaccountNotAuthorized(address account, address subaccount);\n    error MaxSubaccountActionCountExceeded(address account, address subaccount, uint256 count, uint256 maxCount);\n\n    // TokenUtils errors\n    error EmptyTokenTranferGasLimit(address token);\n    error TokenTransferError(address token, address receiver, uint256 amount);\n    error EmptyHoldingAddress();\n\n    // AccountUtils errors\n    error EmptyAccount();\n    error EmptyReceiver();\n\n    // Array errors\n    error CompactedArrayOutOfBounds(\n        uint256[] compactedValues,\n        uint256 index,\n        uint256 slotIndex,\n        string label\n    );\n\n    error ArrayOutOfBoundsUint256(\n        uint256[] values,\n        uint256 index,\n        string label\n    );\n\n    error ArrayOutOfBoundsBytes(\n        bytes[] values,\n        uint256 index,\n        string label\n    );\n\n    // WithdrawalHandler errors\n    error SwapsNotAllowedForAtomicWithdrawal(uint256 longTokenSwapPathLength, uint256 shortTokenSwapPathLength);\n\n    // WithdrawalStoreUtils errors\n    error WithdrawalNotFound(bytes32 key);\n\n    // WithdrawalUtils errors\n    error EmptyWithdrawal();\n    error EmptyWithdrawalAmount();\n    error MinLongTokens(uint256 received, uint256 expected);\n    error MinShortTokens(uint256 received, uint256 expected);\n    error InsufficientMarketTokens(uint256 balance, uint256 expected);\n    error InsufficientWntAmount(uint256 wntAmount, uint256 executionFee);\n    error InvalidPoolValueForWithdrawal(int256 poolValue);\n\n    // Uint256Mask errors\n    error MaskIndexOutOfBounds(uint256 index, string label);\n    error DuplicatedIndex(uint256 index, string label);\n}\n"
    },
    "contracts/error/ErrorUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nlibrary ErrorUtils {\n    // To get the revert reason, referenced from https://ethereum.stackexchange.com/a/83577\n    function getRevertMessage(bytes memory result) internal pure returns (string memory, bool) {\n        // If the result length is less than 68, then the transaction either panicked or failed silently\n        if (result.length < 68) {\n            return (\"\", false);\n        }\n\n        bytes4 errorSelector = getErrorSelectorFromData(result);\n\n        // 0x08c379a0 is the selector for Error(string)\n        // referenced from https://blog.soliditylang.org/2021/04/21/custom-errors/\n        if (errorSelector == bytes4(0x08c379a0)) {\n            assembly {\n                result := add(result, 0x04)\n            }\n\n            return (abi.decode(result, (string)), true);\n        }\n\n        // error may be a custom error, return an empty string for this case\n        return (\"\", false);\n    }\n\n    function getErrorSelectorFromData(bytes memory data) internal pure returns (bytes4) {\n        bytes4 errorSelector;\n\n        assembly {\n            errorSelector := mload(add(data, 0x20))\n        }\n\n        return errorSelector;\n    }\n\n    function revertWithParsedMessage(bytes memory result) internal pure {\n        (string memory revertMessage, bool hasRevertMessage) = getRevertMessage(result);\n\n        if (hasRevertMessage) {\n            revert(revertMessage);\n        } else {\n            revertWithCustomError(result);\n        }\n    }\n\n    function revertWithCustomError(bytes memory result) internal pure {\n        // referenced from https://ethereum.stackexchange.com/a/123588\n        uint256 length = result.length;\n        assembly {\n            revert(add(result, 0x20), length)\n        }\n    }\n}\n"
    },
    "contracts/event/EventEmitter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../role/RoleModule.sol\";\nimport \"./EventUtils.sol\";\n\n// @title EventEmitter\n// @dev Contract to emit events\n// This allows main events to be emitted from a single contract\n// Logic contracts can be updated while re-using the same eventEmitter contract\n// Peripheral services like monitoring or analytics would be able to continue\n// to work without an update and without segregating historical data\ncontract EventEmitter is RoleModule {\n    event EventLog(\n        address msgSender,\n        string eventName,\n        string indexed eventNameHash,\n        EventUtils.EventLogData eventData\n    );\n\n    event EventLog1(\n        address msgSender,\n        string eventName,\n        string indexed eventNameHash,\n        bytes32 indexed topic1,\n        EventUtils.EventLogData eventData\n    );\n\n    event EventLog2(\n        address msgSender,\n        string eventName,\n        string indexed eventNameHash,\n        bytes32 indexed topic1,\n        bytes32 indexed topic2,\n        EventUtils.EventLogData eventData\n    );\n\n    constructor(RoleStore _roleStore) RoleModule(_roleStore) {}\n\n    // @dev emit a general event log\n    // @param eventName the name of the event\n    // @param eventData the event data\n    function emitEventLog(\n        string memory eventName,\n        EventUtils.EventLogData memory eventData\n    ) external onlyController {\n        emit EventLog(\n            msg.sender,\n            eventName,\n            eventName,\n            eventData\n        );\n    }\n\n    // @dev emit a general event log\n    // @param eventName the name of the event\n    // @param topic1 topic1 for indexing\n    // @param eventData the event data\n    function emitEventLog1(\n        string memory eventName,\n        bytes32 topic1,\n        EventUtils.EventLogData memory eventData\n    ) external onlyController {\n        emit EventLog1(\n            msg.sender,\n            eventName,\n            eventName,\n            topic1,\n            eventData\n        );\n    }\n\n    // @dev emit a general event log\n    // @param eventName the name of the event\n    // @param topic1 topic1 for indexing\n    // @param topic2 topic2 for indexing\n    // @param eventData the event data\n    function emitEventLog2(\n        string memory eventName,\n        bytes32 topic1,\n        bytes32 topic2,\n        EventUtils.EventLogData memory eventData\n    ) external onlyController {\n        emit EventLog2(\n            msg.sender,\n            eventName,\n            eventName,\n            topic1,\n            topic2,\n            eventData\n        );\n    }\n    // @dev event log for general use\n    // @param topic1 event topic 1\n    // @param data additional data\n    function emitDataLog1(bytes32 topic1, bytes memory data) external onlyController {\n        uint256 len = data.length;\n        assembly {\n            log1(add(data, 32), len, topic1)\n        }\n    }\n\n    // @dev event log for general use\n    // @param topic1 event topic 1\n    // @param topic2 event topic 2\n    // @param data additional data\n    function emitDataLog2(bytes32 topic1, bytes32 topic2, bytes memory data) external onlyController {\n        uint256 len = data.length;\n        assembly {\n            log2(add(data, 32), len, topic1, topic2)\n        }\n    }\n\n    // @dev event log for general use\n    // @param topic1 event topic 1\n    // @param topic2 event topic 2\n    // @param topic3 event topic 3\n    // @param data additional data\n    function emitDataLog3(bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes memory data) external onlyController {\n        uint256 len = data.length;\n        assembly {\n            log3(add(data, 32), len, topic1, topic2, topic3)\n        }\n    }\n\n    // @dev event log for general use\n    // @param topic1 event topic 1\n    // @param topic2 event topic 2\n    // @param topic3 event topic 3\n    // @param topic4 event topic 4\n    // @param data additional data\n    function emitDataLog4(bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4, bytes memory data) external onlyController {\n        uint256 len = data.length;\n        assembly {\n            log4(add(data, 32), len, topic1, topic2, topic3, topic4)\n        }\n    }\n}\n"
    },
    "contracts/event/EventUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nlibrary EventUtils {\n    struct EmitPositionDecreaseParams {\n        bytes32 key;\n        address account;\n        address market;\n        address collateralToken;\n        bool isLong;\n    }\n\n    struct EventLogData {\n        AddressItems addressItems;\n        UintItems uintItems;\n        IntItems intItems;\n        BoolItems boolItems;\n        Bytes32Items bytes32Items;\n        BytesItems bytesItems;\n        StringItems stringItems;\n    }\n\n    struct AddressItems {\n        AddressKeyValue[] items;\n        AddressArrayKeyValue[] arrayItems;\n    }\n\n    struct UintItems {\n        UintKeyValue[] items;\n        UintArrayKeyValue[] arrayItems;\n    }\n\n    struct IntItems {\n        IntKeyValue[] items;\n        IntArrayKeyValue[] arrayItems;\n    }\n\n    struct BoolItems {\n        BoolKeyValue[] items;\n        BoolArrayKeyValue[] arrayItems;\n    }\n\n    struct Bytes32Items {\n        Bytes32KeyValue[] items;\n        Bytes32ArrayKeyValue[] arrayItems;\n    }\n\n    struct BytesItems {\n        BytesKeyValue[] items;\n        BytesArrayKeyValue[] arrayItems;\n    }\n\n    struct StringItems {\n        StringKeyValue[] items;\n        StringArrayKeyValue[] arrayItems;\n    }\n\n    struct AddressKeyValue {\n        string key;\n        address value;\n    }\n\n    struct AddressArrayKeyValue {\n        string key;\n        address[] value;\n    }\n\n    struct UintKeyValue {\n        string key;\n        uint256 value;\n    }\n\n    struct UintArrayKeyValue {\n        string key;\n        uint256[] value;\n    }\n\n    struct IntKeyValue {\n        string key;\n        int256 value;\n    }\n\n    struct IntArrayKeyValue {\n        string key;\n        int256[] value;\n    }\n\n    struct BoolKeyValue {\n        string key;\n        bool value;\n    }\n\n    struct BoolArrayKeyValue {\n        string key;\n        bool[] value;\n    }\n\n    struct Bytes32KeyValue {\n        string key;\n        bytes32 value;\n    }\n\n    struct Bytes32ArrayKeyValue {\n        string key;\n        bytes32[] value;\n    }\n\n    struct BytesKeyValue {\n        string key;\n        bytes value;\n    }\n\n    struct BytesArrayKeyValue {\n        string key;\n        bytes[] value;\n    }\n\n    struct StringKeyValue {\n        string key;\n        string value;\n    }\n\n    struct StringArrayKeyValue {\n        string key;\n        string[] value;\n    }\n\n    function initItems(AddressItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.AddressKeyValue[](size);\n    }\n\n    function initArrayItems(AddressItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.AddressArrayKeyValue[](size);\n    }\n\n    function setItem(AddressItems memory items, uint256 index, string memory key, address value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(AddressItems memory items, uint256 index, string memory key, address[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(UintItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.UintKeyValue[](size);\n    }\n\n    function initArrayItems(UintItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.UintArrayKeyValue[](size);\n    }\n\n    function setItem(UintItems memory items, uint256 index, string memory key, uint256 value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(UintItems memory items, uint256 index, string memory key, uint256[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(IntItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.IntKeyValue[](size);\n    }\n\n    function initArrayItems(IntItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.IntArrayKeyValue[](size);\n    }\n\n    function setItem(IntItems memory items, uint256 index, string memory key, int256 value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(IntItems memory items, uint256 index, string memory key, int256[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(BoolItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.BoolKeyValue[](size);\n    }\n\n    function initArrayItems(BoolItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.BoolArrayKeyValue[](size);\n    }\n\n    function setItem(BoolItems memory items, uint256 index, string memory key, bool value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(BoolItems memory items, uint256 index, string memory key, bool[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(Bytes32Items memory items, uint256 size) internal pure {\n        items.items = new EventUtils.Bytes32KeyValue[](size);\n    }\n\n    function initArrayItems(Bytes32Items memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.Bytes32ArrayKeyValue[](size);\n    }\n\n    function setItem(Bytes32Items memory items, uint256 index, string memory key, bytes32 value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(Bytes32Items memory items, uint256 index, string memory key, bytes32[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(BytesItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.BytesKeyValue[](size);\n    }\n\n    function initArrayItems(BytesItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.BytesArrayKeyValue[](size);\n    }\n\n    function setItem(BytesItems memory items, uint256 index, string memory key, bytes memory value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(BytesItems memory items, uint256 index, string memory key, bytes[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(StringItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.StringKeyValue[](size);\n    }\n\n    function initArrayItems(StringItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.StringArrayKeyValue[](size);\n    }\n\n    function setItem(StringItems memory items, uint256 index, string memory key, string memory value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(StringItems memory items, uint256 index, string memory key, string[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n}\n"
    },
    "contracts/order/AutoCancelUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/Keys.sol\";\nimport \"../data/DataStore.sol\";\nimport \"../error/Errors.sol\";\n\nlibrary AutoCancelUtils {\n    function addAutoCancelOrderKey(DataStore dataStore, bytes32 positionKey, bytes32 orderKey) internal {\n        bytes32 listKey = Keys.autoCancelOrderListKey(positionKey);\n        uint256 maxAutoCancelOrders = getMaxAutoCancelOrders(dataStore);\n        uint256 count = dataStore.getBytes32Count(listKey);\n        if (count >= maxAutoCancelOrders) {\n            revert Errors.MaxAutoCancelOrdersExceeded(count, maxAutoCancelOrders);\n        }\n\n        dataStore.addBytes32(listKey, orderKey);\n    }\n\n    function removeAutoCancelOrderKey(DataStore dataStore, bytes32 positionKey, bytes32 orderKey) internal {\n        bytes32 listKey = Keys.autoCancelOrderListKey(positionKey);\n        dataStore.removeBytes32(listKey, orderKey);\n    }\n\n    function getAutoCancelOrderKeys(DataStore dataStore, bytes32 positionKey) internal view returns (bytes32[] memory) {\n        bytes32 listKey = Keys.autoCancelOrderListKey(positionKey);\n        uint256 maxAutoCancelOrders = getMaxAutoCancelOrders(dataStore);\n        return dataStore.getBytes32ValuesAt(listKey, 0, maxAutoCancelOrders);\n    }\n\n    function getMaxAutoCancelOrders(DataStore dataStore) internal view returns (uint256) {\n        return dataStore.getUint(Keys.MAX_AUTO_CANCEL_ORDERS);\n    }\n}\n"
    },
    "contracts/order/Order.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../chain/Chain.sol\";\n\n// @title Order\n// @dev Struct for orders\nlibrary Order {\n    using Order for Props;\n\n    enum OrderType {\n        // @dev MarketSwap: swap token A to token B at the current market price\n        // the order will be cancelled if the minOutputAmount cannot be fulfilled\n        MarketSwap,\n        // @dev LimitSwap: swap token A to token B if the minOutputAmount can be fulfilled\n        LimitSwap,\n        // @dev MarketIncrease: increase position at the current market price\n        // the order will be cancelled if the position cannot be increased at the acceptablePrice\n        MarketIncrease,\n        // @dev LimitIncrease: increase position if the triggerPrice is reached and the acceptablePrice can be fulfilled\n        LimitIncrease,\n        // @dev MarketDecrease: decrease position at the current market price\n        // the order will be cancelled if the position cannot be decreased at the acceptablePrice\n        MarketDecrease,\n        // @dev LimitDecrease: decrease position if the triggerPrice is reached and the acceptablePrice can be fulfilled\n        LimitDecrease,\n        // @dev StopLossDecrease: decrease position if the triggerPrice is reached and the acceptablePrice can be fulfilled\n        StopLossDecrease,\n        // @dev Liquidation: allows liquidation of positions if the criteria for liquidation are met\n        Liquidation\n    }\n\n    // to help further differentiate orders\n    enum SecondaryOrderType {\n        None,\n        Adl\n    }\n\n    enum DecreasePositionSwapType {\n        NoSwap,\n        SwapPnlTokenToCollateralToken,\n        SwapCollateralTokenToPnlToken\n    }\n\n    // @dev there is a limit on the number of fields a struct can have when being passed\n    // or returned as a memory variable which can cause \"Stack too deep\" errors\n    // use sub-structs to avoid this issue\n    // @param addresses address values\n    // @param numbers number values\n    // @param flags boolean values\n    struct Props {\n        Addresses addresses;\n        Numbers numbers;\n        Flags flags;\n    }\n\n    // @param account the account of the order\n    // @param receiver the receiver for any token transfers\n    // this field is meant to allow the output of an order to be\n    // received by an address that is different from the creator of the\n    // order whether this is for swaps or whether the account is the owner\n    // of a position\n    // for funding fees and claimable collateral, the funds are still\n    // credited to the owner of the position indicated by order.account\n    // @param callbackContract the contract to call for callbacks\n    // @param uiFeeReceiver the ui fee receiver\n    // @param market the trading market\n    // @param initialCollateralToken for increase orders, initialCollateralToken\n    // is the token sent in by the user, the token will be swapped through the\n    // specified swapPath, before being deposited into the position as collateral\n    // for decrease orders, initialCollateralToken is the collateral token of the position\n    // withdrawn collateral from the decrease of the position will be swapped\n    // through the specified swapPath\n    // for swaps, initialCollateralToken is the initial token sent for the swap\n    // @param swapPath an array of market addresses to swap through\n    struct Addresses {\n        address account;\n        address receiver;\n        address cancellationReceiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialCollateralToken;\n        address[] swapPath;\n    }\n\n    // @param sizeDeltaUsd the requested change in position size\n    // @param initialCollateralDeltaAmount for increase orders, initialCollateralDeltaAmount\n    // is the amount of the initialCollateralToken sent in by the user\n    // for decrease orders, initialCollateralDeltaAmount is the amount of the position's\n    // collateralToken to withdraw\n    // for swaps, initialCollateralDeltaAmount is the amount of initialCollateralToken sent\n    // in for the swap\n    // @param orderType the order type\n    // @param triggerPrice the trigger price for non-market orders\n    // @param acceptablePrice the acceptable execution price for increase / decrease orders\n    // @param executionFee the execution fee for keepers\n    // @param callbackGasLimit the gas limit for the callbackContract\n    // @param minOutputAmount the minimum output amount for decrease orders and swaps\n    // note that for decrease orders, multiple tokens could be received, for this reason, the\n    // minOutputAmount value is treated as a USD value for validation in decrease orders\n    // @param updatedAtBlock the block at which the order was last updated\n    struct Numbers {\n        OrderType orderType;\n        DecreasePositionSwapType decreasePositionSwapType;\n        uint256 sizeDeltaUsd;\n        uint256 initialCollateralDeltaAmount;\n        uint256 triggerPrice;\n        uint256 acceptablePrice;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n        uint256 minOutputAmount;\n        uint256 updatedAtBlock;\n        uint256 updatedAtTime;\n    }\n\n    // @param isLong whether the order is for a long or short\n    // @param shouldUnwrapNativeToken whether to unwrap native tokens before\n    // transferring to the user\n    // @param isFrozen whether the order is frozen\n    struct Flags {\n        bool isLong;\n        bool shouldUnwrapNativeToken;\n        bool isFrozen;\n        bool autoCancel;\n    }\n\n    // @dev the order account\n    // @param props Props\n    // @return the order account\n    function account(Props memory props) internal pure returns (address) {\n        return props.addresses.account;\n    }\n\n    // @dev set the order account\n    // @param props Props\n    // @param value the value to set to\n    function setAccount(Props memory props, address value) internal pure {\n        props.addresses.account = value;\n    }\n\n    // @dev the order receiver\n    // @param props Props\n    // @return the order receiver\n    function receiver(Props memory props) internal pure returns (address) {\n        return props.addresses.receiver;\n    }\n\n    // @dev set the order receiver\n    // @param props Props\n    // @param value the value to set to\n    function setReceiver(Props memory props, address value) internal pure {\n        props.addresses.receiver = value;\n    }\n\n    function cancellationReceiver(Props memory props) internal pure returns (address) {\n        return props.addresses.cancellationReceiver;\n    }\n\n    function setCancellationReceiver(Props memory props, address value) internal pure {\n        props.addresses.cancellationReceiver = value;\n    }\n\n    // @dev the order callbackContract\n    // @param props Props\n    // @return the order callbackContract\n    function callbackContract(Props memory props) internal pure returns (address) {\n        return props.addresses.callbackContract;\n    }\n\n    // @dev set the order callbackContract\n    // @param props Props\n    // @param value the value to set to\n    function setCallbackContract(Props memory props, address value) internal pure {\n        props.addresses.callbackContract = value;\n    }\n\n    // @dev the order market\n    // @param props Props\n    // @return the order market\n    function market(Props memory props) internal pure returns (address) {\n        return props.addresses.market;\n    }\n\n    // @dev set the order market\n    // @param props Props\n    // @param value the value to set to\n    function setMarket(Props memory props, address value) internal pure {\n        props.addresses.market = value;\n    }\n\n    // @dev the order initialCollateralToken\n    // @param props Props\n    // @return the order initialCollateralToken\n    function initialCollateralToken(Props memory props) internal pure returns (address) {\n        return props.addresses.initialCollateralToken;\n    }\n\n    // @dev set the order initialCollateralToken\n    // @param props Props\n    // @param value the value to set to\n    function setInitialCollateralToken(Props memory props, address value) internal pure {\n        props.addresses.initialCollateralToken = value;\n    }\n\n    // @dev the order uiFeeReceiver\n    // @param props Props\n    // @return the order uiFeeReceiver\n    function uiFeeReceiver(Props memory props) internal pure returns (address) {\n        return props.addresses.uiFeeReceiver;\n    }\n\n    // @dev set the order uiFeeReceiver\n    // @param props Props\n    // @param value the value to set to\n    function setUiFeeReceiver(Props memory props, address value) internal pure {\n        props.addresses.uiFeeReceiver = value;\n    }\n\n    // @dev the order swapPath\n    // @param props Props\n    // @return the order swapPath\n    function swapPath(Props memory props) internal pure returns (address[] memory) {\n        return props.addresses.swapPath;\n    }\n\n    // @dev set the order swapPath\n    // @param props Props\n    // @param value the value to set to\n    function setSwapPath(Props memory props, address[] memory value) internal pure {\n        props.addresses.swapPath = value;\n    }\n\n    // @dev the order type\n    // @param props Props\n    // @return the order type\n    function orderType(Props memory props) internal pure returns (OrderType) {\n        return props.numbers.orderType;\n    }\n\n    // @dev set the order type\n    // @param props Props\n    // @param value the value to set to\n    function setOrderType(Props memory props, OrderType value) internal pure {\n        props.numbers.orderType = value;\n    }\n\n    function decreasePositionSwapType(Props memory props) internal pure returns (DecreasePositionSwapType) {\n        return props.numbers.decreasePositionSwapType;\n    }\n\n    function setDecreasePositionSwapType(Props memory props, DecreasePositionSwapType value) internal pure {\n        props.numbers.decreasePositionSwapType = value;\n    }\n\n    // @dev the order sizeDeltaUsd\n    // @param props Props\n    // @return the order sizeDeltaUsd\n    function sizeDeltaUsd(Props memory props) internal pure returns (uint256) {\n        return props.numbers.sizeDeltaUsd;\n    }\n\n    // @dev set the order sizeDeltaUsd\n    // @param props Props\n    // @param value the value to set to\n    function setSizeDeltaUsd(Props memory props, uint256 value) internal pure {\n        props.numbers.sizeDeltaUsd = value;\n    }\n\n    // @dev the order initialCollateralDeltaAmount\n    // @param props Props\n    // @return the order initialCollateralDeltaAmount\n    function initialCollateralDeltaAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.initialCollateralDeltaAmount;\n    }\n\n    // @dev set the order initialCollateralDeltaAmount\n    // @param props Props\n    // @param value the value to set to\n    function setInitialCollateralDeltaAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.initialCollateralDeltaAmount = value;\n    }\n\n    // @dev the order triggerPrice\n    // @param props Props\n    // @return the order triggerPrice\n    function triggerPrice(Props memory props) internal pure returns (uint256) {\n        return props.numbers.triggerPrice;\n    }\n\n    // @dev set the order triggerPrice\n    // @param props Props\n    // @param value the value to set to\n    function setTriggerPrice(Props memory props, uint256 value) internal pure {\n        props.numbers.triggerPrice = value;\n    }\n\n    // @dev the order acceptablePrice\n    // @param props Props\n    // @return the order acceptablePrice\n    function acceptablePrice(Props memory props) internal pure returns (uint256) {\n        return props.numbers.acceptablePrice;\n    }\n\n    // @dev set the order acceptablePrice\n    // @param props Props\n    // @param value the value to set to\n    function setAcceptablePrice(Props memory props, uint256 value) internal pure {\n        props.numbers.acceptablePrice = value;\n    }\n\n    // @dev set the order executionFee\n    // @param props Props\n    // @param value the value to set to\n    function setExecutionFee(Props memory props, uint256 value) internal pure {\n        props.numbers.executionFee = value;\n    }\n\n    // @dev the order executionFee\n    // @param props Props\n    // @return the order executionFee\n    function executionFee(Props memory props) internal pure returns (uint256) {\n        return props.numbers.executionFee;\n    }\n\n    // @dev the order callbackGasLimit\n    // @param props Props\n    // @return the order callbackGasLimit\n    function callbackGasLimit(Props memory props) internal pure returns (uint256) {\n        return props.numbers.callbackGasLimit;\n    }\n\n    // @dev set the order callbackGasLimit\n    // @param props Props\n    // @param value the value to set to\n    function setCallbackGasLimit(Props memory props, uint256 value) internal pure {\n        props.numbers.callbackGasLimit = value;\n    }\n\n    // @dev the order minOutputAmount\n    // @param props Props\n    // @return the order minOutputAmount\n    function minOutputAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.minOutputAmount;\n    }\n\n    // @dev set the order minOutputAmount\n    // @param props Props\n    // @param value the value to set to\n    function setMinOutputAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.minOutputAmount = value;\n    }\n\n    // @dev the order updatedAtBlock\n    // @param props Props\n    // @return the order updatedAtBlock\n    function updatedAtBlock(Props memory props) internal pure returns (uint256) {\n        return props.numbers.updatedAtBlock;\n    }\n\n    // @dev set the order updatedAtBlock\n    // @param props Props\n    // @param value the value to set to\n    function setUpdatedAtBlock(Props memory props, uint256 value) internal pure {\n        props.numbers.updatedAtBlock = value;\n    }\n\n    // @dev the order updatedAtTime\n    // @param props Props\n    // @return the order updatedAtTime\n    function updatedAtTime(Props memory props) internal pure returns (uint256) {\n        return props.numbers.updatedAtTime;\n    }\n\n    // @dev set the order updatedAtTime\n    // @param props Props\n    // @param value the value to set to\n    function setUpdatedAtTime(Props memory props, uint256 value) internal pure {\n        props.numbers.updatedAtTime = value;\n    }\n\n    // @dev whether the order is for a long or short\n    // @param props Props\n    // @return whether the order is for a long or short\n    function isLong(Props memory props) internal pure returns (bool) {\n        return props.flags.isLong;\n    }\n\n    // @dev set whether the order is for a long or short\n    // @param props Props\n    // @param value the value to set to\n    function setIsLong(Props memory props, bool value) internal pure {\n        props.flags.isLong = value;\n    }\n\n    // @dev whether to unwrap the native token before transfers to the user\n    // @param props Props\n    // @return whether to unwrap the native token before transfers to the user\n    function shouldUnwrapNativeToken(Props memory props) internal pure returns (bool) {\n        return props.flags.shouldUnwrapNativeToken;\n    }\n\n    // @dev set whether the native token should be unwrapped before being\n    // transferred to the receiver\n    // @param props Props\n    // @param value the value to set to\n    function setShouldUnwrapNativeToken(Props memory props, bool value) internal pure {\n        props.flags.shouldUnwrapNativeToken = value;\n    }\n\n    // @dev whether the order is frozen\n    // @param props Props\n    // @return whether the order is frozen\n    function isFrozen(Props memory props) internal pure returns (bool) {\n        return props.flags.isFrozen;\n    }\n\n    // @dev set whether the order is frozen\n    // transferred to the receiver\n    // @param props Props\n    // @param value the value to set to\n    function setIsFrozen(Props memory props, bool value) internal pure {\n        props.flags.isFrozen = value;\n    }\n\n    function autoCancel(Props memory props) internal pure returns (bool) {\n        return props.flags.autoCancel;\n    }\n\n    function setAutoCancel(Props memory props, bool value) internal pure {\n        props.flags.autoCancel = value;\n    }\n\n    // @dev set the order.updatedAtBlock to the current block number\n    // @param props Props\n    function touch(Props memory props) internal view {\n        props.setUpdatedAtBlock(Chain.currentBlockNumber());\n        props.setUpdatedAtTime(Chain.currentTimestamp());\n    }\n}\n"
    },
    "contracts/order/OrderStoreUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/Keys.sol\";\nimport \"../data/DataStore.sol\";\n\nimport \"./Order.sol\";\n\n/**\n * @title OrderStoreUtils\n * @dev Library for order storage functions\n */\nlibrary OrderStoreUtils {\n    using Order for Order.Props;\n\n    bytes32 public constant ACCOUNT = keccak256(abi.encode(\"ACCOUNT\"));\n    bytes32 public constant RECEIVER = keccak256(abi.encode(\"RECEIVER\"));\n    bytes32 public constant CANCELLATION_RECEIVER = keccak256(abi.encode(\"CANCELLATION_RECEIVER\"));\n    bytes32 public constant CALLBACK_CONTRACT = keccak256(abi.encode(\"CALLBACK_CONTRACT\"));\n    bytes32 public constant UI_FEE_RECEIVER = keccak256(abi.encode(\"UI_FEE_RECEIVER\"));\n    bytes32 public constant MARKET = keccak256(abi.encode(\"MARKET\"));\n    bytes32 public constant INITIAL_COLLATERAL_TOKEN = keccak256(abi.encode(\"INITIAL_COLLATERAL_TOKEN\"));\n    bytes32 public constant SWAP_PATH = keccak256(abi.encode(\"SWAP_PATH\"));\n\n    bytes32 public constant ORDER_TYPE = keccak256(abi.encode(\"ORDER_TYPE\"));\n    bytes32 public constant DECREASE_POSITION_SWAP_TYPE = keccak256(abi.encode(\"DECREASE_POSITION_SWAP_TYPE\"));\n    bytes32 public constant SIZE_DELTA_USD = keccak256(abi.encode(\"SIZE_DELTA_USD\"));\n    bytes32 public constant INITIAL_COLLATERAL_DELTA_AMOUNT = keccak256(abi.encode(\"INITIAL_COLLATERAL_DELTA_AMOUNT\"));\n    bytes32 public constant TRIGGER_PRICE = keccak256(abi.encode(\"TRIGGER_PRICE\"));\n    bytes32 public constant ACCEPTABLE_PRICE = keccak256(abi.encode(\"ACCEPTABLE_PRICE\"));\n    bytes32 public constant EXECUTION_FEE = keccak256(abi.encode(\"EXECUTION_FEE\"));\n    bytes32 public constant CALLBACK_GAS_LIMIT = keccak256(abi.encode(\"CALLBACK_GAS_LIMIT\"));\n    bytes32 public constant MIN_OUTPUT_AMOUNT = keccak256(abi.encode(\"MIN_OUTPUT_AMOUNT\"));\n    bytes32 public constant UPDATED_AT_BLOCK = keccak256(abi.encode(\"UPDATED_AT_BLOCK\"));\n    bytes32 public constant UPDATED_AT_TIME = keccak256(abi.encode(\"UPDATED_AT_TIME\"));\n\n    bytes32 public constant IS_LONG = keccak256(abi.encode(\"IS_LONG\"));\n    bytes32 public constant SHOULD_UNWRAP_NATIVE_TOKEN = keccak256(abi.encode(\"SHOULD_UNWRAP_NATIVE_TOKEN\"));\n    bytes32 public constant IS_FROZEN = keccak256(abi.encode(\"IS_FROZEN\"));\n    bytes32 public constant AUTO_CANCEL = keccak256(abi.encode(\"AUTO_CANCEL\"));\n\n    function get(DataStore dataStore, bytes32 key) external view returns (Order.Props memory) {\n        Order.Props memory order;\n        if (!dataStore.containsBytes32(Keys.ORDER_LIST, key)) {\n            return order;\n        }\n\n        order.setAccount(dataStore.getAddress(\n            keccak256(abi.encode(key, ACCOUNT))\n        ));\n\n        order.setReceiver(dataStore.getAddress(\n            keccak256(abi.encode(key, RECEIVER))\n        ));\n\n        order.setCancellationReceiver(dataStore.getAddress(\n            keccak256(abi.encode(key, CANCELLATION_RECEIVER))\n        ));\n\n        order.setCallbackContract(dataStore.getAddress(\n            keccak256(abi.encode(key, CALLBACK_CONTRACT))\n        ));\n\n        order.setUiFeeReceiver(dataStore.getAddress(\n            keccak256(abi.encode(key, UI_FEE_RECEIVER))\n        ));\n\n        order.setMarket(dataStore.getAddress(\n            keccak256(abi.encode(key, MARKET))\n        ));\n\n        order.setInitialCollateralToken(dataStore.getAddress(\n            keccak256(abi.encode(key, INITIAL_COLLATERAL_TOKEN))\n        ));\n\n        order.setSwapPath(dataStore.getAddressArray(\n            keccak256(abi.encode(key, SWAP_PATH))\n        ));\n\n        order.setOrderType(Order.OrderType(dataStore.getUint(\n            keccak256(abi.encode(key, ORDER_TYPE))\n        )));\n\n        order.setDecreasePositionSwapType(Order.DecreasePositionSwapType(dataStore.getUint(\n            keccak256(abi.encode(key, DECREASE_POSITION_SWAP_TYPE))\n        )));\n\n        order.setSizeDeltaUsd(dataStore.getUint(\n            keccak256(abi.encode(key, SIZE_DELTA_USD))\n        ));\n\n        order.setInitialCollateralDeltaAmount(dataStore.getUint(\n            keccak256(abi.encode(key, INITIAL_COLLATERAL_DELTA_AMOUNT))\n        ));\n\n        order.setTriggerPrice(dataStore.getUint(\n            keccak256(abi.encode(key, TRIGGER_PRICE))\n        ));\n\n        order.setAcceptablePrice(dataStore.getUint(\n            keccak256(abi.encode(key, ACCEPTABLE_PRICE))\n        ));\n\n        order.setExecutionFee(dataStore.getUint(\n            keccak256(abi.encode(key, EXECUTION_FEE))\n        ));\n\n        order.setCallbackGasLimit(dataStore.getUint(\n            keccak256(abi.encode(key, CALLBACK_GAS_LIMIT))\n        ));\n\n        order.setMinOutputAmount(dataStore.getUint(\n            keccak256(abi.encode(key, MIN_OUTPUT_AMOUNT))\n        ));\n\n        order.setUpdatedAtBlock(dataStore.getUint(\n            keccak256(abi.encode(key, UPDATED_AT_BLOCK))\n        ));\n\n        order.setUpdatedAtTime(dataStore.getUint(\n            keccak256(abi.encode(key, UPDATED_AT_TIME))\n        ));\n\n        order.setIsLong(dataStore.getBool(\n            keccak256(abi.encode(key, IS_LONG))\n        ));\n\n        order.setShouldUnwrapNativeToken(dataStore.getBool(\n            keccak256(abi.encode(key, SHOULD_UNWRAP_NATIVE_TOKEN))\n        ));\n\n        order.setIsFrozen(dataStore.getBool(\n            keccak256(abi.encode(key, IS_FROZEN))\n        ));\n\n        order.setAutoCancel(dataStore.getBool(\n            keccak256(abi.encode(key, AUTO_CANCEL))\n        ));\n\n        return order;\n    }\n\n    function set(DataStore dataStore, bytes32 key, Order.Props memory order) external {\n        dataStore.addBytes32(\n            Keys.ORDER_LIST,\n            key\n        );\n\n        dataStore.addBytes32(\n            Keys.accountOrderListKey(order.account()),\n            key\n        );\n\n        dataStore.setAddress(\n            keccak256(abi.encode(key, ACCOUNT)),\n            order.account()\n        );\n\n        dataStore.setAddress(\n            keccak256(abi.encode(key, RECEIVER)),\n            order.receiver()\n        );\n\n        dataStore.setAddress(\n            keccak256(abi.encode(key, CANCELLATION_RECEIVER)),\n            order.cancellationReceiver()\n        );\n\n        dataStore.setAddress(\n            keccak256(abi.encode(key, CALLBACK_CONTRACT)),\n            order.callbackContract()\n        );\n\n        dataStore.setAddress(\n            keccak256(abi.encode(key, UI_FEE_RECEIVER)),\n            order.uiFeeReceiver()\n        );\n\n        dataStore.setAddress(\n            keccak256(abi.encode(key, MARKET)),\n            order.market()\n        );\n\n        dataStore.setAddress(\n            keccak256(abi.encode(key, INITIAL_COLLATERAL_TOKEN)),\n            order.initialCollateralToken()\n        );\n\n        dataStore.setAddressArray(\n            keccak256(abi.encode(key, SWAP_PATH)),\n            order.swapPath()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, ORDER_TYPE)),\n            uint256(order.orderType())\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, DECREASE_POSITION_SWAP_TYPE)),\n            uint256(order.decreasePositionSwapType())\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, SIZE_DELTA_USD)),\n            order.sizeDeltaUsd()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, INITIAL_COLLATERAL_DELTA_AMOUNT)),\n            order.initialCollateralDeltaAmount()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, TRIGGER_PRICE)),\n            order.triggerPrice()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, ACCEPTABLE_PRICE)),\n            order.acceptablePrice()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, EXECUTION_FEE)),\n            order.executionFee()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, CALLBACK_GAS_LIMIT)),\n            order.callbackGasLimit()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, MIN_OUTPUT_AMOUNT)),\n            order.minOutputAmount()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, UPDATED_AT_BLOCK)),\n            order.updatedAtBlock()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, UPDATED_AT_TIME)),\n            order.updatedAtTime()\n        );\n\n        dataStore.setBool(\n            keccak256(abi.encode(key, IS_LONG)),\n            order.isLong()\n        );\n\n        dataStore.setBool(\n            keccak256(abi.encode(key, SHOULD_UNWRAP_NATIVE_TOKEN)),\n            order.shouldUnwrapNativeToken()\n        );\n\n        dataStore.setBool(\n            keccak256(abi.encode(key, IS_FROZEN)),\n            order.isFrozen()\n        );\n\n        dataStore.setBool(\n            keccak256(abi.encode(key, AUTO_CANCEL)),\n            order.autoCancel()\n        );\n    }\n\n    function remove(DataStore dataStore, bytes32 key, address account) external {\n        if (!dataStore.containsBytes32(Keys.ORDER_LIST, key)) {\n            revert Errors.OrderNotFound(key);\n        }\n\n        dataStore.removeBytes32(\n            Keys.ORDER_LIST,\n            key\n        );\n\n        dataStore.removeBytes32(\n            Keys.accountOrderListKey(account),\n            key\n        );\n\n        dataStore.removeAddress(\n            keccak256(abi.encode(key, ACCOUNT))\n        );\n\n        dataStore.removeAddress(\n            keccak256(abi.encode(key, RECEIVER))\n        );\n\n        dataStore.removeAddress(\n            keccak256(abi.encode(key, CANCELLATION_RECEIVER))\n        );\n\n        dataStore.removeAddress(\n            keccak256(abi.encode(key, CALLBACK_CONTRACT))\n        );\n\n        dataStore.removeAddress(\n            keccak256(abi.encode(key, UI_FEE_RECEIVER))\n        );\n\n        dataStore.removeAddress(\n            keccak256(abi.encode(key, MARKET))\n        );\n\n        dataStore.removeAddress(\n            keccak256(abi.encode(key, INITIAL_COLLATERAL_TOKEN))\n        );\n\n        dataStore.removeAddressArray(\n            keccak256(abi.encode(key, SWAP_PATH))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, ORDER_TYPE))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, DECREASE_POSITION_SWAP_TYPE))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, SIZE_DELTA_USD))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, INITIAL_COLLATERAL_DELTA_AMOUNT))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, TRIGGER_PRICE))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, ACCEPTABLE_PRICE))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, EXECUTION_FEE))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, CALLBACK_GAS_LIMIT))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, MIN_OUTPUT_AMOUNT))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, UPDATED_AT_BLOCK))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, UPDATED_AT_TIME))\n        );\n\n        dataStore.removeBool(\n            keccak256(abi.encode(key, IS_LONG))\n        );\n\n        dataStore.removeBool(\n            keccak256(abi.encode(key, SHOULD_UNWRAP_NATIVE_TOKEN))\n        );\n\n        dataStore.removeBool(\n            keccak256(abi.encode(key, IS_FROZEN))\n        );\n\n        dataStore.removeBool(\n            keccak256(abi.encode(key, AUTO_CANCEL))\n        );\n    }\n\n    function getOrderCount(DataStore dataStore) internal view returns (uint256) {\n        return dataStore.getBytes32Count(Keys.ORDER_LIST);\n    }\n\n    function getOrderKeys(DataStore dataStore, uint256 start, uint256 end) internal view returns (bytes32[] memory) {\n        return dataStore.getBytes32ValuesAt(Keys.ORDER_LIST, start, end);\n    }\n\n    function getAccountOrderCount(DataStore dataStore, address account) internal view returns (uint256) {\n        return dataStore.getBytes32Count(Keys.accountOrderListKey(account));\n    }\n\n    function getAccountOrderKeys(DataStore dataStore, address account, uint256 start, uint256 end) internal view returns (bytes32[] memory) {\n        return dataStore.getBytes32ValuesAt(Keys.accountOrderListKey(account), start, end);\n    }\n}\n"
    },
    "contracts/position/Position.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n// @title Position\n// @dev Stuct for positions\n//\n// borrowing fees for position require only a borrowingFactor to track\n// an example on how this works is if the global cumulativeBorrowingFactor is 10020%\n// a position would be opened with borrowingFactor as 10020%\n// after some time, if the cumulativeBorrowingFactor is updated to 10025% the position would\n// owe 5% of the position size as borrowing fees\n// the total pending borrowing fees of all positions is factored into the calculation of the pool value for LPs\n// when a position is increased or decreased, the pending borrowing fees for the position is deducted from the position's\n// collateral and transferred into the LP pool\n//\n// the same borrowing fee factor tracking cannot be applied for funding fees as those calculations consider pending funding fees\n// based on the fiat value of the position sizes\n//\n// for example, if the price of the longToken is $2000 and a long position owes $200 in funding fees, the opposing short position\n// claims the funding fees of 0.1 longToken ($200), if the price of the longToken changes to $4000 later, the long position would\n// only owe 0.05 longToken ($200)\n// this would result in differences between the amounts deducted and amounts paid out, for this reason, the actual token amounts\n// to be deducted and to be paid out need to be tracked instead\n//\n// for funding fees, there are four values to consider:\n// 1. long positions with market.longToken as collateral\n// 2. long positions with market.shortToken as collateral\n// 3. short positions with market.longToken as collateral\n// 4. short positions with market.shortToken as collateral\nlibrary Position {\n    // @dev there is a limit on the number of fields a struct can have when being passed\n    // or returned as a memory variable which can cause \"Stack too deep\" errors\n    // use sub-structs to avoid this issue\n    // @param addresses address values\n    // @param numbers number values\n    // @param flags boolean values\n    struct Props {\n        Addresses addresses;\n        Numbers numbers;\n        Flags flags;\n    }\n\n    // @param account the position's account\n    // @param market the position's market\n    // @param collateralToken the position's collateralToken\n    struct Addresses {\n        address account;\n        address market;\n        address collateralToken;\n    }\n\n    // @param sizeInUsd the position's size in USD\n    // @param sizeInTokens the position's size in tokens\n    // @param collateralAmount the amount of collateralToken for collateral\n    // @param borrowingFactor the position's borrowing factor\n    // @param fundingFeeAmountPerSize the position's funding fee per size\n    // @param longTokenClaimableFundingAmountPerSize the position's claimable funding amount per size\n    // for the market.longToken\n    // @param shortTokenClaimableFundingAmountPerSize the position's claimable funding amount per size\n    // for the market.shortToken\n    // @param increasedAtBlock the block at which the position was last increased\n    // @param decreasedAtBlock the block at which the position was last decreased\n    struct Numbers {\n        uint256 sizeInUsd;\n        uint256 sizeInTokens;\n        uint256 collateralAmount;\n        uint256 borrowingFactor;\n        uint256 fundingFeeAmountPerSize;\n        uint256 longTokenClaimableFundingAmountPerSize;\n        uint256 shortTokenClaimableFundingAmountPerSize;\n        uint256 increasedAtBlock;\n        uint256 decreasedAtBlock;\n        uint256 increasedAtTime;\n        uint256 decreasedAtTime;\n    }\n\n    // @param isLong whether the position is a long or short\n    struct Flags {\n        bool isLong;\n    }\n\n    function account(Props memory props) internal pure returns (address) {\n        return props.addresses.account;\n    }\n\n    function setAccount(Props memory props, address value) internal pure {\n        props.addresses.account = value;\n    }\n\n    function market(Props memory props) internal pure returns (address) {\n        return props.addresses.market;\n    }\n\n    function setMarket(Props memory props, address value) internal pure {\n        props.addresses.market = value;\n    }\n\n    function collateralToken(Props memory props) internal pure returns (address) {\n        return props.addresses.collateralToken;\n    }\n\n    function setCollateralToken(Props memory props, address value) internal pure {\n        props.addresses.collateralToken = value;\n    }\n\n    function sizeInUsd(Props memory props) internal pure returns (uint256) {\n        return props.numbers.sizeInUsd;\n    }\n\n    function setSizeInUsd(Props memory props, uint256 value) internal pure {\n        props.numbers.sizeInUsd = value;\n    }\n\n    function sizeInTokens(Props memory props) internal pure returns (uint256) {\n        return props.numbers.sizeInTokens;\n    }\n\n    function setSizeInTokens(Props memory props, uint256 value) internal pure {\n        props.numbers.sizeInTokens = value;\n    }\n\n    function collateralAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.collateralAmount;\n    }\n\n    function setCollateralAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.collateralAmount = value;\n    }\n\n    function borrowingFactor(Props memory props) internal pure returns (uint256) {\n        return props.numbers.borrowingFactor;\n    }\n\n    function setBorrowingFactor(Props memory props, uint256 value) internal pure {\n        props.numbers.borrowingFactor = value;\n    }\n\n    function fundingFeeAmountPerSize(Props memory props) internal pure returns (uint256) {\n        return props.numbers.fundingFeeAmountPerSize;\n    }\n\n    function setFundingFeeAmountPerSize(Props memory props, uint256 value) internal pure {\n        props.numbers.fundingFeeAmountPerSize = value;\n    }\n\n    function longTokenClaimableFundingAmountPerSize(Props memory props) internal pure returns (uint256) {\n        return props.numbers.longTokenClaimableFundingAmountPerSize;\n    }\n\n    function setLongTokenClaimableFundingAmountPerSize(Props memory props, uint256 value) internal pure {\n        props.numbers.longTokenClaimableFundingAmountPerSize = value;\n    }\n\n    function shortTokenClaimableFundingAmountPerSize(Props memory props) internal pure returns (uint256) {\n        return props.numbers.shortTokenClaimableFundingAmountPerSize;\n    }\n\n    function setShortTokenClaimableFundingAmountPerSize(Props memory props, uint256 value) internal pure {\n        props.numbers.shortTokenClaimableFundingAmountPerSize = value;\n    }\n\n    function increasedAtBlock(Props memory props) internal pure returns (uint256) {\n        return props.numbers.increasedAtBlock;\n    }\n\n    function setIncreasedAtBlock(Props memory props, uint256 value) internal pure {\n        props.numbers.increasedAtBlock = value;\n    }\n\n    function decreasedAtBlock(Props memory props) internal pure returns (uint256) {\n        return props.numbers.decreasedAtBlock;\n    }\n\n    function setDecreasedAtBlock(Props memory props, uint256 value) internal pure {\n        props.numbers.decreasedAtBlock = value;\n    }\n\n    function increasedAtTime(Props memory props) internal pure returns (uint256) {\n        return props.numbers.increasedAtTime;\n    }\n\n    function setIncreasedAtTime(Props memory props, uint256 value) internal pure {\n        props.numbers.increasedAtTime = value;\n    }\n\n    function decreasedAtTime(Props memory props) internal pure returns (uint256) {\n        return props.numbers.decreasedAtTime;\n    }\n\n    function setDecreasedAtTime(Props memory props, uint256 value) internal pure {\n        props.numbers.decreasedAtTime = value;\n    }\n\n    function isLong(Props memory props) internal pure returns (bool) {\n        return props.flags.isLong;\n    }\n\n    function setIsLong(Props memory props, bool value) internal pure {\n        props.flags.isLong = value;\n    }\n\n    // @dev get the key for a position\n    // @param account the position's account\n    // @param market the position's market\n    // @param collateralToken the position's collateralToken\n    // @param isLong whether the position is long or short\n    // @return the position key\n    function getPositionKey(address _account, address _market, address _collateralToken, bool _isLong) internal pure returns (bytes32) {\n        bytes32 _key = keccak256(abi.encode(_account, _market, _collateralToken, _isLong));\n        return _key;\n    }\n}\n"
    },
    "contracts/position/PositionStoreUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../data/Keys.sol\";\nimport \"../data/DataStore.sol\";\n\nimport \"./Position.sol\";\n\n/**\n * @title PositionStoreUtils\n * @dev Library for position storage functions\n */\nlibrary PositionStoreUtils {\n    using Position for Position.Props;\n\n    bytes32 public constant ACCOUNT = keccak256(abi.encode(\"ACCOUNT\"));\n    bytes32 public constant MARKET = keccak256(abi.encode(\"MARKET\"));\n    bytes32 public constant COLLATERAL_TOKEN = keccak256(abi.encode(\"COLLATERAL_TOKEN\"));\n\n    bytes32 public constant SIZE_IN_USD = keccak256(abi.encode(\"SIZE_IN_USD\"));\n    bytes32 public constant SIZE_IN_TOKENS = keccak256(abi.encode(\"SIZE_IN_TOKENS\"));\n    bytes32 public constant COLLATERAL_AMOUNT = keccak256(abi.encode(\"COLLATERAL_AMOUNT\"));\n    bytes32 public constant BORROWING_FACTOR = keccak256(abi.encode(\"BORROWING_FACTOR\"));\n    bytes32 public constant FUNDING_FEE_AMOUNT_PER_SIZE = keccak256(abi.encode(\"FUNDING_FEE_AMOUNT_PER_SIZE\"));\n    bytes32 public constant LONG_TOKEN_CLAIMABLE_FUNDING_AMOUNT_PER_SIZE = keccak256(abi.encode(\"LONG_TOKEN_CLAIMABLE_FUNDING_AMOUNT_PER_SIZE\"));\n    bytes32 public constant SHORT_TOKEN_CLAIMABLE_FUNDING_AMOUNT_PER_SIZE = keccak256(abi.encode(\"SHORT_TOKEN_CLAIMABLE_FUNDING_AMOUNT_PER_SIZE\"));\n    bytes32 public constant INCREASED_AT_BLOCK = keccak256(abi.encode(\"INCREASED_AT_BLOCK\"));\n    bytes32 public constant DECREASED_AT_BLOCK = keccak256(abi.encode(\"DECREASED_AT_BLOCK\"));\n    bytes32 public constant INCREASED_AT_TIME = keccak256(abi.encode(\"INCREASED_AT_TIME\"));\n    bytes32 public constant DECREASED_AT_TIME = keccak256(abi.encode(\"DECREASED_AT_TIME\"));\n\n    bytes32 public constant IS_LONG = keccak256(abi.encode(\"IS_LONG\"));\n\n    function get(DataStore dataStore, bytes32 key) external view returns (Position.Props memory) {\n        Position.Props memory position;\n        if (!dataStore.containsBytes32(Keys.POSITION_LIST, key)) {\n            return position;\n        }\n\n        position.setAccount(dataStore.getAddress(\n            keccak256(abi.encode(key, ACCOUNT))\n        ));\n\n        position.setMarket(dataStore.getAddress(\n            keccak256(abi.encode(key, MARKET))\n        ));\n\n        position.setCollateralToken(dataStore.getAddress(\n            keccak256(abi.encode(key, COLLATERAL_TOKEN))\n        ));\n\n        position.setSizeInUsd(dataStore.getUint(\n            keccak256(abi.encode(key, SIZE_IN_USD))\n        ));\n\n        position.setSizeInTokens(dataStore.getUint(\n            keccak256(abi.encode(key, SIZE_IN_TOKENS))\n        ));\n\n        position.setCollateralAmount(dataStore.getUint(\n            keccak256(abi.encode(key, COLLATERAL_AMOUNT))\n        ));\n\n        position.setBorrowingFactor(dataStore.getUint(\n            keccak256(abi.encode(key, BORROWING_FACTOR))\n        ));\n\n        position.setFundingFeeAmountPerSize(dataStore.getUint(\n            keccak256(abi.encode(key, FUNDING_FEE_AMOUNT_PER_SIZE))\n        ));\n\n        position.setLongTokenClaimableFundingAmountPerSize(dataStore.getUint(\n            keccak256(abi.encode(key, LONG_TOKEN_CLAIMABLE_FUNDING_AMOUNT_PER_SIZE))\n        ));\n\n        position.setShortTokenClaimableFundingAmountPerSize(dataStore.getUint(\n            keccak256(abi.encode(key, SHORT_TOKEN_CLAIMABLE_FUNDING_AMOUNT_PER_SIZE))\n        ));\n\n        position.setIncreasedAtBlock(dataStore.getUint(\n            keccak256(abi.encode(key, INCREASED_AT_BLOCK))\n        ));\n\n        position.setDecreasedAtBlock(dataStore.getUint(\n            keccak256(abi.encode(key, DECREASED_AT_BLOCK))\n        ));\n\n        position.setIncreasedAtTime(dataStore.getUint(\n            keccak256(abi.encode(key, INCREASED_AT_TIME))\n        ));\n\n        position.setDecreasedAtTime(dataStore.getUint(\n            keccak256(abi.encode(key, DECREASED_AT_TIME))\n        ));\n\n        position.setIsLong(dataStore.getBool(\n            keccak256(abi.encode(key, IS_LONG))\n        ));\n\n        return position;\n    }\n\n    function set(DataStore dataStore, bytes32 key, Position.Props memory position) external {\n        dataStore.addBytes32(\n            Keys.POSITION_LIST,\n            key\n        );\n\n        dataStore.addBytes32(\n            Keys.accountPositionListKey(position.account()),\n            key\n        );\n\n        dataStore.setAddress(\n            keccak256(abi.encode(key, ACCOUNT)),\n            position.account()\n        );\n\n        dataStore.setAddress(\n            keccak256(abi.encode(key, MARKET)),\n            position.market()\n        );\n\n        dataStore.setAddress(\n            keccak256(abi.encode(key, COLLATERAL_TOKEN)),\n            position.collateralToken()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, SIZE_IN_USD)),\n            position.sizeInUsd()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, SIZE_IN_TOKENS)),\n            position.sizeInTokens()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, COLLATERAL_AMOUNT)),\n            position.collateralAmount()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, BORROWING_FACTOR)),\n            position.borrowingFactor()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, FUNDING_FEE_AMOUNT_PER_SIZE)),\n            position.fundingFeeAmountPerSize()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, LONG_TOKEN_CLAIMABLE_FUNDING_AMOUNT_PER_SIZE)),\n            position.longTokenClaimableFundingAmountPerSize()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, SHORT_TOKEN_CLAIMABLE_FUNDING_AMOUNT_PER_SIZE)),\n            position.shortTokenClaimableFundingAmountPerSize()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, INCREASED_AT_BLOCK)),\n            position.increasedAtBlock()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, DECREASED_AT_BLOCK)),\n            position.decreasedAtBlock()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, INCREASED_AT_TIME)),\n            position.increasedAtTime()\n        );\n\n        dataStore.setUint(\n            keccak256(abi.encode(key, DECREASED_AT_TIME)),\n            position.decreasedAtTime()\n        );\n\n        dataStore.setBool(\n            keccak256(abi.encode(key, IS_LONG)),\n            position.isLong()\n        );\n    }\n\n    function remove(DataStore dataStore, bytes32 key, address account) external {\n        if (!dataStore.containsBytes32(Keys.POSITION_LIST, key)) {\n            revert Errors.PositionNotFound(key);\n        }\n\n        dataStore.removeBytes32(\n            Keys.POSITION_LIST,\n            key\n        );\n\n        dataStore.removeBytes32(\n            Keys.accountPositionListKey(account),\n            key\n        );\n\n        dataStore.removeAddress(\n            keccak256(abi.encode(key, ACCOUNT))\n        );\n\n        dataStore.removeAddress(\n            keccak256(abi.encode(key, MARKET))\n        );\n\n        dataStore.removeAddress(\n            keccak256(abi.encode(key, COLLATERAL_TOKEN))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, SIZE_IN_USD))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, SIZE_IN_TOKENS))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, COLLATERAL_AMOUNT))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, BORROWING_FACTOR))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, FUNDING_FEE_AMOUNT_PER_SIZE))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, LONG_TOKEN_CLAIMABLE_FUNDING_AMOUNT_PER_SIZE))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, SHORT_TOKEN_CLAIMABLE_FUNDING_AMOUNT_PER_SIZE))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, INCREASED_AT_BLOCK))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, DECREASED_AT_BLOCK))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, INCREASED_AT_TIME))\n        );\n\n        dataStore.removeUint(\n            keccak256(abi.encode(key, DECREASED_AT_TIME))\n        );\n\n        dataStore.removeBool(\n            keccak256(abi.encode(key, IS_LONG))\n        );\n    }\n\n    function getPositionCount(DataStore dataStore) internal view returns (uint256) {\n        return dataStore.getBytes32Count(Keys.POSITION_LIST);\n    }\n\n    function getPositionKeys(DataStore dataStore, uint256 start, uint256 end) internal view returns (bytes32[] memory) {\n        return dataStore.getBytes32ValuesAt(Keys.POSITION_LIST, start, end);\n    }\n\n    function getAccountPositionCount(DataStore dataStore, address account) internal view returns (uint256) {\n        return dataStore.getBytes32Count(Keys.accountPositionListKey(account));\n    }\n\n    function getAccountPositionKeys(DataStore dataStore, address account, uint256 start, uint256 end) internal view returns (bytes32[] memory) {\n        return dataStore.getBytes32ValuesAt(Keys.accountPositionListKey(account), start, end);\n    }\n}\n"
    },
    "contracts/role/Role.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n/**\n * @title Role\n * @dev Library for role keys\n */\nlibrary Role {\n    /**\n     * @dev The ROLE_ADMIN role.\n     * Hash: 0x56908b85b56869d7c69cd020749874f238259af9646ca930287866cdd660b7d9\n     */\n    bytes32 public constant ROLE_ADMIN = keccak256(abi.encode(\"ROLE_ADMIN\"));\n\n    /**\n     * @dev The TIMELOCK_ADMIN role.\n     * Hash: 0xf49b0c86b385620e25b0985905d1a112a5f1bc1d51a7a292a8cdf112b3a7c47c\n     */\n    bytes32 public constant TIMELOCK_ADMIN = keccak256(abi.encode(\"TIMELOCK_ADMIN\"));\n\n    /**\n     * @dev The TIMELOCK_MULTISIG role.\n     * Hash: 0xe068a8d811c3c8290a8be34607cfa3184b26ffb8dea4dde7a451adfba9fa173a\n     */\n    bytes32 public constant TIMELOCK_MULTISIG = keccak256(abi.encode(\"TIMELOCK_MULTISIG\"));\n\n    /**\n     * @dev The CONFIG_KEEPER role.\n     * Hash: 0x901fb3de937a1dcb6ecaf26886fda47a088e74f36232a0673eade97079dc225b\n     */\n    bytes32 public constant CONFIG_KEEPER = keccak256(abi.encode(\"CONFIG_KEEPER\"));\n\n    /**\n     * @dev The LIMITED_CONFIG_KEEPER role.\n     * Hash: 0xb49beded4d572a2d32002662fc5c735817329f4337b3a488aab0b5e835c01ba7\n     */\n    bytes32 public constant LIMITED_CONFIG_KEEPER = keccak256(abi.encode(\"LIMITED_CONFIG_KEEPER\"));\n\n    /**\n     * @dev The CONTROLLER role.\n     * Hash: 0x97adf037b2472f4a6a9825eff7d2dd45e37f2dc308df2a260d6a72af4189a65b\n     */\n    bytes32 public constant CONTROLLER = keccak256(abi.encode(\"CONTROLLER\"));\n\n    /**\n     * @dev The GOV_TOKEN_CONTROLLER role.\n     * Hash: 0x16a157db08319d4eaf6b157a71f5d2e18c6500cab8a25bee0b4f9c753cb13690\n     */\n    bytes32 public constant GOV_TOKEN_CONTROLLER = keccak256(abi.encode(\"GOV_TOKEN_CONTROLLER\"));\n\n    /**\n     * @dev The ROUTER_PLUGIN role.\n     * Hash: 0xc82e6cc76072f8edb32d42796e58e13ab6e145524eb6b36c073be82f20d410f3\n     */\n    bytes32 public constant ROUTER_PLUGIN = keccak256(abi.encode(\"ROUTER_PLUGIN\"));\n\n    /**\n     * @dev The MARKET_KEEPER role.\n     * Hash: 0xd66692c70b60cf1337e643d6a6473f6865d8c03f3c26b460df3d19b504fb46ae\n     */\n    bytes32 public constant MARKET_KEEPER = keccak256(abi.encode(\"MARKET_KEEPER\"));\n\n    /**\n     * @dev The FEE_KEEPER role.\n     * Hash: 0xe0ff4cc0c6ecffab6db3f63ea62dd53f8091919ac57669f1bb3d9828278081d8\n     */\n    bytes32 public constant FEE_KEEPER = keccak256(abi.encode(\"FEE_KEEPER\"));\n\n    /**\n     * @dev The FEE_DISTRIBUTION_KEEPER role.\n     * Hash: 0xc23a98a1bf683201c11eeeb8344052ad3bc603c8ddcad06093edc1e8dafa96a2\n     */\n    bytes32 public constant FEE_DISTRIBUTION_KEEPER = keccak256(abi.encode(\"FEE_DISTRIBUTION_KEEPER\"));\n\n    /**\n     * @dev The ORDER_KEEPER role.\n     * Hash: 0x40a07f8f0fc57fcf18b093d96362a8e661eaac7b7e6edbf66f242111f83a6794\n     */\n    bytes32 public constant ORDER_KEEPER = keccak256(abi.encode(\"ORDER_KEEPER\"));\n\n    /**\n     * @dev The FROZEN_ORDER_KEEPER role.\n     * Hash: 0xcb6c7bc0d25d73c91008af44527b80c56dee4db8965845d926a25659a4a8bc07\n     */\n    bytes32 public constant FROZEN_ORDER_KEEPER = keccak256(abi.encode(\"FROZEN_ORDER_KEEPER\"));\n\n    /**\n     * @dev The PRICING_KEEPER role.\n     * Hash: 0x2700e36dc4e6a0daa977bffd4368adbd48f8058da74152919f91f58eddb42103\n     */\n    bytes32 public constant PRICING_KEEPER = keccak256(abi.encode(\"PRICING_KEEPER\"));\n    /**\n     * @dev The LIQUIDATION_KEEPER role.\n     * Hash: 0x556c788ffc0574ec93966d808c170833d96489c9c58f5bcb3dadf711ba28720e\n     */\n    bytes32 public constant LIQUIDATION_KEEPER = keccak256(abi.encode(\"LIQUIDATION_KEEPER\"));\n    /**\n     * @dev The ADL_KEEPER role.\n     * Hash: 0xb37d64edaeaf5e634c13682dbd813f5a12fec9eb4f74433a089e7a3c3289af91\n     */\n    bytes32 public constant ADL_KEEPER = keccak256(abi.encode(\"ADL_KEEPER\"));\n}\n"
    },
    "contracts/role/RoleModule.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./RoleStore.sol\";\n\n/**\n * @title RoleModule\n * @dev Contract for role validation functions\n */\ncontract RoleModule {\n    RoleStore public immutable roleStore;\n\n    /**\n     * @dev Constructor that initializes the role store for this contract.\n     *\n     * @param _roleStore The contract instance to use as the role store.\n     */\n    constructor(RoleStore _roleStore) {\n        roleStore = _roleStore;\n    }\n\n    /**\n     * @dev Only allows the contract's own address to call the function.\n     */\n    modifier onlySelf() {\n        if (msg.sender != address(this)) {\n            revert Errors.Unauthorized(msg.sender, \"SELF\");\n        }\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the TIMELOCK_MULTISIG role to call the function.\n     */\n    modifier onlyTimelockMultisig() {\n        _validateRole(Role.TIMELOCK_MULTISIG, \"TIMELOCK_MULTISIG\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the TIMELOCK_ADMIN role to call the function.\n     */\n    modifier onlyTimelockAdmin() {\n        _validateRole(Role.TIMELOCK_ADMIN, \"TIMELOCK_ADMIN\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the CONFIG_KEEPER role to call the function.\n     */\n    modifier onlyConfigKeeper() {\n        _validateRole(Role.CONFIG_KEEPER, \"CONFIG_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the CONTROLLER role to call the function.\n     */\n    modifier onlyController() {\n        _validateRole(Role.CONTROLLER, \"CONTROLLER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the GOV_TOKEN_CONTROLLER role to call the function.\n     */\n    modifier onlyGovTokenController() {\n        _validateRole(Role.GOV_TOKEN_CONTROLLER, \"GOV_TOKEN_CONTROLLER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the ROUTER_PLUGIN role to call the function.\n     */\n    modifier onlyRouterPlugin() {\n        _validateRole(Role.ROUTER_PLUGIN, \"ROUTER_PLUGIN\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the MARKET_KEEPER role to call the function.\n     */\n    modifier onlyMarketKeeper() {\n        _validateRole(Role.MARKET_KEEPER, \"MARKET_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the FEE_KEEPER role to call the function.\n     */\n    modifier onlyFeeKeeper() {\n        _validateRole(Role.FEE_KEEPER, \"FEE_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the FEE_DISTRIBUTION_KEEPER role to call the function.\n     */\n    modifier onlyFeeDistributionKeeper() {\n        _validateRole(Role.FEE_DISTRIBUTION_KEEPER, \"FEE_DISTRIBUTION_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the ORDER_KEEPER role to call the function.\n     */\n    modifier onlyOrderKeeper() {\n        _validateRole(Role.ORDER_KEEPER, \"ORDER_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the PRICING_KEEPER role to call the function.\n     */\n    modifier onlyPricingKeeper() {\n        _validateRole(Role.PRICING_KEEPER, \"PRICING_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the LIQUIDATION_KEEPER role to call the function.\n     */\n    modifier onlyLiquidationKeeper() {\n        _validateRole(Role.LIQUIDATION_KEEPER, \"LIQUIDATION_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Only allows addresses with the ADL_KEEPER role to call the function.\n     */\n    modifier onlyAdlKeeper() {\n        _validateRole(Role.ADL_KEEPER, \"ADL_KEEPER\");\n        _;\n    }\n\n    /**\n     * @dev Validates that the caller has the specified role.\n     *\n     * If the caller does not have the specified role, the transaction is reverted.\n     *\n     * @param role The key of the role to validate.\n     * @param roleName The name of the role to validate.\n     */\n    function _validateRole(bytes32 role, string memory roleName) internal view {\n        if (!roleStore.hasRole(msg.sender, role)) {\n            revert Errors.Unauthorized(msg.sender, roleName);\n        }\n    }\n}\n"
    },
    "contracts/role/RoleStore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../utils/EnumerableValues.sol\";\nimport \"./Role.sol\";\nimport \"../error/Errors.sol\";\n\n/**\n * @title RoleStore\n * @dev Stores roles and their members.\n */\ncontract RoleStore {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableValues for EnumerableSet.AddressSet;\n    using EnumerableValues for EnumerableSet.Bytes32Set;\n\n    EnumerableSet.Bytes32Set internal roles;\n    mapping(bytes32 => EnumerableSet.AddressSet) internal roleMembers;\n    // checking if an account has a role is a frequently used function\n    // roleCache helps to save gas by offering a more efficient lookup\n    // vs calling roleMembers[key].contains(account)\n    mapping(address => mapping (bytes32 => bool)) roleCache;\n\n    modifier onlyRoleAdmin() {\n        if (!hasRole(msg.sender, Role.ROLE_ADMIN)) {\n            revert Errors.Unauthorized(msg.sender, \"ROLE_ADMIN\");\n        }\n        _;\n    }\n\n    constructor() {\n        _grantRole(msg.sender, Role.ROLE_ADMIN);\n    }\n\n    /**\n     * @dev Grants the specified role to the given account.\n     *\n     * @param account The address of the account.\n     * @param roleKey The key of the role to grant.\n     */\n    function grantRole(address account, bytes32 roleKey) external onlyRoleAdmin {\n        _grantRole(account, roleKey);\n    }\n\n    /**\n     * @dev Revokes the specified role from the given account.\n     *\n     * @param account The address of the account.\n     * @param roleKey The key of the role to revoke.\n     */\n    function revokeRole(address account, bytes32 roleKey) external onlyRoleAdmin {\n        _revokeRole(account, roleKey);\n    }\n\n    /**\n     * @dev Returns true if the given account has the specified role.\n     *\n     * @param account The address of the account.\n     * @param roleKey The key of the role.\n     * @return True if the account has the role, false otherwise.\n     */\n    function hasRole(address account, bytes32 roleKey) public view returns (bool) {\n        return roleCache[account][roleKey];\n    }\n\n    /**\n     * @dev Returns the number of roles stored in the contract.\n     *\n     * @return The number of roles.\n     */\n    function getRoleCount() external view returns (uint256) {\n        return roles.length();\n    }\n\n    /**\n     * @dev Returns the keys of the roles stored in the contract.\n     *\n     * @param start The starting index of the range of roles to return.\n     * @param end The ending index of the range of roles to return.\n     * @return The keys of the roles.\n     */\n    function getRoles(uint256 start, uint256 end) external view returns (bytes32[] memory) {\n        return roles.valuesAt(start, end);\n    }\n\n    /**\n     * @dev Returns the number of members of the specified role.\n     *\n     * @param roleKey The key of the role.\n     * @return The number of members of the role.\n     */\n    function getRoleMemberCount(bytes32 roleKey) external view returns (uint256) {\n        return roleMembers[roleKey].length();\n    }\n\n    /**\n     * @dev Returns the members of the specified role.\n     *\n     * @param roleKey The key of the role.\n     * @param start the start index, the value for this index will be included.\n     * @param end the end index, the value for this index will not be included.\n     * @return The members of the role.\n     */\n    function getRoleMembers(bytes32 roleKey, uint256 start, uint256 end) external view returns (address[] memory) {\n        return roleMembers[roleKey].valuesAt(start, end);\n    }\n\n    function _grantRole(address account, bytes32 roleKey) internal {\n        roles.add(roleKey);\n        roleMembers[roleKey].add(account);\n        roleCache[account][roleKey] = true;\n    }\n\n    function _revokeRole(address account, bytes32 roleKey) internal {\n        roleMembers[roleKey].remove(account);\n        roleCache[account][roleKey] = false;\n\n        if (roleMembers[roleKey].length() == 0) {\n            if (roleKey == Role.ROLE_ADMIN) {\n                revert Errors.ThereMustBeAtLeastOneRoleAdmin();\n            }\n            if (roleKey == Role.TIMELOCK_MULTISIG) {\n                revert Errors.ThereMustBeAtLeastOneTimelockMultiSig();\n            }\n        }\n    }\n}\n"
    },
    "contracts/utils/BasicMulticall.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"../error/ErrorUtils.sol\";\n\n/**\n * @title BasicMulticall\n */\nabstract contract BasicMulticall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n\n        for (uint256 i; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                ErrorUtils.revertWithParsedMessage(result);\n            }\n\n            results[i] = result;\n        }\n\n        return results;\n    }\n}\n"
    },
    "contracts/utils/Calc.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/**\n * @title Calc\n * @dev Library for math functions\n */\nlibrary Calc {\n    using SignedMath for int256;\n    using SafeCast for uint256;\n\n    // this method assumes that min is less than max\n    function boundMagnitude(int256 value, uint256 min, uint256 max) internal pure returns (int256) {\n        uint256 magnitude = value.abs();\n\n        if (magnitude < min) {\n            magnitude = min;\n        }\n\n        if (magnitude > max) {\n            magnitude = max;\n        }\n\n        int256 sign = value == 0 ? int256(1) : value / value.abs().toInt256();\n\n        return magnitude.toInt256() * sign;\n    }\n\n    /**\n     * @dev Calculates the result of dividing the first number by the second number,\n     * rounded up to the nearest integer.\n     *\n     * @param a the dividend\n     * @param b the divisor\n     * @return the result of dividing the first number by the second number, rounded up to the nearest integer\n     */\n    function roundUpDivision(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    /**\n     * Calculates the result of dividing the first number by the second number,\n     * rounded up to the nearest integer.\n     * The rounding is purely on the magnitude of a, if a is negative the result\n     * is a larger magnitude negative\n     *\n     * @param a the dividend\n     * @param b the divisor\n     * @return the result of dividing the first number by the second number, rounded up to the nearest integer\n     */\n    function roundUpMagnitudeDivision(int256 a, uint256 b) internal pure returns (int256) {\n        if (a < 0) {\n            return (a - b.toInt256() + 1) / b.toInt256();\n        }\n\n        return (a + b.toInt256() - 1) / b.toInt256();\n    }\n\n    /**\n     * Adds two numbers together and return a uint256 value, treating the second number as a signed integer.\n     *\n     * @param a the first number\n     * @param b the second number\n     * @return the result of adding the two numbers together\n     */\n    function sumReturnUint256(uint256 a, int256 b) internal pure returns (uint256) {\n        if (b > 0) {\n            return a + b.abs();\n        }\n\n        return a - b.abs();\n    }\n\n    /**\n     * Adds two numbers together and return an int256 value, treating the second number as a signed integer.\n     *\n     * @param a the first number\n     * @param b the second number\n     * @return the result of adding the two numbers together\n     */\n    function sumReturnInt256(uint256 a, int256 b) internal pure returns (int256) {\n        return a.toInt256() + b;\n    }\n\n    /**\n     * @dev Calculates the absolute difference between two numbers.\n     *\n     * @param a the first number\n     * @param b the second number\n     * @return the absolute difference between the two numbers\n     */\n    function diff(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n    /**\n     * Adds two numbers together, the result is bounded to prevent overflows.\n     *\n     * @param a the first number\n     * @param b the second number\n     * @return the result of adding the two numbers together\n     */\n    function boundedAdd(int256 a, int256 b) internal pure returns (int256) {\n        // if either a or b is zero or if the signs are different there should not be any overflows\n        if (a == 0 || b == 0 || (a < 0 && b > 0) || (a > 0 && b < 0)) {\n            return a + b;\n        }\n\n        // if adding `b` to `a` would result in a value less than the min int256 value\n        // then return the min int256 value\n        if (a < 0 && b <= type(int256).min - a) {\n            return type(int256).min;\n        }\n\n        // if adding `b` to `a` would result in a value more than the max int256 value\n        // then return the max int256 value\n        if (a > 0 && b >= type(int256).max - a) {\n            return type(int256).max;\n        }\n\n        return a + b;\n    }\n\n    /**\n     * Returns a - b, the result is bounded to prevent overflows.\n     * Note that this will revert if b is type(int256).min because of the usage of \"-b\".\n     *\n     * @param a the first number\n     * @param b the second number\n     * @return the bounded result of a - b\n     */\n    function boundedSub(int256 a, int256 b) internal pure returns (int256) {\n        // if either a or b is zero or the signs are the same there should not be any overflow\n        if (a == 0 || b == 0 || (a > 0 && b > 0) || (a < 0 && b < 0)) {\n            return a - b;\n        }\n\n        // if adding `-b` to `a` would result in a value greater than the max int256 value\n        // then return the max int256 value\n        if (a > 0 && -b >= type(int256).max - a) {\n            return type(int256).max;\n        }\n\n        // if subtracting `b` from `a` would result in a value less than the min int256 value\n        // then return the min int256 value\n        if (a < 0 && -b <= type(int256).min - a) {\n            return type(int256).min;\n        }\n\n        return a - b;\n    }\n\n\n    /**\n     * Converts the given unsigned integer to a signed integer, using the given\n     * flag to determine whether the result should be positive or negative.\n     *\n     * @param a the unsigned integer to convert\n     * @param isPositive whether the result should be positive (if true) or negative (if false)\n     * @return the signed integer representation of the given unsigned integer\n     */\n    function toSigned(uint256 a, bool isPositive) internal pure returns (int256) {\n        if (isPositive) {\n            return a.toInt256();\n        } else {\n            return -a.toInt256();\n        }\n    }\n}\n"
    },
    "contracts/utils/Cast.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n/**\n * @title Cast\n * @dev Library for casting functions\n */\nlibrary Cast {\n    function toBytes32(address value) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(value)));\n    }\n}\n"
    },
    "contracts/utils/EnumerableValues.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/**\n * @title EnumerableValues\n * @dev Library to extend the EnumerableSet library with functions to get\n * valuesAt for a range\n */\nlibrary EnumerableValues {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /**\n     * Returns an array of bytes32 values from the given set, starting at the given\n     * start index and ending before the given end index.\n     *\n     * @param set The set to get the values from.\n     * @param start The starting index.\n     * @param end The ending index.\n     * @return An array of bytes32 values.\n     */\n    function valuesAt(EnumerableSet.Bytes32Set storage set, uint256 start, uint256 end) internal view returns (bytes32[] memory) {\n        uint256 max = set.length();\n        if (end > max) { end = max; }\n\n        bytes32[] memory items = new bytes32[](end - start);\n        for (uint256 i = start; i < end; i++) {\n            items[i - start] = set.at(i);\n        }\n\n        return items;\n    }\n\n\n    /**\n     * Returns an array of address values from the given set, starting at the given\n     * start index and ending before the given end index.\n     *\n     * @param set The set to get the values from.\n     * @param start The starting index.\n     * @param end The ending index.\n     * @return An array of address values.\n     */\n    function valuesAt(EnumerableSet.AddressSet storage set, uint256 start, uint256 end) internal view returns (address[] memory) {\n        uint256 max = set.length();\n        if (end > max) { end = max; }\n\n        address[] memory items = new address[](end - start);\n        for (uint256 i = start; i < end; i++) {\n            items[i - start] = set.at(i);\n        }\n\n        return items;\n    }\n\n\n    /**\n     * Returns an array of uint256 values from the given set, starting at the given\n     * start index and ending before the given end index, the item at the end index will not be returned.\n     *\n     * @param set The set to get the values from.\n     * @param start The starting index (inclusive, item at the start index will be returned).\n     * @param end The ending index (exclusive, item at the end index will not be returned).\n     * @return An array of uint256 values.\n     */\n    function valuesAt(EnumerableSet.UintSet storage set, uint256 start, uint256 end) internal view returns (uint256[] memory) {\n        if (start >= set.length()) {\n            return new uint256[](0);\n        }\n\n        uint256 max = set.length();\n        if (end > max) { end = max; }\n\n        uint256[] memory items = new uint256[](end - start);\n        for (uint256 i = start; i < end; i++) {\n            items[i - start] = set.at(i);\n        }\n\n        return items;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10,
      "details": {
        "constantOptimizer": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}