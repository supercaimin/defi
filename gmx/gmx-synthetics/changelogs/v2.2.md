# Function signature changes (Breaking)

1. Create Deposit, Order, Shift, Withdrawal, GlvDeposit, GlvWithdrawal structs now have a dataList attribute which needs to be passed in

   - This is mainly to allow custom data to be passed in if needed, which can then be used during a callback, it can be set to an empty array if no custom data is needed

2. Reader.getExecutionPrice now requires MarketUtils.MarketPrices prices to be passed in

   - Previously only Price.Props memory indexTokenPrice was needed but now MarketUtils.MarketPrices is required to accurately estimate price impact values

# Return value changes (Breaking)

1. pendingImpactAmount attribute added to Position struct

2. positionKey attribute added to ReaderPositionUtils.PositionInfo

3. Reader.getAccountOrders returns an OrderInfo struct with an orderKey value

4. Deposit, Order, Shift, Withdrawal, GlvDeposit, GlvWithdrawal structs now have a dataList and srcChainId attribute

   - dataList attribute described above
   - srcChainId has been added to support multichain, e.g. if an order was signed from Base then broadcast on Arbitrum, the srcChainId would be the chainId of Base
   - For same chain actions, i.e. a non multichain action, the srcChainId would be zero
     - Note that for events, the srcChainId can be zero even for a multichain action if the movement of funds occurred within the same chain

5. proportionalPendingImpactUsd, totalImpactUsd attributes added to PositionInfo.executionPriceResult

# Callback changes (Breaking)

Currently, when new attributes are added to Deposit, Withdrawal, Order, etc structs, integrations would need to update their contract callback handler code, because the callback function signature would change

To minimize this so that it is possible for structs to be updated without requiring contract changes from integrations, the callback functions are being changed

- Instead of a Deposit, Withdrawal, Order, etc struct, data will be passed to callbacks as EventUtils.EventLogData depositData / withdrawalData, orderData, etc

- EventUtils.EventLogData is a general struct, so even when new attributes are added, the callback function signature would not change

- The data can be accessed by using the "get" method

  - For example, depositData.addressItems.get("account")

- This transition can be supported by temporarily having two callback methods, one to support the old callback function signature, and the other to support the new callback function signature

- For example:

```
contract Callback {
    function afterDepositExecution(
        bytes32 key,
        Deposit.Props memory deposit,
        EventUtils.EventLogData memory eventData
    ) external {
        ...
    }

    function afterDepositExecution(
        bytes32 key,
        EventUtils.EventLogData memory depositData,
        EventUtils.EventLogData memory eventData
    ) external {
        ...
    }
}
```

# Mechanism Changes (Breaking)

1. Liquidations are now based on minCollateralFactorForLiquidation instead of minCollateralFactor

   - This allows for separate configurations where minCollateralFactor is used to control the max leverage when opening a position, and minCollateralFactorForLiquidation is used to control when a position can be liquidated

2. Pending Price Impact
   - Previous mechanism:
     - Price impact was charged on position increase and position decrease
     - For position decrease, there was a price impact cap, if the price impact exceeded the cap, then the price impact up to the capped amount would be charged, with the excess being later claimable if no price manipulation was detected
     - For position increase, the price impact was applied to calculate the executionPrice for validation against the acceptablePrice
     - For position decrease, the capped price impact was applied applied to calculate the executionPrice for validation against the acceptablePrice
   - New mechanism:
     - Price impact is stored on position increase, the total net price impact is charged on position decrease
       - The price impact is stored under a new field position.pendingImpactAmount
     - Net price impact on position decrease is calculated as: `(price impact due to position decrease) + (stored price impact) \* order.size / position.size`
     - The capping of price impact is applied on the net price impact on position decrease, with the excess being later claimable if no price manipulation was detected
       - The key for the configuration for the cap is MAX_POSITION_IMPACT_FACTOR
       - Note that the max positive impact can be different from the max negative impact
     - For both position increase and position decrease, the full uncapped price impact is applied to calculate the executionPrice for validation against the acceptablePrice
       - executionPrice for increase: oraclePrice adjusted by priceImpact for increase action
       - executionPrice for decrease: oraclePrice adjusted by priceImpact for decrease action
   - Previously for market decrease, stop-loss, take-profit orders, users could set an acceptablePrice close to the triggerPrice, and even if there was a high price impact, the order could still be executed, since the capped price impact would keep the calculated executionPrice close to the acceptablePrice
     - In the new logic, if it is desired to ensure that orders are executed, the acceptablePrice should be set to be far from the triggerPrice, since the executionPrice would no longer be based on the capped price impact
     - This change in logic is to allow users who do not want a high price impact, even if it will later be made claimable, to be able to specify this intention in the order’s acceptablePrice
     - For the majority of users, it is recommended to set an acceptablePrice far from the triggerPrice to allow orders to be executed, and to claim the price impact rebates later on
   - For limit increase orders, it may also make sense to set an acceptablePrice that is far from the triggerPrice, this would ensure that the orders can be executed, and price impact should in any case be claimable later on
     - A consideration for this may be what the cap percentage is, and whether that would be acceptable to majority of users, some users may still want the option to set an acceptablePrice that is close to the triggerPrice
   - When a user closes a position, funds are required to pay for the full price impact, including the price impact that would become claimable later on, this can lead to a user not being able to close their position, if:
     - A user’s pending price impact + price impact to close is very large, and liquidations are not triggered yet because price impact for liquidations is set to zero and pending price impact is not accounted for to trigger liquidations
     - The user’s position in this case would be considered to be in a liquidatable state, the liquidation is just not triggering and allows some room for the price to move in favour of the user
     - It is possible that by not closing earlier, the claimable amount for the user is less in comparison when they are liquidated, but this is a current limitation of how the contracts work and this case should be rare
3. Change of logic for capping of positive price impact
   - Previously, positive price impact was capped by the max positive price impact factor and the size of the position impact pool for both increase and decrease
   - With the new pending price impact logic:
     - Capping by max positive price impact factor still applies on increase and decrease
     - For decrease, the cap is on the total price impact (proportional price impact on increase + price impact on decrease)
     - Capping by position impact pool size applies only on decrease and not on increase
       - This is because on increase we do not know what the position impact pool size would be on decrease when the price impact is actually realized
     - Since impact may be pending and not realized, the impact pool may not have funds to pay for price impact, to help reduce the effect of this, there is now a lendable configuration, the amount lendable would be capped by the smaller of
       - MAX_LENDABLE_IMPACT_FACTOR multiplied by worth of longTokenAmount + shortTokenAmount
       - MAX_LENDABLE_IMPACT_USD
     - The code for these can be found in the usages of capPositiveImpactUsdByPositionImpactPool and capPositiveImpactUsdByMaxPositionImpact in PositionUtils.getExecutionPriceForIncrease, PositionUtils.getExecutionPriceForDecrease and DecreasePositionCollateralUtils
4. GM Token Price calculation
   - With the new pending price impact logic, the GM token price calculation needs to be updated to factor in a lentImpactPoolAmount value
   - This is for the case where a position has positive impact, but the price impact pool is insufficient to cover it due to the negative impact being pending and not yet paid to the position impact pool
   - In this case, the lentImpactPoolAmount is increased, this value will be decreased when the negative impact is paid
   - The updated logic is in MarketUtils.getPoolValueInfo
5. Withdrawals
   - With the introduction of lendable amounts for price impact, for withdrawals, there is an additional validation that after the withdrawal, the lent amount / worth of pool tokens does not exceed MAX_LENDABLE_IMPACT_FACTOR_FOR_WITHDRAWALS
   - The code for this is in ExecuteWithdrawalUtils.validateMaxLendableFactor
6. Gasless
   - Instead of userNonces, gasless routers now store used "digests" instead
   - So interfaces should use a randomly generated nonce instead of a sequentially incrementing nonce
   - This would help allow transactions to be created in parallel

# Internal Logic Changes

These changes still have a chance to be breaking, but the chance is lower because they are related to internal logic, so they would only have an effect if there is some dependency on deeper internal logic

1. Automated Price Impact Rebates
   - Previously price impact rebate percentages had to be manually set before price impact rebates could be claimable
   - This has been changed so that price impact rebates become automatically claimable after the CLAIMABLE_COLLATERAL_DELAY time has passed
   - A new CLAIMABLE_COLLATERAL_REDUCTION_FACTOR configuration can be used to reduce the claimable amount for a particular user
2. There is a different fee if an action improves or reduces balance, previously this was calculated using the price impact value, but in markets with zero price impact this was not accurate
   - The logic has been changed to be based directly on whether an action improves or reduces balance instead of the calculated price impact value
3. InsufficientGasForAutoCancellation, UnsupportedOrderTypeForAutoCancellation errors were added to differentiate between errors from autoCancelling vs regular cancellation of orders

4. cancellationReceiver was added to the OrderCreated event

5. uiFeeReceiver added to DepositCreated, WithdrawalCreated, ShiftCreated

6. The funding amount to be paid is now based on the size of the side paying instead of the size of the larger side
   - This results in a more accurate funding calculation, since funding may take some time to flip even after open interest has flipped
7. "Funding" event emitted with market and fundingFactorPerSecond attributes
8. "Borrowing" event emitted with market and borrowingFactorPerSecond attributes
9. When a user authorizes a subaccount, a subaccount integrationId can also be set using SubaccountRouter.setIntegrationId

   - The integrationId is an optional value that integrations can set
   - In case an integration is compromised, this allows the option to disable all subaccounts related to the integration

10. oracleProviderForTokenKey has been changed from oracleProviderForTokenKey(token) to oracleProviderForTokenKey(oracle, token)

- This allows providers to be configured per oracle
